<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Github Pages + Hexo搭建博客（三）]]></title>
      <url>%2F2016%2F12%2F06%2FGithub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[此篇博客主要介绍了自己的博客站点所使用的一些第三方服务的配置，以及主题的一些优化。当然，每个人的需要都不太相同，大家也可以根据自己的喜好去选择使用第三方服务来让自己的博客站点更完善更强大。 再次强调：在Hexo中有两份主要的配置文件，其名称都是_config.yml。其中，一份位于站点根目录下，主要包含Hexo本身的配置,我们称之为全局配置文件；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项,我们称之为主题配置文件。 博客图片存放Markdown编辑器支持插入图片，可以直接给出图片的链接，因此我们可以将图片存放在我们hexo项目的目录下，再填写对应的路径，也可以将其存放在云服务器上，然后给出链接。 在这里，我们介绍使用七牛云来进行图片托管。七牛云是国内领先的企业级云服务商,致力于打造以数据为核心的场景化PaaS服务，图片加载速度还不错，一般也不会出现图片挂掉的情况。 注册账号注册申请一个个人账号，然后激活邮箱完成注册。 官网地址：http://www.qiniu.com/ 存储图片（1）点击左侧菜单的对象存储 （2）点击上端的添加来创建存储空间 （3）填写好基本信息，点击确定创建 （4）来到新创建的存储空间，点击内容管理 （5）在内容管理中可以看到文件列表，点击上传文件 （6）可以设置上传的文件的前缀，以便进行分类管理 （7）点击关闭，回到内容管理页面查看上传的文件，复制图片链接 至此，我们就将我们博客需要的图片存储到了七牛云，然后我们只要将复制的图片链接插入到博客人文章中即可显示图片，感觉显示速度还是蛮快的。 配置第三方服务多说社会化评论（1）多说创建站点 多说官网：http://duoshuo.com/ 登录多说官网，点击主页的我要安装来到创建站点页面填写基本信息： 点击创建后出现：服务异常,请联系客服人员的错误不是因为真的出现异常，而是你填写的用户名或者其他信息不符合他的要求，只是他没有提示你，这是需要注意的地方。比如我遇到的是用户名不能使用‘-’中划线和‘_’下划线，或者多说域名填写格式错误。 （2）创建站点完成后在全局配置文件中新增duoshuo_shortname字段。 值设置成上一步中填写的值（红色方框框出部分的值） 例如： 1duoshuo_shortname: fzyLine （3）实现效果 多说分享多说分享必须与多说评论同时使用 编辑全局配置文件，添加字段 duoshuo_share，值为 true。 12# 多说分享服务duoshuo_share: true 实现效果： 不蒜子统计编辑全局配置文件中的busuanzi_count的配置项。 当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; #如果使用默认的，会显示图标 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; #如果使用默认的，会显示图标 site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; #如果使用默认的，会显示图标 page_pv_footer: 实现效果： 可以修改成如下的样子： 当site_uv: true时，代表在页面底部显示站点的UV值。即访客数： 1234# 效果：本站访客数12345人次site_uv: truesite_uv_header: 本站访客数site_uv_footer: 人次 当site_pv: true时，代表在页面底部显示站点的PV值。即总访问量： 1234# 效果：本站总访问量12345次site_pv: truesite_pv_header: 本站总访问量site_pv_footer: 次 当page_pv: true时，代表在文章页面的标题下显示该页面的PV值（阅读数）。1234# 效果：本文总阅读量12345次page_pv: truepage_pv_header: 本文总阅读量page_pv_footer: 次 站内搜索next主题的官方文档提供了几种实现搜索服务的方式，我们就使用配置最简单的Local Search，添加百度/谷歌/本地 自定义站点内容搜索。 （1）安装 hexo-generator-searchdb，在站点目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save （2）编辑全局配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 （3）实现效果： 开启打赏功能next主题开启打赏功能很简单，我们只需要在全局配置文件中填入微信和支付宝收款二维码图片地址即可开启该功能。先到微信和支付宝将自己收款二维码图片保存，我们同样可以将其存在七牛云上，然后贴到下面的配置文件里。 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: 微信当面付图片的urlalipay: 支付宝当面付图片的url 实现效果： Github pages + Hexo搭建静态博客站点的系列文章到这里就完结了，其实也算是一个很详细的教程了，花了一些时间来整理。之后可能不会再更新，但是，如果之后遇到一些问题或者有更好的推荐，可能还会再写。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法学习-刷题(十)]]></title>
      <url>%2F2016%2F12%2F04%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%8D%81%2F</url>
      <content type="text"><![CDATA[继续使用Python进行算法练习解题，此篇博客的5道题依然来自于牛客网（专业IT笔试面试备考平台）在线编程之：华为机试在线训练(6-10题)。 地址如下：https://www.nowcoder.com/ta/huawei 质数因子题目描述功能:输入一个正整数，按照从小到大的顺序输出它的所有质数的因子（如180的质数因子为2 2 3 3 5 ）,最后一个数后面也要有空格 详细描述： 函数接口说明： public String getResult(long ulDataInput) 输入参数： long ulDataInput：输入的正整数 返回值： String 输入描述: 输入一个long型整数 输出描述: 按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。 输入例子: 180 输出例子: 2 2 3 3 5 Python实现如果一个数是质数，那么它的倍数都不是质数。 我们不需要考虑是否是质数因子，因为每次得到的那个因子肯定是质数因子，其他数都可以从这些质数因子相乘得到。比如，i = 4能被整除的不可能出现，因为当i=2时已经被全求出来了。 这个题的思路其实不太好描述，还是看代码吧！ 123456789101112while True: try: n = int(raw_input()) i = 2 while n&gt;1: while(n%i == 0): print i, n = n/i i += 1 except: break python中print输出一行，如果想多次输出的内容不换行，可以在print后面加逗号. 取近似值题目描述写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。 输入描述: 输入一个正浮点数值 输出描述: 输出该数值的近似整数值 输入例子: 5.5 输出例子: 6 Python实现将输入的数据转换成float类型，再用round函数进行四舍五入，最后转换成int类型进行输出 123import sysnum = sys.stdin.readline() #读取一行数据print int(round(float(num))) 合并表记录题目描述数据表记录包含表索引和数值，请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。 输入描述: 先输入键值对的个数，然后输入成对的index和value值，以空格隔开 输出描述: 输出合并后的键值对（多行） 输入例子: 4 0 1 0 2 1 2 3 4 输出例子: 0 3 1 2 3 4 Python实现123456789101112131415161718#-*- coding:utf-8 -*-n = int(raw_input())dic = &#123;&#125; #构造字典for i in range(n): item = raw_input().split() #获取一行输入 key = int(item[0]) #得到该行的第一个数：键 value = int(item[1]) #得到该行的第二个数：值 if key in dic: #如果字典中已经存在这个键，则将其键值相加 dic[key] += value; else: #否则添加新的键值对 dic[key] = value;lst = dic.keys() #获取字典的所有键lst.sort() #对键进行排序for i in lst: #根据键从小到大输出 print i,dic[i] 提取不重复的整数题目描述输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。 输入描述: 输入一个int型整数 输出描述: 按照从右向左的阅读顺序，返回一个不含重复数字的新的整数 输入例子: 9876673 输出例子: 37689 Python实现12345678#-*- coding:utf-8 -*-input_str = raw_input()res = [] for i in list(reversed(input_str)): #反转字符串，并将其转换从列表 if i not in res: #去除重复的数字 res.append(i)print &quot;&quot;.join(res) #列表转字符串 字符个数统计题目描述编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0~127)。不在范围内的不作统计。 输入描述: 输入N个字符，字符在ACSII码范围内。 输出描述: 输出范围在(0~127)字符的个数。 输入例子: abc 输出例子: 3 Python实现123456789101112131415161718#-*- coding:utf-8 -*-import sysdef count(input_str): #自定义处理函数 s = [] cnt = 0 for ch in input_str: #去除重复的字符 if ch not in s: s.append(ch) for c in s: #统计个数 if (ord(c) &gt;=0 and ord(c) &lt;= 127): cnt+=1 print cntinput_str = sys.stdin.readline() #根据题目要求要实现多组数据的测试count(input_str) #调用函数处理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法学习-刷题(九)]]></title>
      <url>%2F2016%2F12%2F03%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%B9%9D%2F</url>
      <content type="text"><![CDATA[近来，越来越感受到Python的魅力，简洁的书写，相对高效的实现，写起来很舒服。以前只是用python做一些应用，也只是需要什么就去学什么，并没有真正系统地学习这门语言，现在结合书本和教学视频系统地进行学习，然后再通过Python来练习这些算法题，突然发现也是一种不错的学习方式。 下面的题目均来自牛客网（专业IT笔试面试备考平台）在线编程之：华为机试在线训练 地址如下：https://www.nowcoder.com/ta/huawei 字符串最后一个单词的长度题目描述计算字符串最后一个单词的长度，单词以空格隔开。 输入描述: 一行字符串，非空，长度小于5000。 输出描述: 整数N，最后一个单词的长度。 输入例子: hello world 输出例子: 5 Python实现这个题目本身就比较简单，python来实现则更加简单，因为python提供了很多方便快捷地方法，比如此题，split方法可以将我们输入的字符串切分成列表，然后取出列表最后一个元素即最后一个单词，再用len方法得到该单词的长度。列表中，负数索引是从列表右端即尾部开始，-1索引即为最后一个元素。 12mystr = raw_input()print len(mystr.split(&apos; &apos;)[-1]) 计算字符个数题目描述写出一个程序，接受一个有字母和数字以及空格组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。 输入描述: 输入一个有字母和数字以及空格组成的字符串，和一个字符。 输出描述: 输出输入字符串中含有该字符的个数。 输入例子: ABCDEF A 输出例子: 1 Python实现1234input_str = raw_input() #获取字符串tag = raw_input() #获取目标字符lst = list(input_str.lower()) #题目中说明不区分大小写，所以全部转换从小写，然后将字符串转换成列表print lst.count(tag.lower()) #统计字符在列表中出现的次数 明明的随机数题目描述明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。 Input Param n 输入随机数的个数 inputArray n个随机整数组成的数组 Return Value OutputArray 输出处理后的随机整数 注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 输入描述: 输入多行，先输入随机整数的个数，再输入相应个数的整数 输出描述: 返回多行，处理后的结果 123456789101112131415161718192021222324输入例子:11102040326740208930040015输出例子:10152032406789300400 Python实现12345678910111213141516import syswhile True: #题目要求有多组数据，需要循环 try: #捕获异常 n = int(raw_input()) #确定要输入多少个数据 l = [] for _ in range(0,n): k = sys.stdin.readline() #输入n个数 l.append(int(k)) res = list(set(l)) #集合是不重复的，这样做可以去除list中重复的元素 res.sort() #对去重后的列表进行排序 for i in res: #打印结果 print i except: break 字符串分隔题目描述 连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组； 长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。 输入描述: 连续输入字符串(输入2次,每个字符串长度小于100) 输出描述: 输出到长度为8的新字符串数组 输入例子: abc 123456789 输出例子: abc00000 12345678 90000000 python实现这里采用一种巧妙地办法，因为要以8为间隔输出字符串，所以我们先判断字符串长度是否为0，如果不为0，则在字符串末尾添加7个0，这样就不用考虑后面会缺几个0了，方便后面的输出，输出时我们只要以8为间隔输出，然后不满8个字符就不用输出了，肯定是末尾我们补上的多余的0了。 以下三种写法基本思路一样，关键在于输出的时候可以采用不同的办法进行处理。 （1）写法一 1234567891011121314# -*- coding: utf-8 -*- str1 = raw_input()str2 = raw_input() def splitstr(string): if(len(string) != 0): string += &quot;0000000&quot; while(len(string) &gt;= 8): #字符串长度大于等于8才打印出来 print string[0:8] #使用分片的方法切分字符串 string = string[8:] splitstr(str1)splitstr(str2) （2）写法二 123456789101112a = raw_input()b = raw_input() def substr(line): left = len(line)%8 if left!=0: line += &quot;0&quot; * (8-left) for i in range(len(line)/8): #字符串长度大于等于8才打印出来 print line[i*8 : (i+1)*8] #使用索引加分片的方法切分字符串 substr(a)substr(b) （3）写法三 123456789101112131415# -*- coding: utf-8 -*-import re str1 = raw_input()str2 = raw_input() def substr(string): if(len(string) != 0): string += &quot;0000000&quot; mylist = re.findall(r&apos;.&#123;8&#125;&apos;,string) #用正则表达式对字符串进行切分 for substr in mylist: #打印切分好的以8个字符为间隔的字符串 print substr substr(str1)substr(str2) 进制转换题目描述写出一个程序，接受一个十六进制的数值字符串，输出该数值的十进制字符串。（多组同时输入 ） 输入描述: 输入一个十六进制的数值字符串。 输出描述: 输出该数值的十进制字符串。 输入例子: 0xA 输出例子: 10 Python实现12345# -*- coding: utf-8 -*-import sysfor line in sys.stdin: print int(line, 16) 其中，for line in sys.stdin实现多行输入 这里并不是将line转换为16进制的数，而是说line就是一个16进制的数形式的字符串，int()函数将其用十进制数表示]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github Pages + Hexo搭建博客（二）]]></title>
      <url>%2F2016%2F12%2F03%2FGithub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[此篇博客主要讲解Hexo的站点配置、主题配置和使用以及博客文章的发布。 在Hexo中有两份主要的配置文件，其名称都是_config.yml。其中，一份位于站点根目录下，主要包含Hexo本身的配置,我们称之为全局配置文件；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项,我们称之为主题配置文件。 hexo的官方网站：https://hexo.io/，里面有hexo的详细说明文档，不过是英文的。没关系，英语不好的请往下看。 注意：配置文件中每个字段后面的冒号是英文格式的，且在其后要加一个空格再写值 比如： 1title: Myblog hexo的站点配置编辑hexo目录下的_config.yml文件，具体配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 站点信息配置，根据自己的需要进行修改title: Line&apos;s Blog #站点名，会在浏览器页面标签左上角显示subtitle: Love Coding,Enjoy Life #副标题description: fzy-line #对站点的描述，给搜索引擎看的，可以自定义author: Line #网站作者language: zh-Hans #网站语言timezone: Asia/Shanghai #时区avatar: /images/logo.jpg #网站logo，会在浏览器页面标签左上角显示# URL 博客地址,与申请的GitHub一致## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://fzy-line.github.io/root: /#博客链接格式permalink: :year/:month/:day/:title/ permalink_defaults:# Directory #目录设置，一般不修改source_dir: source #资源文件夹，放在里面的文件会上传到github中public_dir: public #公共文件夹，存放生成的静态文件tag_dir: tags #标签文件夹，默认是tags。实际存放在source/tags中。archive_dir: archives #档案文件夹，默认是archives。category_dir: categories #分类文件夹，默认是categories。实际存放在source/categories中。code_dir: downloads/code #代码文件夹，默认是downloads/codei18n_dir: :lang #国际化文件夹，默认跟language相同skip_render: #跳过指定文件的渲染，您可使用 glob 来配置路径。# Writing 这是文章布局、写作格式的定义，一般不修改new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag #分类和标签，一般不修改default_category: uncategorizedcategory_map:tag_map:# Date / Time format #日期、时间格式，一般不修改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD time_format: HH:mm:ss# Pagination #可根据自己需要修改## Set per_page to 0 to disable paginationper_page: 6 #分页，每页文章数量pagination_dir: page# Extensions #扩展## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next #博客主题 # Deployment 这里配置站点部署到Github，上一节中已经讲过## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:你的Github用户名.github.io.git branch: master hexo使用主题Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。 hexo官方主题下载地址：https://hexo.io/themes/，里面有多种多样的主题模板供大家选择。 这里推荐一款很火的主题：next，下面的配置也是以这个主题为例。如果你使用的是其他的主题，那么请你自己根据说明文档进行配置。 next主题的官网，有很详细的配置文档：http://theme-next.iissnan.com/ 下载主题next下载地址：https://github.com/iissnan/hexo-theme-next 到Gtihub下载此主题后解压，打开可以看到里面很多主题相关的文件，我们将此文件夹改名为next，然后将它复制到站点目录的/themes/目录下。 启用主题hexo默认是使用的landscape主题，我们可以在站点目录下的/themes/目录下看到landscape文件夹。 我们的themes文件夹里可以放很多主题的文件夹，但是实际上我们的网站采用哪一个主题，这是需要我们进行配置的，打开编辑全局配置文件，找到下面的内容： 1234# Extensions #扩展## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next #博客主题，默认是landscape 在theme字段这里填上你下载的主题的文件夹的名字，例如我们使用next主题就填上next。这样配置文件就和我们的主题文件关联起来了。 配置主题配置文件主题配置文件位于站点目录下的/themes/next/目录下，打开编辑，这里我们只贴出需要修改的地方进行介绍，如下： （1）配置基本信息 1234567891011# 网站图标，将其放在hexo站点/source/目录下favicon: /logo.jpg# 关键词，例如下面是我写的keywords: &quot;Python,Life,Android&quot;# 网站建立时间，显示在页面底部since: 2016# 网站版权声明，显示在页面底部copyright: true （2）选择外观样式 目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 找到主题配置文件的如下三行，其中#号表示注释，要启用哪一种样式就把#号去掉即可。 1234# Schemes#scheme: Muse#scheme: Mistscheme: Pisces （3）设置菜单 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，它将用于匹配图标以及翻译。 12345678menu: home: / archives: /archives categories: /categories tags: /tags about: /about #sitemap: /sitemap.xml #commonweal: /404.html 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 1234567891011menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat 测试配置效果123$ hexo clean #用于清除缓存$ hexo generate #生成静态网页$ hexo server #开启本地预览 访问：http://localhost:4000/ 查看效果，如下图： 解决遇到的问题到这里会发现点击左侧菜单的分类、标签和关于会提示找不到页面。 这是因为我们只是创建了菜单，还没有创建相应的页面。 新建页面的hexo命令是： 1$ hexo new page &quot;pageName&quot; 我们新建分类、标签、关于页面： 1$ hexo new page &apos;categories&apos; 1$ hexo new page &apos;tags&apos; 1$ hexo new page &apos;about&apos; 分别执行完这三条命令后，我们会发现站点目录下的/source/目录下多了三个文件夹：categories，tags，about，每个文件夹里面都会生成一个index.md文件，如下： 默认都只会生成title和date字段，我们要为其添加上type字段，并赋值。 注意：博客文章的抬头信息中每个字段后面的冒号是英文格式的，而且其后要加一个空格再写值 categories下的index.md： 12345---title: categoriesdate: 2016-12-02 23:28:27type: categories--- tags下的index.md： 12345---title: tagsdate: 2016-12-02 23:31:23type: tags--- about下的index.md： 12345---title: aboutdate: 2016-12-02 23:31:23type: about--- 这样我们的这几个页面也就没有问题了。至此，基本的配置也就完成了，接下来介绍如何写博客与发布博客。 发布博客新建博客文章1$ hexo new &quot;postName&quot; #新建文章 实例： 新建博客《我的第一篇博客》 1$ hexo new &quot;我的第一篇博客&quot; 到站点目录下的/source/_posts/目录下可以看到生成了名为：我的第一篇博客.md的文件，这是Markdown格式的文件，可以用sublime text3或者notepad++等编辑器打开，也可以下载一个MarkdownPad来编辑Markdown文件。 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 如果你没有使用过Markdown编辑器，那请你自己去学习一下Markdown语法。 Markdown 语法说明(简体中文版)：http://www.appinn.com/markdown/ 编辑博客Hexo默认新建的文章抬头已有title、date、tags等属性，可能缺乏categories和meta标签，想要指定目录就需要添加categories属性，而meta标签则是为了便于搜索引擎的收录。如下： 12345---title: 我的第一篇博客date: 2016-12-02 23:44:20tags: #文章标签 可以省略--- tags字段是文章的标签，可以指定标签也可以不指定，如果要指定多个标签需要这样做： 1tags: [Linux,Http,网络] 我们可以添加上categories字段，对博客进行分类管理，然后点击主页左侧菜单的分类就可看到具体的分类。例如： 1categories: Linux 如何实现上图的阅读全文功能？ 在自己喜欢的位置添加一个：1&lt;!--more--&gt; 即可，主题会自动识别这个标签，生成对应的阅读全文按钮。 123以上是文章摘要&lt;!--more--&gt;以下是余下全文 发布博客1$ hexo clean #清除缓存 网页正常情况下可以忽略此条命令 1$ hexo generate #生成静态页面至public目录 写好之后可以现在本地预览，确定无误之后再部署到Github上。 1$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） 1$ hexo deploy #将.deploy目录部署到GitHub 需要说明的是： 我们博客文章的编写都是Markdown文件，但是发布到github上的其实是html文件，将Markdown转换成html这个工作我们只要输入hexo generate命令即可，hexo会帮我们完成转换。 hexo命令简写形式1234hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot;hexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 下一篇博客主要讲解如何优化next主题，使用主题提供的一些第三方功能。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python序列详解-列表]]></title>
      <url>%2F2016%2F12%2F01%2FPython%E5%BA%8F%E5%88%97%E8%AF%A6%E8%A7%A3-%E5%88%97%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[基本介绍 列表是最常用的Python数据类型。 列表是可变的。 列表的数据项不需要具有相同的类型。 列表用[]符号或list()创建。 基本的列表操作list函数将序列转换成列表。 12&gt;&gt;&gt; list(&apos;Hunau&apos;)[&apos;H&apos;, &apos;u&apos;, &apos;n&apos;, &apos;a&apos;, &apos;u&apos;] list函数适用于所有类型的序列，而不只是字符串。 赋值使用列表的索引标记来为某个特定的、位置明确的元素赋值。 1234&gt;&gt;&gt; lst = [1,2,3]&gt;&gt;&gt; lst[2] = 4&gt;&gt;&gt; lst[1, 2, 4] 不能为一个位置不存在的元素进行赋值。 分片赋值（1）通过分片赋值进行替换 可以一次为多个元素赋值，并且使用与原序列不等长的序列将分片替换： 1234567&gt;&gt;&gt; lst = [1, 2, 3, 4]&gt;&gt;&gt; lst[1:3] = list(&apos;xx&apos;) #等长替换&gt;&gt;&gt; lst[1, &apos;x&apos;, &apos;x&apos;, 4]&gt;&gt;&gt; lst[1:] = list(&apos;python&apos;) #不等长替换&gt;&gt;&gt; lst[1, &apos;p&apos;, &apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;] （2）通过分片赋值进行插入 可以在不替换任何原有元素的情况下插入新的元素： 1234&gt;&gt;&gt; lst = [1,6]&gt;&gt;&gt; lst[1:1] = [2, 3, 4, 5]&gt;&gt;&gt; lst[1, 2, 3, 4, 5, 6] （3）通过分片赋值进行删除 1234&gt;&gt;&gt; lst = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; lst[1:5] = []&gt;&gt;&gt; lst[1, 6] 删除元素有个方法可以从列表中按给定的索引而不是值来删除一个子项：del 语句。 语句del还可以从列表中删除切片或清空整个列表. 12345678910&gt;&gt;&gt; lst = [1,2,3,4,5,6,7,8]&gt;&gt;&gt; del lst[1] #删除一个元素&gt;&gt;&gt; lst[1, 3, 4, 5, 6, 7, 8]&gt;&gt;&gt; del lst[0:2] #借助分片删除多个元素&gt;&gt;&gt; lst[4, 5, 6, 7, 8]&gt;&gt;&gt; del lst[:] #删除列表的所有元素&gt;&gt;&gt; lst[] del也可以用来删除整个变量！ 列表对象方法append把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。它是直接修改列表，而不是返回一个新的列表。 1234&gt;&gt;&gt; lst = [1,2,&apos;x&apos;,&apos;y&apos;]&gt;&gt;&gt; lst.append(3)&gt;&gt;&gt; lst[1, 2, &apos;x&apos;, &apos;y&apos;, 3] extend将一个给定列表中的所有元素都添加到另一个列表中，相当于 a[len(a):] = L 。 12345&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[1, 2, 3, 4, 5, 6] 对比连接操作： 1234&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; a + b[1, 2, 3, 4, 5, 6] 看似两种方法得到的结果一样，实则不然。extend与连接操作最大的区别在于：extend方法修改了被扩展的序列（即上例中的a列表），而使用+号进行连接操作则会返回一个新的列表。 insert在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 lst.insert(0, x) 会插入到整个列表之前，而 lst.insert(len(lst), x) 相当于lst.append(x)。 1234567&gt;&gt;&gt; lst = [2,4]&gt;&gt;&gt; lst.insert(0,1)&gt;&gt;&gt; lst[1, 2, 4]&gt;&gt;&gt; lst.insert(3,5)&gt;&gt;&gt; lst[1, 2, 4, 5] count统计某个元素在列表中出现的次数。 1234567&gt;&gt;&gt; lst = [1,2,1,&apos;x&apos;,&apos;x&apos;,[&apos;z&apos;,&apos;y&apos;],[&apos;z&apos;,&apos;y&apos;]]&gt;&gt;&gt; lst.count(1)2&gt;&gt;&gt; lst.count(&apos;x&apos;)2&gt;&gt;&gt; lst.count([&apos;z&apos;,&apos;y&apos;])2 remove删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。 1234&gt;&gt;&gt; lst = [1, 2, &apos;z&apos;, &apos;y&apos;, &apos;z&apos;]&gt;&gt;&gt; lst.remove(&apos;z&apos;)&gt;&gt;&gt; lst[1, 2, &apos;y&apos;, &apos;z&apos;] index返回列表中第一个值为x的元素的索引。如果没有匹配的元素就会返回一个错误。 123&gt;&gt;&gt; lst = [1, 2, &apos;z&apos;, &apos;y&apos;, &apos;z&apos;]&gt;&gt;&gt; lst.index(&apos;z&apos;)2 pop从列表的指定位置删除元素，并将其返回。如果没有指定索引，pop() 返回最后一个元素。元素随即从列表中被删除。 12345&gt;&gt;&gt; lst = [1,2,3]&gt;&gt;&gt; lst.pop()3&gt;&gt;&gt; lst[1, 2] 把列表当作堆栈使用 用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来。 123456789&gt;&gt;&gt; stack = [1,2]&gt;&gt;&gt; stack.append(3)&gt;&gt;&gt; stack.append(4)&gt;&gt;&gt; stack.pop()4&gt;&gt;&gt; stack.pop()3&gt;&gt;&gt; stack[1, 2] reverse就地倒排列表中的元素。该方法直接修改列表，而不返回值。 1234&gt;&gt;&gt; lst = [1,2,3,4]&gt;&gt;&gt; lst.reverse()&gt;&gt;&gt; lst[4, 3, 2, 1] sort在原位置对列表中的元素就地进行排序。 1234&gt;&gt;&gt; lst = [2,1,5,3,4]&gt;&gt;&gt; lst.sort()&gt;&gt;&gt; lst[1, 2, 3, 4, 5] 在原位置排序意味着改变原来的列表，而不是返回一个已排序的列表副本。以下操作是错误的： 1234&gt;&gt;&gt; lst = [2, 1, 5, 4, 3]&gt;&gt;&gt; x = lst.sort() #这样做是错误的&gt;&gt;&gt; print xNone 因为sort方法修改了lst列表，然后返回了空值，所以x的值为None。 可以用sorted()方法来获得已排序的列表副本 123456&gt;&gt;&gt; lst = [2, 1, 5, 4, 3]&gt;&gt;&gt; x = sorted(lst)&gt;&gt;&gt; lst[2, 1, 5, 4, 3]&gt;&gt;&gt; x[1, 2, 3, 4, 5] sorted()方法可以用在任何数据类型的序列中，返回的总是一个列表形式： 12&gt;&gt;&gt; sorted(&apos;python&apos;)[&apos;h&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;t&apos;, &apos;y&apos;] 高级排序sort函数是list类的一个方法，其中，包含三个参数cmp，key，reverse：cmp用于指定排序的大小比较算法；key用于制定排序的维度和优先级别；reverse说明是否是逆序排列（True表示从大到小）. 参数reverse1234567891011&gt;&gt;&gt; lst = [1, 5, 3, 2, 4]&gt;&gt;&gt; sorted(lst) #默认升序[1, 2, 3, 4, 5]&gt;&gt;&gt; sorted(lst, reverse = True) #降序排列[5, 4, 3, 2, 1]&gt;&gt;&gt; lst.sort()&gt;&gt;&gt; lst[1, 2, 3, 4, 5]&gt;&gt;&gt; lst.sort(reverse = True)&gt;&gt;&gt; lst[5, 4, 3, 2, 1] 参数key按字符串长度排序 123456&gt;&gt;&gt; lst = [&apos;c&apos;, &apos;java&apos;, &apos;python&apos;,&apos;c++&apos;]&gt;&gt;&gt; sorted(lst, key = len) [&apos;c&apos;, &apos;c++&apos;, &apos;java&apos;, &apos;python&apos;]&gt;&gt;&gt; lst.sort(key = len)&gt;&gt;&gt; lst[&apos;c&apos;, &apos;c++&apos;, &apos;java&apos;, &apos;python&apos;] 将列表中的每个元素变为小写，再按每个元素中的每个字母的ascii码从小到大排序 123456&gt;&gt;&gt; lst = [&apos;zZ&apos;,&apos;bb&apos;,&apos;XX&apos;,&apos;Aa&apos;]&gt;&gt;&gt; sorted(lst, key = str.lower)[&apos;Aa&apos;, &apos;bb&apos;, &apos;XX&apos;, &apos;zZ&apos;]&gt;&gt;&gt; lst.sort(key = str.lower)&gt;&gt;&gt; lst[&apos;Aa&apos;, &apos;bb&apos;, &apos;XX&apos;, &apos;zZ&apos;] 按自定义函数排序 12345&gt;&gt;&gt; def lastChar(s): return s[-1] &gt;&gt;&gt; lst = [&apos;abc&apos;,&apos;b&apos;,&apos;AAz&apos;,&apos;ef&apos;] &gt;&gt;&gt; sorted(lst, key = lastChar) ##按列表e中每个元素的最后一个字母的ascii码从小到大排序[&apos;b&apos;, &apos;abc&apos;, &apos;ef&apos;, &apos;AAz&apos;] 按字典属性排序 12345&gt;&gt;&gt; lst = [&#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:20&#125;,&#123;&apos;name&apos;:&apos;xxx&apos;,&apos;age&apos;:30&#125;,&#123;&apos;name&apos;:&apos;yyy&apos;,&apos;age&apos;:25&#125;] #列表中的元素为字典 &gt;&gt;&gt; def age(s): return s[&apos;age&apos;] &gt;&gt;&gt; sorted(lst,key = age) #自定义函数按列表f中字典的age从小到大排序 [&#123;&apos;age&apos;: 20, &apos;name&apos;: &apos;fzy&apos;&#125;, &#123;&apos;age&apos;: 25, &apos;name&apos;: &apos;yyy&apos;&#125;, &#123;&apos;age&apos;: 30, &apos;name&apos;: &apos;xxx&apos;&#125;]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github Pages + Hexo搭建博客（一）]]></title>
      <url>%2F2016%2F11%2F30%2FGithub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[写在前面的话阮一峰说过，喜欢写Blog的人，会经历三个阶段。 （1）第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。 （2）第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。 （3）第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 我自己就是从一开始在CSDN写，后来租用阿里云的服务器，用WordPress搭建自己的博客，再到现在整体搬迁到Github上来，整个过程是一种锻炼，也是一种成长。 GitHub Pages是什么？GitHub Pages本用于介绍托管在GitHub的项目， 不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。 为什么选择GitHub Pages？ GitHub Pages有300M免费空间，搭建的博客可以很方便的进行管理，并且保存可靠； GitHub 是趋势，GitHub上面有很多大牛，学IT的人应该尽早融入这样的环境， 程序员应该学会使用Git来管理项目，熟悉版本控制。 Github上有很多的开源项目，多学习学习，眼界会开阔很多； 接下来应该怎么做？Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托管在github。我们要使用Github Pages + Hexo搭建博客站点，就必须注册Github账号，安装git、node.js以及hexo等，接下来就一起来实践吧！ Github注册与配置注册如果你还没有自己的Github账号，那请到Github官网注册账号：https://github.com/ 注册成功后github会发送验证邮件到你的邮箱，请查收邮件并进行验证。 新建版本库注册完成后，点击Start a project来新建一个版本库 如果你已经注册，则在自己的主页，点击”New repository”，即可新建一个版本库 输入Repository name:yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了) 启用GitHub Page进入版本库后，点击右上方的setting 下来到Githubs pages栏目，点击Launch automatic page generator 来到New user site页面后点击右下角的Continue to layouts 最后点击”Publish page”,发布github默认生成的一个静态站点 至此，我们已经配置好了github默认的静态站点，并且可以访问：你的github用户名.github.io测试我们刚刚建立好的站点主页。 下载并安装Git下载根据自己电脑操作系统的位数到git官网下载相应的版本： https://git-scm.com/download/win 安装根据自己的需要安装到相应的路径下，其他的一路点击next即可 配置环境变量选中桌面图标计算机，右键选择属性，打开左边的高级系统设置，打开弹出窗口的环境变量，找到path进行编辑。 找到git的安装目录，将其复制后粘贴到path后面。注意每一个加进来的路径后面都要带英文格式的分号。 安装与配置过程可参考图文教程：git的安装和配置 测试是否安装成功windows+R输入cmd打开命令提示符窗口，输入如下命令： 1git --version 若安装成功会打印出本机安装的git的版本。 添加SSH KEY到GithubSSH Key是一个认证，让github识别绑定这台机器，允许这台机器提交。 （1）检查本机是否有SSH KEY设置 打开git bash，输入cd ~/.ssh 或cd .ssh 如果没有则提示： No such file or directory 如果有则进入~/.ssh路径下（ls查看当前路径文件，rm * 删除所有文件） （2）配置生成SSH KEY 12345678910$ cd ~ #保证当前路径在”~”下$ ssh-keygen -t rsa -C &quot;这里填写你的邮箱地址&quot;Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/xxxx_000/.ssh/id_rsa): #不填直接回车Enter passphrase (empty for no passphrase): #输入密码（可以为空）Enter same passphrase again: #再次确认密码（可以为空）Your identification has been saved in /c/Users/xxxx_000/.ssh/id_rsa. #生成的密钥Your public key has been saved in /c/Users/xxxx_000/.ssh/id_rsa.pub. #生成的公钥The key fingerprint is:e3:51:33:xx:xx:xx:xx:xxx:61:28:83:e2:81 xxxxxx@yy.com 至此，已经生成ssh key，其存放路径为：c:/Users/你电脑的用户名/.ssh/下。 注释：可生成ssh key自定义名称的密钥，默认id_rsa。 （3）复制SSH KEY到Github 到C盘你的用户目录下找到.ssh文件夹，查看里面是否有id_rsa和id_rsa.pub这两个文件。 登录GitHub系统；点击右上角账号头像的“▼”→Settings→SSH kyes→Add SSH key，Title自定义，复制id_rsa.pub的公钥内容到GitHub中Add an SSH key的key输入框，最后“Add Key”。 （4）配置账户 123$ git config --global user.name “your_username” #设置用户名$ git config --global user.email “your_registered_github_Email” #设置邮箱地址(建议用注册giuhub的邮箱) （5）测试SSH KEY是否设置成功 1$ ssh -T git@github.com 接下来会返回一些信息，并需要你输入一次yes，若生成ssh key时设置有密码则还会让你输入生成ssh key时设置的密码。 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. #出现词句话，说明设置成功。 SSH-KEY的生成与配置可参考图文教程window下配置SSH连接GitHub、GitHub配置ssh key： 下载并安装node.js下载根据自己电脑操作系统的位数到git官网下载相应的版本： https://nodejs.org/en/download/ 安装根据自己的需要安装到响应的地方，其他的一路点击next即可 配置环境变量选中桌面图标计算机，右键选择属性，打开左边的高级系统设置，打开弹出窗口的环境变量，找到path进行编辑。 找到node.js的安装目录，将其复制后粘贴到path后面。注意每一个加进来的路径后面都要带英文格式的分号。 测试是否安装成功windows+R输入cmd打开命令提示符窗口，输入如下命令： 1node -v 若安装成功会打印出本机安装的node.js的版本。 安装和配置hexohexo是基于node.js的静态博客，官网也是搭建在GitHub上。 安装在你喜欢的路径下新建一个文件夹blog，用来存放博客的文件，在此文件夹中右键打开Git Bash 输入如下指令进行安装： 1$ npm install -g hexo-cli 如果执行这条命令时长时间未成功，那么请先使用下面的命令将npm镜像源更改为国内的镜像，再执行上面的安装命令，因为国外的镜像源很有可能被墙了。1npm config set registry https://registry.npm.taobao.org 初始化hexo1$ hexo init hexo 这里会将Github上的hexo项目clone下来，得到hexo文件夹。 初始化成功后会在最后打印一行：INFO Start blogging with Hexo! 安装依赖文件进入到hexo文件夹 1$ cd hexo 安装依赖文件： 1$ npm install 部署形成文件：1$ hexo generate 本地测试 1$ hexo server 在浏览器输入：http://localhost:4000/ 即可访问到我们搭建好的hexo站点。 将本地hexo项目托管到Github修改全局配置文件_config.yml说明： hexo文件夹下一个_config.yml，我们称之为全局配置文件，在每个主题文件夹内还会有一个_config.yml文件，我们称之为主题配置文件。 用sublime text3或者notepad++等编辑器打开hexo文件夹下的_config.yml文件。 注意：配置文件中每个字段后面的冒号是英文格式的，且在其后要加一个空格再写值 编辑最后面的deploy属性，加入代码： 123type: gitrepository: https://github.com/你的Github用户名/你的Github用户名.github.io.gitbranch: master type使用是git。 repository属性改成你的刚才创建仓库git地址。 分支branch填写master。 安装hexo-deployer-git插件1$ npm install hexo-deployer-git --save 部署到Github上依次执行以下三条命令： 1$ hexo clean #清除缓存 网页正常情况下可以忽略此条命令 1$ hexo generator #生成静态页面至public目录 1$ hexo deploy #将.deploy目录部署到GitHub 执行hexo deploy命令之后，如果最后一行打印出如下信息则表示部署成功 1INFO Deploy done: git 然后你再去访问你创建的Github pages地址，也就是：你的Github用户名.github.io，即可看到你本地的hexo项目已经被部署到github上去了。此时博客的默认主题是landscape，即上面本地测试时的样子。 此篇博客就讲解到这里，下一篇博客主要讲解hexo主题的配置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法学习-刷题(八)]]></title>
      <url>%2F2016%2F11%2F06%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%85%AB%2F</url>
      <content type="text"><![CDATA[二维数组中查找整数牛客网在线编程：剑指Offer第1题 题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解法一12345public class Solution &#123; public boolean Find(int [][] array,int target) &#123; for(int i = 0;i &lt; array[0].size()) &#125;&#125; 解法二把每一行看成有序递增的数组，利用二分查找，通过遍历每一行得到答案，时间复杂度是nlogn。 12345678910111213141516171819public class Solution &#123; public boolean Find(int [][] array,int target) &#123; for(int i=0;i&lt;array.length;i++)&#123; int low=0; int high=array[i].length-1; while(low&lt;=high)&#123; int mid=(low+high)/2; if(target&gt;array[i][mid]) low=mid+1; else if(target&lt;array[i][mid]) high=mid-1; else return true; &#125; &#125; return false; &#125;&#125; 解法三利用二维数组由上到下，由左到右递增的规律，那么选取右上角或者左下角的元素a[row][col]与target进行比较，当target小于元素a[row][col]时，那么target必定在元素a所在行的左边,即col–；当target大于元素a[row][col]时，那么target必定在元素a所在列的下边,即row++； 123456789101112131415public class Solution &#123; public boolean Find(int [][] array,int target) &#123; int row=0; int col=array[0].length-1; while(row&lt;=array.length-1&amp;&amp;col&gt;=0)&#123; if(target==array[row][col]) return true; else if(target&gt;array[row][col]) row++; else col--; &#125; return false; &#125;&#125; myPowLeetCode第2题 题目描述Implement pow(x, n). Subscribe to see which companies asked this question 解法一用递归方法求n个x的乘积，注意考虑n的正负号，时间复杂度为O(n)。 Leetcode提交超时的代码： 1234567double myPow(double x, int n) &#123; if(n==0) return 1.0; if(n&lt;0) return 1.0/myPow(x,-n); return x*myPow(x,n-1);&#125; 解法二考虑到n个x相乘式子的对称关系，可采用如下方法： Leetcode AC的代码： 12345678910double myPow(double x, int n) &#123; if(n==0) return 1.0; if(n % 2 == 0) &#123; return myPow(x * x, n / 2); &#125; else &#123; return (n &gt; 0 ? x : 1.0 / x ) * myPow(x * x, n / 2) ; &#125; &#125; 3、Reverse Integer LeetCode第7题 题目描述： Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 一般的思路反转整数，只要从低位开始依次取得整数的各个位，然后再按顺序整合成整数即可。 12345678int reverse(int x) &#123; int num = 0; while(x)&#123; num = num*10 + x%10; x = x/10; &#125; return num;&#125; 但是，此题特别要考虑结果溢出的问题！ LeetcodeAC的代码1234567891011int reverse(int x) &#123; int num = 0,tmp; while(x)&#123; tmp = num; num = num*10 + x%10; if((num-x%10)/10 != tmp) //判断是否溢出 return 0; x = x/10; &#125; return num;&#125; 计算字符个数牛客网华为机试在线训练第2题 题目描述写出一个程序，接受一个有字母和数字以及空格组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。 输入一个有字母和数字以及空格组成的字符串，和一个字符。 输出输入字符串中含有该字符的个数。 输入例子:ABCDEFA 输出例子:1 此题十分简单，遍历字符串，将目标字符与字符串的每个字符进行比较，相等则计数加1，当然，要注意的是题目中给出的不区分大小写以及获取输入的方法。 牛客网AC的代码123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int i,len=0,cnt=0; char str[1000],c; gets(str); scanf(&quot;%c&quot;,&amp;c); if(c&gt;=65&amp;&amp;c&lt;=90) //目标字符如果是字母则转换成小写 c+=32; len = strlen(str); for(i=0;i&lt;len;i++)&#123; if(str[i]&gt;=65&amp;&amp;str[i]&lt;=90) //字符串中的字符如果是字母则统一转换成小写 str[i]+=32; if(str[i]==c)&#123; //进行比较 cnt++; &#125; &#125; printf(&quot;%d&quot;,cnt); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第三届电子协会成立大会发言]]></title>
      <url>%2F2016%2F10%2F23%2F%E7%AC%AC%E4%B8%89%E5%B1%8A%E7%94%B5%E5%AD%90%E5%8D%8F%E4%BC%9A%E6%88%90%E7%AB%8B%E5%A4%A7%E4%BC%9A%E5%8F%91%E8%A8%80%2F</url>
      <content type="text"><![CDATA[时光飞逝，电子协会已经走到第三届，作为协会创办和发展的见证者，很高兴看到协会现在的样子，希望协会能够在第三届的带领下越办越好，也希望大家能够将协会的精神一届届地传承下去。我也很荣幸能够受邀作为第二届电子协会的代表在第三届成立大会上发言，以下是发言稿正文。 尊敬的各位领导、老师，亲爱的同学们，大家晚上好，我是13级信息工程3班的樊振宇，很荣幸能够作为第二届电子协会的代表在这里发言。时光飞逝，转眼一年又过去了，依稀记得第二届电子协会成立大会的场景，去年的成立大会比较简短，今年呢，我们第三届的理事们精心准备，付出了很多，所以也希望我能和大家多分享一点。其实呢，作为协会和实验室的老学长，我对这里已经有很深的感情，所以确实也有很多话想要和大家说。 首先，欢迎各位学弟学妹们加入电子协会这个大家庭，也祝贺第三届电子协会在今天成立。我自己是在大一下学期通过学院的实验室宣讲进入了电子设计创新实验室，那个时候电子协会还没有成立。刚进实验室的时候是12级电信2班的欧超学长带的我，他给我提供了很多帮助，也教会了我一些基本的技术，所以我一直也很感谢他。在这个实验室我不仅可以得到丰富的学习资源，还有热情的学长学姐们的指导和帮助，我当时就觉得这就是我理想的实验室。直到14年10月的时候，在实验室几位学长学姐的倡导下，成立了电子协会，成立的初衷也是积聚更多的电子人才，为实验室的发展打下良好的基础，因此，电子协会和电子设计创新实验室是一个有机的整体。 从我加入实验室，然后经历第一届、第二届电子协会的发展，再到今天第三届电子协会成立，这一路走来，我自己对于这个实验室和协会的发展也投入了很多的精力和感情，当然，在此期间，我也获得了技术与管理的双重成长，还结识了很多志同道合的朋友，这就是我在这里的一些收获。我也相信，如果大家也能够在协会和实验室一直坚持下去，等到你们大四的时候，一定也会有同样的收获和感触。 总结我的大学生活，实验室和协会是非常重要的一部分，也是非常精彩的一部分。深深地记得大二的那个暑假，参加全国电子设计大赛，虽有遗憾，但是一个暑假精心的准备，和指导老师一起四天三夜的连续奋斗至今还历历在目。大学里，你可能会和朋友去KTV通宵嗨唱，也可能会去网吧通宵游戏，但是你很难有机会和老师一起为了比赛而通宵奋斗。另外，我们实验室的小伙伴之间也建立了深厚的友谊，比如我们经常一起打球，有机会还会出去各种浪。总之，这里有学习有奋斗有工作有生活更有快乐，这就是我大学最难忘的实验室时光的一部分，这也是有青春、有活力的电子协会的一部分。虽然现在我们把接力棒交给了第三届的理事们，但是不管以后我们在哪里，我们也会像12级已经毕业的学长学姐们那样，始终关心支持实验室和协会的发展，希望协会的这些优秀的传统能够一届届传递下去。我想，这样一届一届的人才积淀，对于以后实验室和协会成员的考研、找工作或者是创业都会有所帮助，因为我们都来自于电子协会这个大家庭。 然后，作为第二届电子协会管理层的代表，我很高兴能够看到电子协会这一年取得的发展。这些成绩的取得来之不易，一方面，离不开实验室和协会各位指导老师的辛勤付出以及学院对我们的关心与支持，特别是匡老师的到来，给我们协会带来了很多实实在在的改变，在她的指导下很多制度都在不断完善，项目团队也在不断地充实，可以说整个实验室和协会的风气都在慢慢转变，另外王老师也加入到我们的团队中来了，相信我们的电子协会一定会发展得越来越顺利。另一方面，也离不开我们协会所有电子人不懈的努力，是大家夜以继日地奋斗，以及辛勤而无私的付出，才能够给实验室培养和输送这么多的人才，然后才能做出这么多的项目，去北京、上海、成都这些地方参加比赛并去的很不错的成绩。 最后，我想对第三届电子协会的管理人员说，我相信各位能够做得比我们第二届做得更好，也希望你们能够不忘初心，将这份积聚了几届电子人辛勤付出的事业更好地传承下去，我也衷心地希望第三届电子协会能够再创辉煌。我还想对第三届电子协会的所有学弟学妹们说，电子协会是一个很有活力的集体，有技术精湛而且负责任的指导老师，还有一群热情大方的学长学姐，相信这里将会是你技术梦想开始的地方，也希望大家能够一直坚持下来，最终顺利进入实验室，进行更深入的学习。 最后的最后，祝大家在电子协会都能有所收获，也祝愿电子协会能够越办越好。谢谢大家！ 2016年10月22日 湖南农业大学]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python Web开发框架Flask]]></title>
      <url>%2F2016%2F10%2F08%2FPython-Web%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6Flask%2F</url>
      <content type="text"><![CDATA[Flask是一个使用 Python 编写的轻量级 Web 应用框架。Flask 的设计目标是实现一个 wsgi 的微框架，其核心代码保持简单和可扩展性，很容易学习。Flask是一个易于学习和使用的框架，但是它的功能也是十分强大，后续还会有进一步的学习和总结，这是第一篇python Web的博客。 flask框架中文版开发文档：http://docs.jinkan.org/docs/flask/ Flask 依赖两个外部库：Werkzeug 和 Jinja2 。 Werkzeug 是一个 WSGI（在 Web 应用和多种服务器之间的标准 Python 接口) 工具集。Jinja2 负责渲染模板。 virtualenv – python虚拟沙盒virtualenv通过创建独立Python开发环境的工具, 来解决依赖、版本以及间接权限问题。 简单地说，你可以为每个项目建立不同的/独立的Python环境，你将为每个项目安装所有需要的软件包到它们各自独立的环境中。 安装virtualenv1$ pip install virtualenv 由于权限问题使用sudo临时提升权限 1$ sudo pip install virtualenv 建立并进入虚拟环境12$ mkdir myproject$ cd myproject 激活虚拟环境1$ . venv/bin/activate #激活当前virtualenv 测试（1）执行python程序 1$ sudo python Test.py （2）访问测试 通过浏览器访问如下地址：http://localhost:5000或者http://127.0.0.1:5000/，就可以看到Hello World！ （3）关闭服务器，按 Ctrl+C。 退出虚拟环境1$ deactivate 删除虚拟环境1$ rm -r venv 获取帮助1$ virtualenv -h Flask框架安装flask1$ pip install flask 基本框架（1）完整的Flask程序 123456789from flask import Flaskapp = Flask(__name__)@app.route(&apos;/&apos;)def hello_world(): return &apos;Hello World!&apos;if __name__ == &apos;__main__&apos;: app.run() （2）框架说明 12from flask import Flaskapp = Flask(__name__) 以上代码中首先导入了 Flask 类，并得到了该类的的实例app，这将会是我们的 WSGI 应用程序。 123@app.route(&apos;/&apos;)def hello_world(): return &apos;Hello World!&apos; 以上代码中route() 装饰器告诉Flask什么样的URL 能触发我们的函数。即route() 装饰器把一个函数绑定到对应的URL上，这个函数返回我们想要显示在用户浏览器中的信息。 12if __name__ == &apos;__main__&apos;: app.run() 以上代码中用 run() 函数来让应用运行在本地服务器上。其中 if name == ‘main‘: 确保服务器只会在该脚本被Python解释器直接执行的时候才会运行，而不是作为模块导入的时候。 调试模式启用了调试支持，服务器会在代码修改后自动重新载入，并在发生错误时提供一个相当有用的调试器。 有两种途径来启用调试模式。一种是直接在应用对象上设置: 12app.debug = Trueapp.run() 另一种是作为 run 方法的一个参数传入: 1app.run(debug=True) 路由配置route() 装饰器把一个函数绑定到对应的 URL 上。 123456789@app.route(&apos;/&apos;)def index(): return &apos;Index Page&apos;#通过http://127.0.0.1:5000访问@app.route(&apos;/hello&apos;)def hello(): return &apos;Hello World&apos;#通过http://127.0.0.1:5000/hello访问 可以给 URL 添加变量部分，你可以把这些特殊的字段标记为 ， 这个部分将会作为命名参数传递到你的函数。规则可以用 指定一个可选的转换器。 1234567891011@app.route(&apos;/user/&lt;username&gt;&apos;)def show_user_profile(username): return &apos;User %s&apos; % username#通过http://127.0.0.1:5000/user/加上名字访问@app.route(&apos;/post/&lt;int:post_id&gt;&apos;)def show_post(post_id): # show the post with the given id, the id is an integer return &apos;Post %d&apos; % post_id#通过http://127.0.0.1:5000/post/加上id访问 默认情况下，路由只回应 GET 请求，但是通过 route() 装饰器传递 methods 参数可以改变这个行为。 123456@app.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def login(): if request.method == &apos;POST&apos;: do_the_login() else: show_the_login_form() 关于HTTP协议的相关方法请参考博主博客：Android网络编程：HTTP协议 通过以上的学习对于Flask框架应该有了一个基本的认识，后续的博文中还将继续深入学习，敬请关注。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux NFS服务配置]]></title>
      <url>%2F2016%2F10%2F05%2FLinux-NFS%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。本博文记录了博主配置NFS服务的过程，并测试成功，希望对大家有所帮助。 注：本博客基于CentOS7进行测试，并假设你已经具有一定的Linux操作基础。 服务端配置安装必要的包使用NFS服务需要安装两个包：nfs-utils和rpcbind 1yum install -y nfs-utils 使用yum安装nfs-utils时会自动安装rpcbind 配置/etc/exports文件1vim /etc/exports 在配置文件中增加内容，每一行分为三部分： 本地要共享出去的目录 允许访问的主机（ip或ip段） 权限选项 例如写入如下一行： 1/home/fzy/ 192.168.0.1/24(rw,sync,all_squash,anonuid=501,anongid=501) 意思是：把/home/fzy/目录共享给ip地址为192.168.0.1/24的主机. 权限部分特别说明： rw 表示读/写 ro 表示只读 sync 表示数据同步写入内存缓冲区与磁盘中，效率较低，但可以保证数据的一致性（适合于小文件传输） async 表示数据先暂时放于内存，而非直接写入硬盘，等到必要时才写入磁盘（适合于大文件传输） no_root_squash 表示root用户对这个共享的目录拥有至高的控制权（不安全，不建议使用） root_squash 表示root用户对这个共享的目录的权限和普通用户一样。 all_squash 表示不管使用NFS的用户是谁，其身份都会被限定成一个指定的普通用户。 no_all_squash 表示所有的普通用户使用nfs都不使用权限压缩（默认设置） anonuid/anongid 要和root_squash以及all_squash选项一同使用，用于指定使用NFS的用户被限定后的uid和gid 启动NFS服务在启动nfs前，需先启动rpcbind 12# service rpcbind start# service nfs start 虽然上面的命令能够正常启动服务，但是根据提示，我们应该使用如下命令来替换： # /bin/systemctl start rpcbind.service # /bin/systemctl start nfs.service 关闭NFS服务 # /bin/systemctl stop rpcbind.service # /bin/systemctl stop nfs.service 客户端挂载NFS查看服务器共享的目录1# showmount -e 服务器ip地址 会得到如下的结果： 12Export list for 服务器ip地址:/home/fzy 客户端ip地址 在客户端上挂载NFS1# mount -t nfs 服务器ip地址:服务器共享目录 挂载点 其中-t nfs 指定挂载的类型为nfs 查看是否挂载成功命令df用于查看已挂载磁盘的总容量、使用容量、剩余容量等。 1# df -h -h 表示使用合适的单位显示 如下图： 解除挂载1# umount 已挂载的目录 如果遇到：umount.nfs: 已挂载的目录: device is busy 可以添加-l参数，如下： 1# umount -l 已挂载的目录 选项 –l 并不是马上umount，而是在该目录空闲后再umount，即延迟卸载。 开机自动挂载方法一： /etc/fstab里添加如下内容： 1服务器ip地址:共享的目录 客户端挂载点 nfs defaults 1 1 第1个1表示备份文件系统，第2个1表示从/分区的顺序开始fsck磁盘检测，0表示不检测. 方法二（推荐）： 将手动挂载命令加入到/etc/rc.local中. 命令exportfs命令选项 -a 表示全部挂载或者卸载 -r 表示重新挂载 -u 表示卸载某一目录 -v 表示显示共享的目录 使用命令修改配置文件/etc/exports后，使用exportfs命令挂载不需要重启NFS服务 1# exportfs -arv]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android逆向分析之反编译]]></title>
      <url>%2F2016%2F10%2F03%2FAndroid%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B9%8B%E5%8F%8D%E7%BC%96%E8%AF%91%2F</url>
      <content type="text"><![CDATA[如果你已经具备一定的Android开发基础，那你一定会思考别人的App是怎么做的，在使用一款App的时候也会想它这个布局、这个效果是怎么实现的？思考是好事，但是全靠猜可不行，如何拿到他的源代码呢？反编译的作用不言而喻。直接拿别人的源码确实不太道德，所以我们提倡学习借鉴，而不是复制。 使用工具： apktool（获取资源文件工具） apktool官方地址 dex2jar（获取源码文件工具） dex2jarGithub地址 jd-gui（源码查看工具） jd-gui官方地址 工具打包下载地址： 百度云链接：http://pan.baidu.com/s/1jHVHc4Q 密码：ra3u 注：以下操作需要你的电脑安装JDK，我们假设你已经安装了，并配置好了环境变量。 反编译得到资源文件apktool反编译得到程序的源代码、图片、XML配置、语言资源等文件 简单的使用如果你只需要简单的反编译，那下面这条命令已经能够满足你的需求。 在Windows下，使用cmd进入到下载的decompile文件夹，然后使用如下命令进行反编译： 1apktool.jar d apk文件路径 配置更多如果你需要使用带参数的apktool，体验更多的功能，或者你经常使用反编译，那建议你进行相应的配置。 将decompile文件夹下的apktool.jar和apktool.bat移动/复制到C:\Windows目录下(需要管理员权限)，如果不进行这一步，使用apktool命令时会提示：’apktool’不是内部或外部命令，也不是可运行的程序或批处理文件。 此处操作的原理就是将apktool的文件加入到环境变量中，因为C:\Windows已经在系统的环境变量中，所以复制到该文件夹后，apktool就成为了一个随处可用的命令。 比如使用apktool命令进行反编译： 1apktool d apk文件路径 apktool有如下参数可供使用： 123456789101112131415161718192021(1) -version 或者 --version 查看apktool版本信息(2) -advance 或者 --advanced 输出更详细的信息(3) d 或者 decode 反编译(4) b 或者 build 编译(5) -o 或者 --output &lt;dir&gt; apk反编译后输出到指定目录---------------------------以上较常用-----------------------------(6) -r 或者 --no-res 阻止反编译resource，不修改resources.arsc，若仅仅修改java（smail），建议使用该选项(7) -s 或者 --no-src 阻止dex文件分割，在build时仅仅移动classes.dex，若需要快速打包，建议使用该选项(8) -f 或者 --force-all 在打包时重写已经存在的文件，强制覆盖(9) -t 或者 --frame-tag &lt;TAG&gt; 给生成的framework文件打上标识(10) -p 或者 --frame-path &lt;dir&gt;指定framework文件储存的位置 使用apktool进行反编译之后可以得到android工程的res目录下的所有文件，以及AndroidManifest.xml，还有一个smali文件夹，很可惜，这个文件夹里的文件并不是java文件，而是很多smali格式的文件。如下图所示： 因为Android系统有自己的虚拟机Dalvik,代码编译最终不是采用的java的class，而是使用的smali。如果我们懂一点smali语法，那看懂这些文件也是不成问题的，但是我们有更好的办法，请看下一步。 Apk反编译得到Jar文件1、在windows下，使用cmd进入到下载的decomplie目录下的dex2jar文件夹 2、将apk文件改成rar后者zip文件，然后解压得到classes.dex文件 3、将解压得到的classes.dex文件复制到dex2jar文件夹内 4、使用如下命令得到classes-dex2jar.jar文件 1d2j-dex2jar.bat classes.dex文件的路径 在dex2jar文件夹可以看到生成了一个classes-dex2jar.jar的文件，然后通过下一步的工具即可查看项目java源码。 使用jar查看器查看源码打开下载的decompile文件夹中的jd-gui-windows-1.4.0目录下的jd-gui.exe，使用jd-gui打开上一步得到的jar文件即可看到项目的java源码，如下图所示： 此工具可用来查看jar文件，其实很多第三方的jar包也是可以通过此工具打开进行查看的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android聊天机器人之图灵机器人]]></title>
      <url>%2F2016%2F09%2F22%2FAndroid%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B9%8B%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%2F</url>
      <content type="text"><![CDATA[图灵机器人—-中文语境下智能度最高的机器人大脑。之前写了一个有意思的小Demo，其实也比较简单，只是使用了图灵机器人的SDK来做了一个简单的聊天机器人，不过图灵机器人确实比较智能，而且功能十分丰富，它不仅提供了数据访问接口，还集成了SDK供大家使用，所以很方便很实用。如果无聊了，就自己动手来做一个聊天机器人解解闷吧！ 下载Android版本SDK图灵机器人官网：http://www.tuling123.com/ 注册之后创建机器人，就可以得到APIKEY和密钥，然后下载SDK，如下图： 将SDK添加到工程中将SDK压缩包中的libs文件夹复制到工程目录替换掉原来的libs。 添加权限1234567&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; SDK初始化12345678910111213141516171819SDKInitBuilder builder = new SDKInitBuilder(this) .setSecret(TURING_SECRET).setTuringKey(TURING_APIKEY) .setUniqueId(UNIQUEID);SDKInit.init(builder, new InitListener() &#123; @Override public void onFail(String arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void onComplete() &#123; // TODO Auto-generated method stub mTuringApiManager = new TuringApiManager(MainActivity.this); mTuringApiManager.setHttpListener(myHttpConnectionListener); // ttsManager.startTTS(&quot;你好啊&quot;); &#125;&#125;); 聊天机器人Demo实现的效果如下： 实现步骤： 定义消息实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ChatMessage &#123; private String name; //消息的名字 private String msg; //消息的内容 private Type type; //消息的类型 private Date date; //消息的时间 //消息类型：发送、接收 public enum Type &#123; INCOMING, OUTCOMING &#125; public ChatMessage() &#123; // TODO Auto-generated constructor stub &#125; public ChatMessage(String msg,Type type,Date date) &#123; // TODO Auto-generated constructor stub setMsg(msg); setType(type); setDate(date); &#125; //生成各成员属性的set和get方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public Type getType() &#123; return type; &#125; public void setType(Type type) &#123; this.type = type; &#125; public Date getDate() &#123; return date; &#125; public void setDate(Date date) &#123; this.date = date; &#125;&#125; 编写适配器类使用适配器将数据与视图绑定起来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class ChatMessageAdapter extends BaseAdapter &#123; private List&lt;ChatMessage&gt; mDatas; private Context mContext; //使用ViewHolder临时存储view，提高效率 private final class ViewHolder &#123; TextView mDate; TextView mMsg; &#125; public ChatMessageAdapter(Context context, List&lt;ChatMessage&gt; data) &#123; // TODO Auto-generated constructor stub mDatas = data; mContext = context; &#125; @Override public int getCount() &#123; // TODO Auto-generated method stub return mDatas.size(); &#125; @Override public Object getItem(int position) &#123; // TODO Auto-generated method stub return mDatas.get(position); &#125; @Override public long getItemId(int position) &#123; // TODO Auto-generated method stub return position; &#125; //得到布局的类型 @Override public int getItemViewType(int position) &#123; ChatMessage chatMessage = mDatas.get(position); if (chatMessage.getType() == Type.INCOMING) &#123; return 0; &#125; return 1; &#125; @Override public int getViewTypeCount() &#123; return 2; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; // TODO Auto-generated method stub ViewHolder viewHolder = null; if (convertView == null) &#123; //更具不同的布局，加载不同的控件 if (getItemViewType(position) == 0) &#123; convertView = LayoutInflater.from(mContext).inflate( R.layout.item_from_msg, null); viewHolder = new ViewHolder(); viewHolder.mDate = (TextView) convertView .findViewById(R.id.id_form_msg_date); viewHolder.mMsg = (TextView) convertView .findViewById(R.id.id_from_msg_info); &#125; else &#123; convertView = LayoutInflater.from(mContext).inflate( R.layout.item_to_msg, null); viewHolder = new ViewHolder(); viewHolder.mDate = (TextView) convertView .findViewById(R.id.id_to_msg_date); viewHolder.mMsg = (TextView) convertView .findViewById(R.id.id_to_msg_info); &#125; convertView.setTag(viewHolder); //使用setTag把view缓存起来 &#125; else &#123; viewHolder = (ViewHolder) convertView.getTag(); //使用getTag得到view &#125; ChatMessage chatMessage = mDatas.get(position); // 设置数据 SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); viewHolder.mDate.setText(df.format(chatMessage.getDate())); viewHolder.mMsg.setText(chatMessage.getMsg()); return convertView; &#125;&#125; 实现业务逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class MainActivity extends Activity &#123; /** * 申请的turing的apikey * **/ private final String TURING_APIKEY = &quot;56433fe6f67942ff80c4d7bd2d20fe34&quot;; /** * 申请的secret * **/ private final String TURING_SECRET = &quot;d9989eac6e4cab39&quot;; private final String UNIQUEID = &quot;131313131&quot;; private TuringApiManager mTuringApiManager; private ListView mMsgs; private ChatMessageAdapter mAdapter; private List&lt;ChatMessage&gt; mDatas; private EditText mInputMsg; private Button mSendMsg; //设置监听 HttpConnectionListener myHttpConnectionListener = new HttpConnectionListener() &#123; @Override public void onSuccess(RequestResult result) &#123; // TODO Auto-generated method stub if (result != null) &#123; String res = result.getContent().toString(); //获取服务器返回数据 System.out.println(res); JSONObject jo; try &#123; jo = new JSONObject(res); //解析JSON格式数据 String text = jo.getString(&quot;text&quot;); mDatas.add(new ChatMessage(text, Type.INCOMING, new Date())); mAdapter.notifyDataSetChanged(); //更新UI mMsgs.setSelection(mDatas.size()-1); &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; @Override public void onError(ErrorMessage arg0) &#123; // TODO Auto-generated method stub &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); //SDK初始化 SDKInitBuilder builder = new SDKInitBuilder(this) .setSecret(TURING_SECRET).setTuringKey(TURING_APIKEY) .setUniqueId(UNIQUEID); SDKInit.init(builder, new InitListener() &#123; @Override public void onFail(String arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void onComplete() &#123; // TODO Auto-generated method stub mTuringApiManager = new TuringApiManager(MainActivity.this); mTuringApiManager.setHttpListener(myHttpConnectionListener); &#125; &#125;); initView(); //初始化视图 initDatas(); //初始化数据 //发送消息按钮的监听事件 mSendMsg.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; final String toMsg = mInputMsg.getText().toString(); if (TextUtils.isEmpty(toMsg)) &#123; Toast.makeText(MainActivity.this,&quot;发送消息不能为空！&quot;,Toast.LENGTH_SHORT).show(); return; &#125; //得到输入框的内容，转化成一个消息对象 ChatMessage toMessage = new ChatMessage(toMsg,Type.OUTCOMING,new Date()); mDatas.add(toMessage); mAdapter.notifyDataSetChanged(); mMsgs.setSelection(mDatas.size()-1); //清空输入框 mInputMsg.setText(&quot;&quot;); //发送消息到图灵服务器 mTuringApiManager.requestTuringAPI(toMsg); &#125; &#125;); &#125; //初始化数据 private void initDatas() &#123; mDatas = new ArrayList&lt;ChatMessage&gt;(); mDatas.add(new ChatMessage(&quot;你好，小农为您服务&quot;, Type.INCOMING, new Date())); mAdapter = new ChatMessageAdapter(this, mDatas); mMsgs.setAdapter(mAdapter); &#125; //初始化视图 private void initView() &#123; mMsgs = (ListView) findViewById(R.id.id_listview_msgs); mInputMsg = (EditText) findViewById(R.id.id_input_msg); mSendMsg = (Button) findViewById(R.id.id_send_msg); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构基础之队列]]></title>
      <url>%2F2016%2F09%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%98%9F%E5%88%97%2F</url>
      <content type="text"><![CDATA[上一篇博客中我们总结了栈的相关知识，其实，在数据结构的教材中栈和队列通常是放在同一章进行讲解的，因为他们都是操作受限的线性表，只是具体的限制不同。队列是只允许在表的一段进行插入操作，而在另一端进行删除操作的线性表，它的应用也是比较广泛的，比如在操作系统的处理进程对CPU资源的竞争以及我们常常提及的优先级队列等等。 队列的基本概念定义：只允许在表的一段进行插入操作，而在另一端进行删除操作的线性表。 队头：允许进行删除操作的一端。 队尾：允许进行插入操作的一端。 顺序队列 采用顺序存储结构，即在内存中用一组地址连续的存储单元一次存放从队头到队尾的数据元素，同时设置两个指针front、rear分别指示队头元素和队尾元素的位置。 1234typedef struct&#123; ElemType data[MAXSIZE]; //存放数据元素的数组 int front,rear; //头尾指针&#125;SeqQueue; 队头指针：指示队头元素所在位置。 队尾指针：指示队尾元素的下一个位置。 入队操作：rear = rear + 1 出队操作：front = front + 1 当rear = MAXSIZE时，队列不一定真的占满整个数组空间，因为不管入队还是出队指针都是加，头指针一直加就会使得数组的前端可能出现许多空的单元，这种现象称为假溢出。为了充分利用数组空间，于是引入了循环队列。 循环队列 将队列的存储空间看成一个环状的空间，即将队列的首、尾的位置连接起来形成的结构称为循环队列。 入队操作：Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE 出队操作：Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE 区分队空还是队满的方式1、牺牲一个单元来区分队空和队满，约定以队头指针在队尾指针的下一个位置作为队满的标志，则有： 队空条件：Q-&gt;front == Q-&gt;rear 队满条件：(Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front 队列中元素个数：(Q-&gt;rear-Q-&gt;front+MAXSIZE) % MAXSIZE 2、类型中增设表示元素个数的数据成员，则有： 队空满条件：Q-&gt;size == 0 队满条件：Q-&gt;size == MAXSIZE 3、类型中增设tag数据成员，则有： tag等于0的情况下，若因删除导致Q-&gt;front == Q-&gt;rear则为队空，tag等于1的情况下，若因插入导致Q-&gt;front == Q-&gt;rear则为队满。 基本操作实现下面例子采用第一种处理方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define false 0#define true 1#define MAXSIZE 100typedef struct&#123; ElemType data[MAXSIZE]; //存放数据元素的数组 int front,rear; //头尾指针&#125;SeqQueue;/*********初始化队列*********/void InitQueue(SeqQueue *Q)&#123; Q-&gt;front = Q-&gt;rear = 0;&#125;/*******判断队列是否为空*******/int QueueEmpty(SeqQueue *Q)&#123; if(Q-&gt;front == Q-&gt;rear) return true; else return false;&#125;/*************入队操作*************/int EnQueue(SeqQueue *Q,ElemType e)&#123; if((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front) //队满 return false; Q-&gt;data[Q-&gt;rear] = e; //将e插入队尾 Q-&gt;rear = (Q-&gt;rear+1)%MAXSIZE; //修改尾指针 return true;&#125;/*************出队操作**************/int DeQueue(SeqQueue *Q,ElemType *e)&#123; if(Q-&gt;front == Q-&gt;rear) //队空 return false; *e = Q-&gt;data[Q-&gt;front]; //得到删除的队头元素 Q-&gt;front = (Q-&gt;front+1)%MAXSIZE; //修改头指针 return true;&#125;/*************取队头元素**************/int GetFront(SeqQueue *Q,ElemType *e)&#123; if(Q-&gt;front == Q-&gt;rear) //队空 return false; *e = Q-&gt;data[Q-&gt;front]; //取得队头元素 return true;&#125;int main()&#123; SeqQueue Q; InitQueue(&amp;Q); .... 进行入队、出队、判空等操作 .... return 0;&#125; 链式队列 采用链表形式的队列，队列中每个元素对应链表中的一个结点的，并设置两个分别指向队头和队尾的指针。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define false 0#define true 1typedef struct LinkQNode&#123; ElemType data; //数据域 struct LinkQNode *next; //指针域&#125;LinkQNode;typedef struct&#123; LinkQNode *front; //队头指针 LinkQNode *rear; //队尾指针&#125;LinkQueue;/*********初始化队列*********/void InitQueue(LinkQueue *Q)&#123; LinkQNode *p = (LinkQNode *)malloc(sizeof(LinkQNode)); //构建头结点 if(p == NULL) //存储空间分配失败 return false; Q-&gt;front = Q-&gt;rear = p; //队头指针和队尾指针都指向头结点 Q-&gt;front-&gt;next = NULL; //头结点指针域至为空 return true;&#125;/*******判断队列是否为空*******/int QueueEmpty(LinkQueue *Q)&#123; if(Q-&gt;front == Q-&gt;rear) return true; else return false;&#125;/*************入队操作*************/int EnQueue(LinkQueue *Q,ElemType e)&#123; LinkQNode *p = (LinkQNode *)malloc(sizeof(LinkQNode)); //构建新结点 if(p == NULL) //存储空间分配失败 return false; p-&gt;data = e; //设置新结点数据域 p-&gt;next = NULL; //设置新结点指针域 Q-&gt;rear-&gt;next = p; //将新结点插入队尾 Q-&gt;rear = p; //修改队尾指针 return true;&#125;/*************出队操作**************/int DeQueue(LinkQueue *Q,ElemType *e)&#123; LinkQNode *p; if(Q-&gt;front == Q-&gt;rear) //队列空 return false; p = Q-&gt;front-&gt;next; //得到第一个结点 *e = p-&gt;data; //得到删除结点的值 Q-&gt;front-&gt;next = p-&gt;next; //结点p出队 if(Q-&gt;rear == p) //队列中只有一个结点p，则出队后队列为空 Q-&gt;rear = Q-&gt;front; free(p); //释放存储空间 return true;&#125;/*************取队头元素**************/int GetFront(LinkQueue *Q,ElemType *e)&#123; LinkQNode *p; if(Q-&gt;front == Q-&gt;rear) //队空 return false; p = Q-&gt;front-&gt;next; //得到第一个结点 *e = p-&gt;data; //得到第一个结点的值 return true;&#125;int main()&#123; LinkQueue Q; InitQueue(&amp;Q); .... 进行入队、出队、判空等操作 .... return 0;&#125; 双端队列 双端队列是指允许两端都可以进行入队和出队操作的队列。 输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列。 输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列。 尽管双端队列看起来似乎比栈和队列更灵活，但实际上在应用程序中远不及栈和队列有用，所以在这里就不详细的介绍啦！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构基础之栈]]></title>
      <url>%2F2016%2F09%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%88%2F</url>
      <content type="text"><![CDATA[继续上一篇博客的话题，继续总结数据结构的相关知识，此篇博客主要总结栈的基本概念、存储结构、基本操作以及应用，栈是一种操作受限的线性表，只允许在表的一端进行插入和删除，也正因为它的这个特点，使得栈的应用十分广泛，比如数制转换、表达式求值等问题的解决都用到栈以及栈在递归中的重要作用。 栈的基本概念定义：只允许在表的一端进行插入和删除的操作的线性表。 栈顶：允许插入和删除的一端。 特点：后进先出（Last In First Out，LIFO）。 顺序栈 对栈顶指针进行初始化时，可以将其初始化为-1，也可以初始化为0，当初始化为-1时栈顶指针指向的元素即为栈顶元素，而初始化为0时，栈顶指针减1所指向的元素才是栈顶元素，具体区别如下： 初始化栈顶指针S-&gt;top = -1时栈顶元素为S-&gt;data[S-&gt;top] 进栈操作：先将栈顶指针加1，再送值到栈顶元素，即S-&gt;data[++S-&gt;top] = x 出栈操作：先取栈顶元素值，再将栈顶指针减1，即x = S-&gt;data[S-&gt;top–] 栈空条件：S-&gt;top = -1 栈满条件：S-&gt;top = MAXSIZE - 1 栈长：S-top + 1 初始化栈顶指针S-&gt;top = 0时栈顶元素为S-&gt;data[S-&gt;top - 1] 进栈操作：先送值到栈顶元素，栈顶指针再加1，即S-&gt;data[S-&gt;top++] = x 出栈操作：先将栈顶指针减1，再取栈顶元素值，即x = S-&gt;data[–S-&gt;top] 栈空条件：S-&gt;top = 0 栈满条件：S-&gt;top = MAXSIZE 栈长：S-top 基本操作实现下面以将栈顶指针初始化为0为例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define MAXSIZE 100 //定义栈的最大容量#define true 1#define false 0typedef struct&#123; ElemType data[MAXSIZE]; //存放栈中元素的数组 int top; //栈顶指针&#125;SeqStack;/******构造一个空栈******/void InitStack(SeqStack *S)&#123; S-&gt;top = 0; //栈顶指针初始化为0&#125;/*******判断栈空*******/int StackEmpty(SeqStack *S)&#123; if(S-&gt;top == 0) return true; else return false;&#125;/***********出栈操作***********/int Pop(SeqStack *S,ElemType *e)&#123; if(S-&gt;top == 0) //若栈空出栈失败 return false; *e = S-&gt;data[-- S-&gt;top]; //修改栈顶指针，并保存栈顶元素 return true;&#125;/***********进栈操作***********/int Push(SeqStack *S,ElemType e)&#123; if(S-&gt;top == MAXSIZE) //若栈满则进栈失败 return false; S-&gt;data[S-&gt;top ++] = e; //将e插入栈顶，并修改栈顶指针 return true;&#125;/***********取栈顶元素***********/int GetTop(SeqStack *S,ElemType *e)&#123; if(S-&gt;top == 0) //若栈空取栈顶元素失败 return false; *e = S-&gt;data[S-&gt;top-1]; //保存栈顶元素 return true;&#125;int main()&#123; SeqStack S; InitStack(&amp;S); .... 进行进栈、出栈、判断栈空等操作 .... &#125; 链栈利用单链表结构来实现的栈，即栈中的每一个数据元素用一个结点来表示，同时设置一个指针top来指示栈顶元素的当前位置。 特点 便于多个栈共享存储空间 不存在栈满溢出的情况 操作与链表类似，便于结点的插入和删除 基本操作实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define false 0#define true 1typedef struct SNode&#123; ElemType data; //数据域 struct SNode *next; //指针域&#125;SNode;typedef struct&#123; SNode *top; //栈顶指针&#125;LinkStack;/*******构造一个空栈*******/int InitStack(LinkStack *S)&#123; S = (LinkStack *)malloc(sizeof(LinkStack)); //分配栈顶指针的内存空间 if(S == NULL) //内存分配失败 return false; S-&gt;top = NULL; //栈顶指针置为空 return true;&#125;/**********置栈空**********/void ClearStack(LinkStack *S)&#123; S-&gt;top = NULL; //将栈顶指针置为空&#125;/*********判断栈空********/int StackEmpty(LinkStack *S)&#123; return S-&gt;top == NULL; //判断栈顶指针是否为空&#125;/***********进栈操作***********/int Push(LinkStack *S,ElemType e)&#123; SNode *temp; temp = (SNode *)malloc(sizeof(SNode)); //生成新的结点 if(temp == NULL) //内存分配失败 return false; temp-&gt;data = e; //赋值给结点数据域 temp-&gt;next = S-&gt;top; //插入栈顶 S-&gt;top = temp; //修改栈顶指针 return true;&#125;/***********出栈操作***********/int Pop(LinkStack *S,ElemType *e)&#123; SNode *temp; if(S-&gt;top == NULL) //若栈为空则出栈失败 return false; temp = S-&gt;top; S-&gt;top = temp-&gt;next; //修改栈顶指针 *e = temp-&gt;data; //保存栈顶元素 free(temp); //释放出栈结点 return true;&#125;/***********取栈顶元素***********/int GetTop(LinkStack *S,ElemType *e)&#123; if(S-&gt;top == NULL) //若栈为空则无法获取栈顶元素 return false; *e = S-&gt;top-&gt;data; //取栈顶指针指向的元素 return true;&#125;int main()&#123; LinkStack S; InitStack(&amp;S); .... 进行进栈、出栈、判断栈空等操作 ....&#125; 共享栈为了避免出现有的栈溢出有的栈空闲的情况，可以让多个栈共享一个足够大的数组空间，是存储空间得到充分利用。常见的是两栈共享空间，即让两个栈共享一个一维数组空间，使两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。 特点同样，由于初始化的不同会出现两种情况，这里以初始化栈1的栈顶指针为0，栈2的栈顶指针为MAXSIZE-1为例进行说明： 栈满条件：S-&gt;top1 = S-&gt;top2 + 1 栈空条件：S-&gt;top1 = 0 或 S-&gt;top2 = MAXSIZE - 1 进栈操作：栈1：先赋值栈顶指针再加1，栈2：先赋值栈顶指针再减1 出栈操作：栈1：栈顶指针先减1再赋值，栈2：栈顶指针先加1再赋值 栈顶元素：栈1：S-&gt;data[S-&gt;top1-1]，栈2：S-&gt;data[S-&gt;top2-1] 如果初始化栈1的栈顶指针为-1，栈2的栈顶指针为MAXSIZE会有什么不同呢？还是自己想一想吧，这里就不给出啦。 基本操作实现下面是初始化为0和MAXSIZE-1的情况： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define MAXSIZE 100 //定义栈的最大容量#define true 1#define false 0typedef struct&#123; ElemType data[MAXSIZE]; //两栈共享的数组空间 int top[2]; //两栈的栈顶指针&#125;DSeqStack;/*********构造一个空栈*********/void InitStack(DSeqStack *S)&#123; S-&gt;top[0] = 0; //初始化栈1的栈顶指针 S-&gt;top[1] = MAXSIZE-1; //初始化栈2的栈顶指针&#125;/*********判断栈是否为空*********/int StackEmpty(DSeqStack *S,int i)&#123; switch(i)&#123; case 1: return (S-&gt;top[0] == 0? true:false); //判断栈1是否为空 break; case 2: return (S-&gt;top[1] == MAXSIZE-1? true:false); //判断栈2是否为空 break; default: return false; //参数错误 &#125;&#125;/**************进栈操作**************/int Push(DSeqStack *S,ElemType e,int i)&#123; if(S-&gt;top[0] == S-&gt;top[1]+1) //判断栈空间是否满 return false; switch(i)&#123; case 1: S-&gt;data[S-&gt;top[0]] = e; //将e压入第1个栈 S-&gt;top[0]++; break; case 2: S-&gt;data[S-&gt;top[1]] = e; //将e压入第2个栈 S-&gt;top[1]--; break; default: return false; //参数错误 &#125; return true;&#125;/**************出栈操作**************/int Pop(DSeqStack *S,ElemType *e,int i)&#123; switch(i)&#123; case 1: if(S-&gt;top[0] == 0) //判断栈1是否为空 return false; S-&gt;top[0]--; //修改栈1的栈顶指针 *e = S-&gt;data[S-&gt;top[0]]; //从第1个栈中弹出 break; case 2: if(S-&gt;top[1] == MAXSIZE-1) //判断栈2是否为空 return false; S-&gt;top[1]++; //修改栈2的栈顶指针 *e = S-&gt;data[S-&gt;top[1]]; //从第2个栈中弹出 break; default: return false; //参数错误 &#125; return true;&#125;int main()&#123; DSeqStack S; InitStack(&amp;S); .... 进行进栈、出栈、判断栈空等操作 ....&#125; 栈的应用数制转换数制转换过程中我们得到的结果序列往往是我们所要结果的逆序，这时候就需要栈来帮忙了。比如，将十进制数12转换成二进制序列，过程如下： 12345612/2 = 6...06/2 = 3...03/2 = 1...11/2 = 0...1依次得到0011，但是12的二进制表示为1100，即为逆序。 所以我们需要将每次得到的余数压入栈中，一直到没有元素需要压入栈中时再将元素依次从栈中弹出，即得到正确的结果。 以十进制转K进制为例： 1234567891011121314void Conversion(int n,int k)&#123; ElemType x; SeqStack S; InitStack(&amp;S); while(n&gt;0)&#123; x = n%k; Push(&amp;S,x); //将得到的余数依次压入栈中 n = n/k; &#125; while(!StackEmpty(&amp;S))&#123; Pop(&amp;S,&amp;x); printf(&quot;%d&quot;,x); &#125;&#125; 栈的应用还有很多，比如括号匹配的检验、表达式求值，以及栈在递归中的重要作用。这里就不再一一描述了，以后在Leetcode上看到类似的题目再进行说明。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构基础之线性表]]></title>
      <url>%2F2016%2F09%2F06%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[数据结构也是算法学习的一部分，最近比较忙，在对所学的知识查漏补缺，没有学习什么新的东西，于是干脆就对一直在复习数据结构来了个大总结，这篇博客主要是数据结构的线性表部分，争取尽快把其他部分总结完。接下来的一段时间可能不会经常去Leetcode刷题了，近期的算法学习这一系列的博客将以数据结构为主，因为近来有更重要的事情要做，毕竟精力有限，刷题这一块就先放一放咯。 线性表的基本概念定义：具有相同数据类型的n(n&gt;=0)个数据元素的有限序列 线性表的特点： 1、表中的元素个数有限。 2、表中元素具有逻辑上的顺序性，在序列中各元素排列有其先后顺序。 3、表中元素都是数据元素，每个元素都是单个元素。 4、表中元素的数据类型都相同。 5、表中元素具有抽象性。即仅讨论元素间的逻辑关系，不考虑元素究竟表示什么内容。 顺序存储顺序表线性表的顺序存储。用一组地址连续的存储单元，依次存储线性表中的数据元素，使得逻辑上相邻的两个元素在物理上也相邻。 注意：顺序表的位序是从1开始的，而数组中元素的下标是从0开始的。 基本操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define OVERFLOW -2#define true 1#define false 0#define LIST_INIT_SIZE 10 //线性表存储空间的初始分配量#define LIST_INCREMENT 2 //线性表存储空间的分配增量typedef struct&#123; ElemType *data; //存储空间基址 int length; //当前长度 int listsize; //当前分配的存储容量(以sizeof(ElemType)为单位)&#125;SeqList;/********初始化********/int InitList(SeqList *L)&#123; L-&gt;data = (ElemType *)malloc(sizeof(ElemType)*LIST_INIT_SIZE); if(!L-&gt;data) return OVERFLOW; L-&gt;length = 0; L-&gt;listsize = LIST_INIT_SIZE; return true;&#125;/****************插入操作*****************/int ListInsert(SeqList *L,int i,ElemType e)&#123; int j; if(i&lt;1||i&gt;L-&gt;length+1) //判断i的范围是否有效 return false; if(L-&gt;length == L-&gt;listsize) //存储空间已满时不能插入 return OVERFLOW; for(j=L-&gt;length;j&gt;=i;j--) //将第i个元素及之后的元素后移 L-&gt;data[j]=L-&gt;data[j-1]; L-&gt;data[i-1]=e; //在位置i处放入e L-&gt;length++; //线性表长度加1 return true;&#125;/***********删除操作***********/int ListDelete(SeqList *L,int i)&#123; int j; if(i&lt;1||i&gt;L-&gt;length+1) //判断i的范围是否有效 return false; for(j=i;j&lt;L-&gt;length;j++) //将第i个位置之后的元素前移 L-&gt;data[j-1] = L-&gt;data[j]; L-&gt;length--; //线性表长度减1 return true;&#125;/**********按位置查找************/ElemType GetElem(SeqList *L,int i)&#123; if(i&lt;1||i&gt;L-&gt;length+1) //判断i的范围是否有效 return false; return L-&gt;data[i-1];&#125;/*************按值查找**************/int LocateElem(SeqList *L,ElemType e)&#123; int i; for(i=0;i&lt;L-&gt;length;i++)&#123; if(L-&gt;data[i] == e) return i+1; &#125; return 0;&#125;/*********求表长**********/int ListLength(SeqList *L)&#123; return L-&gt;length;&#125;/******判断是否是空表*****/void ListEmpty(SeqList *L)&#123; if(L-&gt;length == 0) return true; else return false;&#125;/*********输出表*********/void printList(SeqList *L)&#123; int i; for(i=0;i&lt;L-&gt;length;i++) printf(&quot;%d &quot;,L-&gt;data[i]);&#125;/*********清空表********/void ClearList(SeqList *L)&#123; L-&gt;length = 0;&#125;/*********销毁表********/void DstroyList(SeqList *L)&#123; free(L-&gt;data); L-&gt;data = NULL; L-&gt;length = 0; L-&gt;listsize = 0;&#125;int main()&#123; SeqList L; InitList(&amp;L); .... 进行插入、删除、查找结点等操作 .... return 0;&#125; 扩展操作 1234567891011121314151617181920212223242526272829303132333435363738/********将顺序表的所有元素逆置******/void Reverse(SeqList *L)&#123; int i; ElemType temp; //辅助变量 for(i=0;i&lt;((L-&gt;length)/2);i++)&#123; //扫描顺序表L，进行元素交换 temp = L-&gt;data[i]; L-&gt;data[i] = L-&gt;data[L-&gt;length-1-i]; L-&gt;data[L-&gt;length-1-i] = temp; &#125;&#125;/******删除有序顺序表中重复的元素******/void Del_same(SeqList *L)&#123; int i,j; for(i=0,j=1;j&lt;L-&gt;length;j++)&#123; //i存储第一个不相同的元素，j工作指针 if(L-&gt;data[i] != L-&gt;data[j])&#123; //查找下一个与上一个元素值不相同的元素 L-&gt;data[++i] = L-&gt;data[j]; //找到后，则将元素前移 &#125; &#125; L-&gt;length = i+1; //删除相同元素后，线性表的长度&#125;/*****将两个有序顺序表合并成一个新的有序顺序表*****/int Merge(SeqList *L1,SeqList *L2,SeqList *L)&#123; if(L1-&gt;length + L2-&gt;length &gt; L-&gt;length) //大于合并表的长度 return false; while(i &lt; L1-&gt;length &amp;&amp; j &lt; L2-&gt;length)&#123; //循环，两两比较，较小的存入结果表 if(L1-&gt;data[i] &lt;= L2-&gt;data[j]) L-&gt;data[k++] = L1-&gt;data[i]; else L-&gt;data[k++] = L2-&gt;data[j]; &#125; while(i &lt; L1-&gt;length) //处理剩下没比完的顺序表 L-&gt;data[k++] = L1-&gt;data[i++]; while(j &lt; L2-&gt;length) L-&gt;data[k++] = L2-&gt;data[i++]; return true;&#125; 链式存储单链表单链表：通过一组任意的存储单元来存储线性表中的数据元素。 头结点head指向单链表的第一个结点。 结点由两部分组成：数据域data，指针域next(存放直接后继元素的地址)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define true 1#define false 0typedef struct LNode&#123; ElemType data; struct LNode *next;&#125;LNode,*LinkList;/************头插法建立链表*************/LinkList HeadInsert_CreatList(LinkList L)&#123; int n; LNode *s; L = (LinkList)malloc(sizeof(LNode)); //创建头结点 L-&gt;next = NULL; printf(&quot;采用头插法建立链表，请输入结点值，以9999结束：\n&quot;); scanf(&quot;%d&quot;,&amp;n); while(n!=9999)&#123; s = (LinkList *)malloc(sizeof(LNode)); //创建新结点 s-&gt;data = n; s-&gt;next = L-&gt;next; L-&gt;next = s; //将新结点插入表中 scanf(&quot;%d&quot;,&amp;n); &#125; return L;&#125;/************尾插法建立链表*************/LinkList RearInsert_CreatList(LinkList L)&#123; int n; LNode *s,*r; L = (LinkList)malloc(sizeof(LNode)); //创建头结点 r = L; printf(&quot;采用尾插法建立链表，请输入结点值，以9999结束：\n&quot;); scanf(&quot;%d&quot;,&amp;n); while(n!=9999)&#123; s = (LNode *)malloc(sizeof(LNode)); //创建新结点 s-&gt;data = n; r-&gt;next = s; r = s; //r指向新的表尾结点 scanf(&quot;%d&quot;,&amp;n); &#125; r-&gt;next = NULL; //表尾结点指针置空 return L;&#125;/*******按序号查找结点值*******/LNode* GetElem(LinkList L,int i)&#123; int j = 1; LNode *p = L-&gt;next; //头结点指针赋给p if(i==0) //i=0返回头结点 return L; if(i&lt;1) //i无效则返回NULL return NULL; while(p&amp;&amp;j&lt;i)&#123; //从第1个结点开始查找第i个结点 p = p-&gt;next; j++; &#125; return p; //返回第i个结点的指针&#125;/*************按值查找结点*************/LNode* LocateElem(LinkList L,ElemType e)&#123; LNode *p = L-&gt;next; //头结点指针赋给p while(p!=NULL&amp;&amp;p-&gt;next!=e) //从第1个结点开始查找值为e的结点 p = p-&gt;next; return p; //找到则返回值为e的结点，否则返回NULL&#125;/****************插入结点****************/int ListInsert(LinkList L,int i,ElemType x)&#123; LNode *s,*p; p = GetElem(L,i-1); //查找插入位置的前驱结点 s = (LNode *)malloc(sizeof(LNode)); //创建新结点 s-&gt;data = x; s-&gt;next = p-&gt;next; p-&gt;next = s; return true;&#125;/*********求表长*********/int ListLength(LinkList L)&#123; int len = 0; LNode *p = L-&gt;next; //头结点指针赋给p while(p)&#123; len++; //记录表中结点个数 p = p-&gt;next; &#125; return len; //返回表长&#125;/***********删除结点***********/int ListDelete(LinkList L,int i)&#123; LNode *p = GetElem(L,i-1); //查找待删除结点的前驱结点 LNode *q = p-&gt;next; //p指向需要删除的结点 p-&gt;next = q-&gt;next; //修改指针 free(q); //释放删除结点的存储空间 return true;&#125;/*****打印链表结点值******/int ListPrint(LinkList L)&#123; LNode *p = L-&gt;next; //头结点指针赋给p while(p)&#123; printf(&quot;%d &quot;,p-&gt;data); //按顺序依次输出结点值 p = p-&gt;next; &#125; printf(&quot;\n&quot;);&#125;int main()&#123; LinkList L1,L2; L1 = HeadInsert_CreatList(L1); printf(&quot;采用头插法建立的链表L1的结点值为：&quot;); ListPrint(L1); L2 = RearInsert_CreatList(L2); printf(&quot;采用尾插法建立的链表L2的结点值为：&quot;); ListPrint(L2); .... 进行插入、删除、查找结点等操作 .... return 0;&#125; 双链表每个结点设置两个指针prior和next，分别指向其前驱结点和后继结点。 1234typedef struct DNode&#123; ElemType data; //数据域 struct DNode *prior,*next; //前驱和后继指针&#125;DNode,*DLinkList; 插入操作： 12345//将结点*s插入到结点*p之后s-&gt;next = p-&gt;next;p-&gt;next-&gt;prior = s;s-&gt;prior = p;p-&gt;next = s; 删除操作：1234//删除结点*p的后继结点*qp-&gt;next = q-&gt;next;q-&gt;next-&gt;proir = p;free(q); 循环单链表将单链表的最后一个指针由NULL改为指向头结点，使整个链表形成一个环。 判空条件为：头结点的指针是否等于头结点。 插入删除与单链表相同。 静态链表借助数组来描述线性表的链式存储结构。 结点由两部分组成：数据域data，下一个元素的数组下标next。 1234typedef struct&#123; ElemType data; //存储数据元素 int next; //下一个元素的数组下标&#125;SLinkList[MAXSIZE]; 以next=-1作为其结束的标志。 顺序表和链表的比较存取方式顺序表：可以顺序存取也可以随机存取。 链表：只能从表头顺序存取元素。 逻辑结构与物理结构顺序表：逻辑上相邻的元素，其对应的物理存储位置也相邻。 链表：逻辑上相邻的元素，其物理存储位置则不一定相邻。 查找、插入和删除操作查找： 按值查找时，顺序表无序时，顺序表和链表的时间复杂度均为O(n)，但是当顺序表有序时，可采用折半查找，时间复杂度为O(log2n)。 按序号查找时，顺序表的时间复杂度仅为O(1)，而链表的平均时间复杂度为O(n)。 插入和删除： 顺序表平均需要移动半个表长的元素，而链表只需要修改相关指针即可。 空间分配顺序存储在空间分配中存在诸多问题与隐患，比如内存溢出、内存闲置等，而链式存储的结点空间只在需要的时候申请分配，只要内存有空间就可以分配，操作灵活、高效。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开学季-那些迷茫与美好]]></title>
      <url>%2F2016%2F08%2F31%2F%E5%BC%80%E5%AD%A6%E5%AD%A3-%E9%82%A3%E4%BA%9B%E8%BF%B7%E8%8C%AB%E4%B8%8E%E7%BE%8E%E5%A5%BD%2F</url>
      <content type="text"><![CDATA[大学的最后一个暑假已经结束，明天就是九月了，开学已经好几天，但是根本没有任何开学的感觉，毕竟都是大四的老腊肉了。没有一节课的大四生活就这样悄悄地开始了，不知道接下来会发生什么，也不知道这一年自己可以做些什么，有时候选择很多也未必是好事，因为这样会很迷茫。就像现在的我，每天都觉得很迷茫，但是我还是按照既定的计划每天向前走着。这样的日子说不上很美好，但是却很安静，也很满足。 这个暑假，基本的安排都在有序的进行着，虽然总会有一些烦人的事情，也会有担忧，但是都还是坚持下来了。最近看了鲁豫有约之大咖一日行第一期王健林的那个视频，这些大咖总是又让我们很佩服的事情，虽然他们肯定有过人之处，就像他那句话刷爆了朋友圈的话：先定一个小目标，比方说我先挣它一个亿。我觉得确实说得很对啊，抛开大家对于一个亿是小目标的玩笑，认真想想，很多时候，我们就是缺少一个实际一点的目标。我们可以根据自己的实际情况对自己定一些小目标，然后关键就在于我们能不能坚持去做了。我也给自己定过很多小目标，有的完成了，有的没完成，但是这个过程中收获还是有的。 先定一个小目标，比方说我先写它30篇博客。暑假，在复习之余也一直在更新自己的博客，我始终认为技术不能丢，安卓和算法这是这个暑假主要在学习的两块内容。暑假写了差不多30篇博客，有时候也会很烦，写一篇博客确实需要花费很多的精力，从选题到拟定提纲、到查阅资料、编写实例，再到格式整理等等，这个过程其实是很漫长而又艰难的，有时候也会想要放弃，但是每次写完都还是很有成就感的。虽然可能自己写的博客没有多少人来看，但是这都不重要，写博客本来就是对自我学习的总结以及对自己写作能力的锻炼。 考研这条路不再像高考，高考的时候你的身边都是为了考大学这一个目标，但是现在似乎不再有以前的那种氛围，那股冲劲，身边很多人都去实习了，留下的也基本都在等秋招，自己也投了一些简历，想去试试。现在的生活真的很安静，早上早起打打球，白天静静地待在图书馆学习，晚上静静地在寝室写代码写博客，没有什么压力，也没有什么束缚，其实这样也挺好。 不管怎么说，信心还是要有的。一直以来对于自己的自学能力还是很有信心的，大学里学到的很多技术也都是靠自己查资料、实践以及向老师学长学姐请教学来的。但是也开始意识到自己薄弱的地方，慢慢懂得数据结构与算法是软件的核心，不管是考研还是找工作，数据结构与算法都是很重要的知识。虽然有些技能不需要人教我就可以很快掌握，但是在数据结构和算法方面自己还是很欠缺的。不想做一个只会写代码的底层码农，而想要成为有思想的程序员，要慢慢地朝着架构师的方向发展。 不知道九月甚至是大四的这一年会发生些什么，也不知道接下来我会怎样走下去，虽然迷茫但是从来不畏惧，相信努力、勤奋与坚持会带来改变。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于CentOS7的SVN服务器配置]]></title>
      <url>%2F2016%2F08%2F30%2F%E5%9F%BA%E4%BA%8ECentOS7%E7%9A%84SVN%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[SVN是Subversion的简称，它是一个受欢迎的开放源代码的版本控制系统。简单一点说，SVN就是用于多个人共同开发同一个项目，共用资源的目的。作为软件开发人员，很有必要了解和学习SVN的使用。学习版本控制从SVN安装与配置开始，此篇博客主要讲解基于阿里云服务器的SVN服务器配置。 版本控制版本控制系统 (VCS) 是一个软件，帮助软件开发人员团队工作并维持他们完整的工作历史。 版本控制系统(VCS) 的目标： 允许开发者们同时工作 不会重写每个人的改变 维持每个版本的全部的历史 VCS被分成两种 集中版本控制系统 (CVCS) 和 分散或不集中的版本控制系统 (DVCS) Subversion 基于集中的版本控制系统，意味着使用统一的服务器让团队协作。 安装SVN大多数 GNU/Linux 发行版系统自带，所以它很有可能已经安装在你的系统上了。可以使用下面命令检查是否安装了。 1svn --version 如果系统已经安装Subversion客户端，使用上面的命令会出现安装的软件版本，否则会提示命令找不到。 如果你使用基于RPM的GNU/Linux，可以切换到root用户使用yum命令进行安装，安装成功之后，执行 svn –version 命令。 1yum install subversion 如果你使用基于Debian的GNU/Linux，使用apt命令进行安装。 1sudo apt-get update 另外，还需要安装Apache httpd模块，如果没有安装请自行百度吧，这里主要讲解如何配置SVN。 注：博主租用的阿里云的服务器，采用CentOS系统，自带SVN，并且我已经安装好了Apache httpd模块。 创建目录保存所有的工作1mkdir -p /var/svn 创建版本库1svnadmin create /var/svn/repo 创建完成后，可以使用ls命令看到，在版本库中存在如下文件： 1conf db format hooks locks README.txt 配置版本库在conf目录下有如下三个文件： svn服务综合配置文件（svnserve.conf） 用户名口令文件（passwd） 权限配置文件（authz） 配置svnserve.conf文件找到以下四行，删除前面的注释符使其起作用： 1234anon-access = read #匿名用户可读auth-access = write #授权用户可写password-db = passwd #使用哪个文件作为账号文件authz-db = authz.conf #使用哪个文件作为权限文件 配置passwd文件在[users]块中添加用户和密码，格式：帐号=密码，例如添加如下两个账户： 123[users]fzy = 123456hunau = 111111 配置authz文件在末尾添加如下代码： 123[/]fzy = rwhunau = r 意思是版本库的根目录fzy用户对其有读写权限，hunau用户只有读权限。 启动和使用配置成功以后，使用如下命令启动svn版本库服务： 1svnserve -d -r /var/svn #其中/var/svn为版本库根目录 查看是否启动成功： 1ps -ef|grep svnserve 关闭svn服务（1）使用以下命令查找进程 1ps aux | grep svn 如下：12root 22368 1 0 Aug29 ? 00:00:00 svnserve -d -r /var/svnroot 24538 24423 0 19:58 pts/0 00:00:00 grep --color=auto svn （2）使用Kill命令杀死进程 1kill -s 9 22368 #其中22368 为进程ID Windwos上客户端安装与使用（1）下载安装SVN Windows客户端：TortoiseSVN 下载地址：https://tortoisesvn.net/downloads.html （2）新建一个文件夹用来存放版本库文件 （3）右键选择SVN Checkout （4）填写SVN地址 格式为： 1svn://服务器ip地址/服务器上版本库名称/ （5）输入用户名密码 可以勾选保存账号密码，如果你只用一个账号的话可以这么做，如果需要经常切换账户的话最好不要勾选。 如果已经勾选了，但是又需要切换账户，怎么办呢？ 右键菜单：Settings -&gt; Saved Data-&gt; Authentication data -&gt; Clear （6）在repo文件夹下进行版本控制操作 可以将服务器上的文件通过SVN Update更新到本地，也可以将本地文件通过SVN commit提交到服务器，还有很多的操作，在这里就不一一讲解了，下次写一篇详细的博客进行介绍。 注：文件上传到服务器后存放在服务器什么地方呢？ 一般放在版本库路径下的db文件夹的revs文件夹中，例如我的为/var/svn/repo/db/revs。 需要注意的地方checkout时，提示：URL svn://服务器ip地址/repo doesn’t exist…奇怪，怎么会提示库不存在呢？肯定是哪里配置问题。后来尝试了半天，也在网上搜索了很久，终于发现问题所在。 如果你的svn库的路径为：/var/svn/repo 那么你启动时，不能用命令：1svnserve -d -r /var/svn/repo 而要用命令：1svnserve -d -r /var/svn/ commit时，提示：Authorization failed问题可能出在svnserve.conf这个文件。注意以下四行一定要取消注释： 1234# anon-access = read# auth-access = write# password-db = passwd# authz-db = authz 问题也有可能出在authz文件里，用户组或者用户权限没有配置好，只要设置[/]就可以，代表根目录下所有的资源，如果要限定资源，可以加上子目录即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法学习-刷题(七)]]></title>
      <url>%2F2016%2F08%2F27%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%B8%83%2F</url>
      <content type="text"><![CDATA[Happy NumberLeetCode第202题 题目描述Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1 思路分析快乐数（happy number）有以下的特性：在给定的进位制下，该数字所有数位(digits)的平方和，得到的新数再次求所有数位的平方和，如此重复进行，最终结果必为1。 如果一个数是一个happy number，那么最终是1循环，比较容易判断。如果一个数不是 happy number，那么存在一个循环，其中不包含1，这就比较难判断，因为不清楚这个循环周期大小。一种解决思路是通过HashSet来存取数字，如果这个数字之前存储好了，说明进入一个循环。利用HashSet元素不重复的性质，采用add方法，它会返回一个boolean值，如果集合中已经存在该元素返回false，否则返回true。 Java语言实现12345678910111213141516171819public class Solution &#123; public boolean isHappy(int n) &#123; Set&lt;Integer&gt; records = new HashSet&lt;Integer&gt;(); while(n!=1)&#123; if(!records.add(n)) //把结果添加到记录中，如果集合中已经存在该元素则判断为非快乐数 return false; else&#123; int sum = 0; while(n!=0)&#123; //依次得到各个位的平方数并加起来 int digit = n%10; sum = sum + digit*digit; n = n/10; &#125; n = sum; //把结果赋给n &#125; &#125; return true; &#125;&#125; 这道题目自己用C语言一直没有AC出来，于是上网找了找资料，所有不快乐数的数位平方和计算，最后都会进入4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4的周期性循环。那如何判断周期性循环呢？这就需要用到Floyd判圈算法的思想了： Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)。该算法由美国科学家罗伯特·弗洛伊德发明，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。 初始状态下，假设已知某个起点节点为节点S。现设两个指针t和h，将它们均指向S。接着，同时让t和h往前推进，但是二者的速度不同：t每前进1步，h前进2步。只要二者都可以前进而且没有相遇，就如此保持二者的推进。当h无法前进，即到达某个没有后继的节点时，就可以确定从S出发不会遇到环。反之当t与h再次相遇时，就可以确定从S出发一定会进入某个环。 运用此思想进行解题： LeetCode AC的代码123456789101112131415161718192021int digitSquareSum(int n) &#123; //得到该数字所有数位的平方和 int sum = 0, tmp; while (n) &#123; tmp = n % 10; sum += tmp * tmp; n /= 10; &#125; return sum;&#125;bool isHappy(int n) &#123; int slow, fast; slow = fast = n; //都从n开始 do &#123; slow = digitSquareSum(slow); //前进一步，即计算一次 fast = digitSquareSum(fast); //前进两步，即计算两次 fast = digitSquareSum(fast); &#125; while(slow != fast); //直到两者相等 if (slow == 1) return 1; //判断最终结果是否为1 else return 0;&#125; 这个问题的关键是如何结束一个潜在的无限循环，下面给出别人的更高效的方法，确实很不错。上面说到：所有不快乐数的数位平方和计算，最后都会进入4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4的周期性循环。因此，一旦出现2或4，那就可以判断为非快乐数但是下面带给出的是小于5，等与1时肯定是快乐数，2和4肯定不是快乐数，但是3还不确定，不明白作者为什么这么写。 12345678910111213141516171819202122public class Solution &#123; public boolean isHappy(int n) &#123; if ( n &lt; 5) &#123; //结束的条件 if (1 == n) return true; else return false; &#125; int sum = 0; // 得到各个位的数的平方和 while ( n &gt;= 10) &#123; sum += (n % 10) * (n % 10); n = n / 10; &#125; sum += n * n; return isHappy(sum); //递归调用 &#125;&#125; Remove ElementLeetCode第27题 题目描述Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. 思路分析删除数组中的指定元素，可以从头到尾遍历数组，判断是否等于目标数，如果不等于，则将其移到数组的前面。 例如： 数组nums为[1,2,2,3,2,4]，要删除的数为2 i=0，nums[0]不等于2，则有nums[0] = nums[0]; 数组为[1,2,2,3,2,4]，len=1 i=1，nums[1]等于2，继续下一次循环 i=2，nums[2]等于2，继续下一次循环 i=3，nums[3]不等于2，则有nums[1] = nums[3]; 数组为[1,3,2,3,2,4]，len=2 i=4，nums[4]等于2，继续下一次循环 i=5，nums[5]不等于2，则有nums[2] = nums[5]; 数组为[1,3,4,3,2,4]，len=3 返回len即可，数组的前len个数即为删除指定元素剩余的数组元素。 LeetCode AC的代码1234567891011int removeElement(int* nums, int numsSize, int val) &#123; int len = 0,i; for(i=0;i&lt;numsSize;i++)&#123; //遍历数组 if(nums[i] != val) //如果不等于目标数 &#123; nums[len] = nums[i]; //依次移到数组前端 len++; //记录不等于目标数的个数 &#125; &#125; return len;&#125; Delete Node in a Linked ListLeetCode第237题 题目描述Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function. Subscribe to see which companies asked this question 思路分析要删除链表中指定的节点，可以用一个指针指向要删除结点的下一个结点，然后将指针指向的结点的数据域和指针域复制给要删除的结点，再释放掉指针指向的结点，这样就从链表中成功删除了该结点。 LeetCode AC的代码12345678910111213/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */void deleteNode(struct ListNode* node) &#123; struct ListNode* p = node-&gt;next; //指向要删除结点的下一个结点 node-&gt;val = p-&gt;val; //把下一个结点的数据域复制给要删除的结点 node-&gt;next = p-&gt;next; //把下一个结点的指针域复制给要删除的结点 free(p); //释放下一个结点&#125; Count PrimesLeetCode第204题 题目描述Description: Count the number of prime numbers less than a non-negative number, n. 思路分析素数是指除了1和它本身以外,不能被任何整数整除的数。这是一个很老但是很经典的问题，大一的时候就遇到过这个问题，那时候只要求做出来并不没有时间复杂度等要求，但是这个题目不一样。题目要求统计小于n的数中素数的个数，方法多种，但是如果使用最原始的方法一般都会超时的，所以需要一个高效的办法来解决这个问题。 （1）基本思路（提交时超时）： 123456789101112int countPrimes(int n) &#123; int i,j,cnt=0; for(i=2;i&lt;n;i++)&#123; for(j=2;j&lt;=sqrt(i);j++)&#123; //和比它的平方根小的数相除 if(i%j==0) //如果除尽了是合数 break; &#125; if(j&gt;sqrt(i)) //如果都不能除尽则是素数 cnt++; &#125; return cnt;&#125; （2）利用数学规律解题 素数出现规律：当n≧5时，如果n为素数，那么n mod 6 = 1 或 n mod 6 = 5，即n一定出现在6x（x≥1）两侧。 可以参考这篇博客：高效判断素数方法 LeetCode AC的代码(1)12345678910111213141516171819202122bool isPrime(int num) &#123; int i; if(num == 2 || num == 3) return true; if (num % 6 != 1 &amp;&amp; num % 6 != 5) return false; for (i=5;i*i&lt;=num;i+=6) &#123; if(num%i == 0 || num%(i+2) == 0) return false; &#125; return true; &#125;int countPrimes(int n) &#123; int i,j,cnt=0; for(i=2;i&lt;n;i++)&#123; if(isPrime(i)) cnt++; &#125; return cnt;&#125; （3）改进方法 定义一个n个数大小的数组，并全部初始化为0,从2开始判断，如果这个数为0，则将他的倍数都标记为1，比如将2的倍数4，6，8…等都标记为1，然后3的倍数6，9，12…都标记为1，最后统计遍历这些数的过程中为等于0的次数。 LeetCode AC的代码(2)12345678910111213int countPrimes(int n) &#123; int i,j,cnt=0; int *prime; prime = (int *)malloc(sizeof(int)*n); //分配内存空间 for(i=2;i&lt;n;i++)&#123; //遍历小于n的数 if(prime[i] == 0)&#123; //如果这个数为0 cnt++; //记录加1 for(j=2;i*j&lt;n;j++) //将这个数的倍数都标记为1 prime[i*j] = 1; &#125; &#125; return cnt;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android WebView详解]]></title>
      <url>%2F2016%2F08%2F26%2FAndroid-WebView%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[Android提供了内置的浏览器，该浏览器使用了开源的WebKit引擎，要使用内置的浏览器就需要通过WebView来实现。Android WebView在Android平台上是一个特殊的View， 它能用来显示网页，这个类可以被用来在你的app中仅仅显示一张在线的网页，还可以用来开发浏览器。本文详细介绍了WebView的相关方法以及配置操作，最后通过一个简易的浏览器对WebView进行应用演示。 基本使用基本方法 方法 描述 loadUrl(String url) 用于加载指定url对应得网页 goBack() 执行后退操作，相当于浏览器的回退按钮功能 goForward() 执行前进操作，相当于浏览器的前进按钮功能 stopLoading() 用于停止加载当前页面 reload() 用于刷新当前页面 使用示例访问百度首页： 12mWebView = (WebView) findViewById(R.id.webView1);mWebView.loadUrl(&quot;http://www.baidu.com/&quot;); 这个时候发现一个问题，启动应用后，自动的打开了系统内置的浏览器，解决这个问题需要为webview设置WebViewClient，并重写重写WebViewClient的shouldOverrideUrlLoading方法返回true，这样新的连接就会在当前WebView中打开。 1234567mWebView.setWebViewClient(new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url)&#123; view.loadUrl(url); return true; &#125;&#125;); 进阶使用WebSettings常用方法获取设置WebView的WebSettings对象。 1mWebView.getSettings() //得到WebSettings对象 （1）设置支持自动加载图片 1mWebView.getSettings().setLoadsImagesAutomatically(true); （2）设置支持放大和缩小的功能 12mWebView.getSettings().setSupportZoom(true); mWebView..getSettings().setBuiltInZoomControls(true) （3）设置支持多窗口 1mWebView.getSettings().supportMultipleWindows(); （4） 设置支持JavaScript 1mWebView.getSettings().setJavaScriptEnabled(true); （5）设置将图片调整到适合webview的大小 1mWebView.getSettings().setUseWideViewPort(false); （6）设置支持插件 1mWebView.getSettings().setPluginsEnabled(true); WebViewClient常用方法设置将接收各种通知和请求的WebViewClient。 123mWebView.setWebViewClient(new WebViewClient()&#123; //可在此重写下列方法，以实现相应需求&#125;); （1）开始载入页面时调用 1onPageStarted(WebView view, String url, Bitmap favicon) （2）在页面加载结束时调用 1onPageFinished(WebView view, String url) （3）在加载页面资源时调用 1onLoadResource(WebView view, String url) （4）报告错误信息1onReceivedError(WebView view, int errorCode, String description, String failingUrl) （5）重写此方法才能够处理在浏览器中的按键事件 1shouldOverrideKeyEvent(WebView view, KeyEvent event) （6）控制新的连接在当前WebView中打开 1shouldOverrideUrlLoading(WebView view, String url) WebChromeClient常用方法设置chrome处理。 123mWebView.setWebChromeClient(new WebChromeClient() &#123; //可在此重写下列方法，以实现相应需求&#125;); （1）网页加载进度改变时调用 1onProgressChanged(WebView view, int newProgress) （2）网页加载完毕时获取网站标题 1onReceivedTitle(WebView view, String title) （3）创建WebView时 1onCreateWindow(WebView view, boolean isDialog,boolean isUserGesture, Message resultMsg) （4）关闭WebView时 1onCloseWindow(WebView window) （5）网页加载完毕时获取网站图标 1onReceivedIcon(WebView view, Bitmap icon) （6）WebView获得焦点时 1onRequestFocus(WebView view) 浏览器开发小技巧（1）设置android WebView 不显示滚动条 可以直接在layout中添加如下属性设置 1android:scrollbars=&quot;none&quot; （2）一些清除方法 1234mWebView.clearHistory(); //清除当前webview访问的历史记录mWebView.clearFormData(); //清除自动完成填充的表单数据mWebView.clearCache(); //清除网页访问留下的缓存mWebView.clearMatches(); //清除网页查找的高亮匹配字符 自制简易浏览器带前进、后退、主页、刷新按钮，网页加载进度条，网址输入框的简单浏览器。 实现效果如下： 添加网络访问权限1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class MainActivity extends Activity implements OnClickListener &#123; private WebView mWebView; private ImageButton mBack, mHome, mNext, mRefresh; private EditText mEditText; private ProgressBar mProgressBar; private String homeUrl = &quot;www.baidu.com&quot;; @SuppressLint(&quot;SetJavaScriptEnabled&quot;) @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); mWebView = (WebView) findViewById(R.id.wb_test_web); mBack = (ImageButton) findViewById(R.id.ib_back); //返回按钮 mHome = (ImageButton) findViewById(R.id.ib_home); //主页按钮 mNext = (ImageButton) findViewById(R.id.ib_next); //前进按钮 mRefresh = (ImageButton) findViewById(R.id.ib_refresh); //刷新按钮 mEditText = (EditText) findViewById(R.id.et_url); //网址输入框 mProgressBar = (ProgressBar) findViewById(R.id.pb_load); //网页加载进度条 /*设置监听事件*/ mBack.setOnClickListener(this); mHome.setOnClickListener(this); mNext.setOnClickListener(this); mRefresh.setOnClickListener(this); mEditText.setOnClickListener(this); /*WebView的基本设置*/ mWebView.getSettings().setJavaScriptEnabled(true); mWebView.getSettings().setSupportZoom(true); mWebView.getSettings().setBuiltInZoomControls(true); mWebView.setInitialScale(25); mWebView.getSettings().setUseWideViewPort(true); mWebView.setWebViewClient(new WebViewClient()); mWebView.setWebChromeClient(new WebChromeClient() &#123; @Override public void onProgressChanged(WebView view, int newProgress) &#123; // TODO Auto-generated method stub mProgressBar.setProgress(newProgress); //设置进度 System.out.println(newProgress); if (newProgress == 100) &#123; mProgressBar.setVisibility(View.GONE); //加载完后设置进度条不可见 &#125;else&#123; mProgressBar.setVisibility(View.VISIBLE); //设置进度条可见 &#125; super.onProgressChanged(view, newProgress); &#125; @Override public void onReceivedTitle(WebView view, String title) &#123; // TODO Auto-generated method stub mEditText.setText(title); //网站加载完后， super.onReceivedTitle(view, title); &#125; &#125;); /*加载主页*/ loadWeb(homeUrl); mEditText.setOnKeyListener(new OnKeyListener() &#123; @Override public boolean onKey(View v, int keyCode, KeyEvent event) &#123; // TODO Auto-generated method stub String url = mEditText.getText().toString(); if (keyCode == KeyEvent.KEYCODE_ENTER) &#123; if (!url.equals(&quot;&quot;)) &#123; loadWeb(url); return true; &#125; &#125; else &#123; Toast.makeText(MainActivity.this, &quot;请输入要访问的网址&quot;, Toast.LENGTH_SHORT).show(); &#125; return false; &#125; &#125;); &#125; public void loadWeb(String url) &#123; url = &quot;http://&quot; + url; //补全url mWebView.loadUrl(url); //加载页面 &#125; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub switch (v.getId()) &#123; case R.id.ib_back: mWebView.goBack(); //返回上一个页面 break; case R.id.ib_home: loadWeb(homeUrl); //回到主页 break; case R.id.ib_next: mWebView.goForward(); //前进到下一个页面 break; case R.id.ib_refresh: mWebView.reload(); //重新加载 break; case R.id.et_url: mEditText.setText(&quot;&quot;); //输入网站 mEditText.setHint(&quot;请输入网址&quot;); break; default: break; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android网络编程：HTTP协议]]></title>
      <url>%2F2016%2F08%2F22%2FAndroid%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9AHTTP%E5%8D%8F%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[HTTP协议是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。在之前的博客中多次使用HTTP网络请求，了解HTTP协议的详细工作过程以及报文格式，对于深入理解Android网络编程具有重要的意义。此篇博文通过搜集网络上优秀的博客文章，对HTTP协议的内容进行了较为详细的总结。 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 HTTP工作流程HTTP协议永远都是客户端发起请求，服务器回送响应。见下图： 这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。 HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。 一次HTTP操作称为一个事务，其工作过程可分为四步： （1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。 （2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。 （3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 （4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。 如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。 HTTP URL的格式1http://host[&quot;:&quot;port][abs_path] http表示通过HTTP协议来定位网络资源 host表示合法的Internet主机域名或者ip地址 port指定一个端口号，为空则使用默认端口80 abs_path指请求资源的URL HTTP请求报文HTTP请求由四部分组成，分别是：请求行、请求报头、空行、请求数据 请求行请求行格式： 1方法 请求的URL 版本 回车换行 HTTP请求方法： HTTP请求方法有8种，分别是GET、POST、PUT、DELETE、HEAD、OPTIONS、TRACE、CONNECT 。 GET：GET的本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现数据（如HTML文本，或者图片或者视频等）返回给客户端。 POST：向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。 PUT：本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。 DELETE：请求服务器删除请求的URI所标识的资源。 HEAD：HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。 OPTIONS：它可以用来获取服务器支持的HTTP请求方法，还可以用来用来检查服务器的性能。它对于服务端和用户端一定是安全的。 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 请求报头在请求行之后会有0个或者多个请求报头，每个请求报头都由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。 请求报头通知服务器关于客户端求求的信息，典型的请求头有： Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机 User-Agent：发送请求的浏览器类型、操作系统等信息 Accept：客户端可识别的内容类型列表，用于指定客户端接收那些类型的信息 Accept-Encoding：客户端可识别的数据编码 Accept-Language：表示浏览器所支持的语言类型 Connection：允许客户端和服务器指定与请求/响应连接有关的选项，例如设置为Keep-Alive则表示保持连接。 Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。 空行最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。 请求数据请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合，与请求数据相关的最常用的请求头是Content-Type和Content-Length。 HTTP响应报文HTTP响应也由四部分组成，分别是：状态行、响应报头、空行、响应数据 状态行状态行格式： 1版本 状态码 原因短语 回车换行 HTTP协议响应状态码： HTTP协议响应状态码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 常见状态代码、状态描述、说明： 200 OK 客户端请求成功 304 NOT MODIFIED 未修改；一般浏览器会缓存一些数据，当下次请求时将发送Etag与Last_Modified信息给服务器确定是否次文件在服务器修改过，若果是将重新加载 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 请求资源不存在，eg：输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 响应报头用于服务器传递自身信息的响应，常见的响应报头： Location：用于重定向接受者到一个新的位置，常用在更换域名的时候Server：包含可服务器用来处理请求的系统信息，与User-Agent请求报头是相对应的 响应数据服务器根据发送的请求返回的数据 HTTP报头HTTP报头分为通用报头，请求报头，响应报头和实体报头。 请求方的http报头结构：通用报头|请求报头|实体报头 响应方的http报头结构：通用报头|响应报头|实体报头 请求报头与响应报头在前文已经详细描述，下文主要讲解通用报头和实体报头。 通用报头既可以出现在请求报头，也可以出现在响应报头中 Date：表示消息产生的日期和时间 Connection：允许发送指定连接的选项，例如指定连接是连续的，或者指定“close”选项，通知服务器，在响应完成后，关闭连接 Cache-Control：用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制） 实体报头实体报头用来定于被传送资源的信息，既可以用于请求也可用于响应。请求和响应消息都可以传送一个实体，常见的实体报头为： Content-Type：发送给接收者的实体正文的媒体类型 Content-Lenght：实体正文的长度 Content-Language：描述资源所用的自然语言，没有设置则该选项则认为实体内容将提供给所有的语言阅读 Content-Encoding：实体报头被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。 Last-Modified：实体报头用于指示资源的最后修改日期和时间 Expires：实体报头给出响应过期的日期和时间 请求示例Windows下使用cmd的telnet命令模拟HTTP请求 打开命令提示符输入以下内容，建立连接1telnet blog.line-coding.tech 80 HTTP默认使用80端口，HTTPS默认使用443.此示例是对我的博客的一个404页面发送一个GET请求，所以请求地址为blog.line-coding.tech。 输入上面的命令回车之后就会进入命令界面，可以输入请求信息，也可以通过使用快捷键”Ctrl+](右中括号)”来打开本地回显功能查看自己输入的内容，在本地回显界面再按下回车就可以进入命令界面编辑请求信息。 输入请求头信息1234567GET / HTTP/1.1HOST:blog.line-coding.techUser-Agent:Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36Accept:*/*Accept-Encoding:gzip, deflate, sdchAccept-Language:zh-CNConnection:keep-alive 按两下回车键得到响应信息第一个回车代表请求头结束的空行，第二个回车代表请求数据为空并发送请求 结果如下： 红色箭头指示为我们输入的请求头，蓝色箭头指示的为响应报文的内容，下面还有一些内容就是响应数据。 参考文章： 1、《网络协议》HTTP 协议：http://blog.csdn.net/chenhanzhun/article/details/43149557 2、http协议学习系列：http://www.blogjava.net/zjusuyong/articles/304788.html 3、通过win7中cmd命令提示符telnet模拟http请求：http://blog.csdn.net/hsd2012/article/details/51075811]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法学习-刷题(六)]]></title>
      <url>%2F2016%2F08%2F21%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%85%AD%2F</url>
      <content type="text"><![CDATA[Valid AnagramLeetCode第242题 题目描述Given two strings s and t, write a function to determine if t is an anagram of s. For example,s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false. Note:You may assume the string contains only lowercase alphabets. 思路分析先将两个字符串按字母大小排序，再从头开始比较每一个字符，如果全相等则是，否则不是。这个方法可以得到结果，但是效率太低，字符串很长时会造成超时。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define true 1#define false 0char* sort(char *s,int len) //简单选择排序&#123; int i,j,min,temp; for(i=0;i&lt;len-1;i++) &#123; min = i; for(j=i+1;j&lt;len;j++) &#123; if(s[j]&lt;s[min]) min = j; &#125; if(min!=i) &#123; temp = s[i]; s[i] = s[min]; s[min] = temp; &#125; &#125; return s;&#125;int isAnagram(char* s, char* t) &#123; //判断字符串是否相等 int len1,len2,i; len1 = strlen(s); len2 = strlen(t); if(len1 == len2) &#123; s = sort(s,len1); t = sort(t,len2); for(i=0;i&lt;len1;i++) //从第一个字符开始按顺序判断每个字符是否相等 &#123; if(s[i] == t[i]) continue; else return false; &#125; if(i==len1) //如果全相等，则返回真 return true; &#125; else return false;&#125;int main()&#123; char s[100],t[100]; gets(s); //输入两个字符串 gets(t); if(isAnagram(s,t)) printf(&quot;YES!\n&quot;); else printf(&quot;NO!\n&quot;); return 0;&#125; 更好的解法26个字母，用一个数组来记录每个字母出现的次数，如果某个字母在第一个数组出现，它第二个数组中出现时则计数减一，最好判断计数数组是否全为0。 1234567891011121314151617181920212223242526bool isAnagram(char* s, char* t) &#123; int scnt = 0; int tcnt = 0; int i; int histogram[26] = &#123;0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0&#125;; //初始化记录数组 while(s[scnt] != &apos;\0&apos;)&#123; histogram[s[scnt] - 97]++; //对应记录值加一 scnt++; &#125; while(t[tcnt] != &apos;\0&apos;)&#123; histogram[t[tcnt] - 97]--; //对应记录值减一 tcnt++; &#125; if(scnt != tcnt) return false; else if(scnt == 0) return true; else&#123; for(i = 0; i &lt; 26 ; i++) if(histogram[i] != 0) return false; //判断所有记录值是不是都为0 return true; &#125;&#125; 终极解决办法从两个字符串第一个字符开始，依次记录两个字符串的对应字符的ASCLL码的差值，如果最后得到的记录值为0，则说明两个字符串中含有的字符完全相同，否则不相同。 12345678910111213141516bool isAnagram(char* s, char* t) &#123; int total = 0; if(strlen(s)!=strlen(t)) //如果字符串长度不相等则无须比较 return false;//按顺序遍历两个字符串，用total来记录两个字符串中字符的ascll码值差值，如果最后差值等与0，则可判断为字符相等，否则不想等。 while((*s)!=&apos;\0&apos;) &#123; total += (*s-*t); s++; t++; &#125; if(total==0) return true; else return false;&#125; 超简洁的python实现1return sorted(s) == sorted(t) Add DigitsLeetCode第258题 题目描述Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. For example: Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime? //这个要求好像没达到，但是还是AC了 思路分析对取余得到数的各个位的数值，然后加起来，得到一个新的数，判断这个新的数是否还可以进行上述步骤，即判断该数是否大于10，如果大于10则递归执行上述操作，否则该数即为我们需要的结果。 LeetCode AC的代码1234567891011int addDigits(int num) &#123; int sum=0; while(num)&#123; //求各个位的值的和 sum = sum + num%10; num = num/10; &#125; if(sum&gt;=10) return addDigits(sum); //递归执行 else return sum;&#125; Two SumLeetCode第1题 题目描述Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 思路分析给了一个数组，然后给一个目标数，找出目标数是由数组中哪两个数相加得到的，输出那两个数的下标。我们只要从第一个数开始将每个数与后面的数依次相加并判断相加的结果是否等于目标数 一定要注意代码编辑部分的提示，返回的数组必须自己使用malloc分配内存，否则即使你做对了也一直无法AC，这就是我的惨痛教训！ LeetCode AC的代码1234567891011121314151617181920/** * Note: The returned array must be malloced, assume caller calls free(). */int* twoSum(int* nums, int numsSize, int target) &#123; int i,j,*res; res = (int *)malloc(sizeof(int)*2); for(i=0;i&lt;numsSize-1;i++) //从第一个数开始将每个数与后面的数依次相加 &#123; for(j=i+1;j&lt;numsSize;j++) &#123; if(nums[i] + nums[j] == target) //判断相加的结果是否等于目标数 &#123; res[0] = i; res[1] = j; return res; &#125; &#125; &#125; return res;&#125; Palindrome NumberLeetCode第9题 题目描述Determine whether an integer is a palindrome. Do this without extra space. 思路分析“回文”是指正读反读都能读通的句子，在数学中也有这样一类数字有这样的特征，成为回文数（palindrome number） 判断一个数是不是回文数，只要回文数是否与其倒置后的数相等 例如： 123倒置后为321，不是回文数 12344321倒置后仍为12344321，即为回文数 LeetCode AC的代码1234567891011121314151617bool isPalindrome(int x) &#123; int mod,inverse=0,num; if(x&lt;0) //负数必定不是回文数 return false; num = x; while(num) //把数倒置 &#123; mod = num%10; inverse = inverse*10 + mod; num = num/10; &#125; if(inverse==x) //判断原数与倒置后的数是否相等 return true; else return false; return true;&#125; Excel Sheet Column TitleLeetCode第168题 题目描述Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 12345671 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB LeetCode AC的代码1234567891011121314151617181920212223char* convertToTitle(int n) &#123; int i=0,j; char *s,temp; s = (char *)malloc(sizeof(char)*100); while(n) &#123; s[i] = (char)((n-1)%26+65); n = (n-1)/26; i++; &#125; s[i]=&apos;\0&apos;; if(i&gt;1)&#123; for(j=0;j&lt;i/2;j++) &#123; temp = s[j]; s[j] = s[i-1-j]; s[i-1-j] = temp; &#125; &#125; return s;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法学习-刷题(五)]]></title>
      <url>%2F2016%2F08%2F18%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%BA%94%2F</url>
      <content type="text"><![CDATA[Move ZeroesLeetCode第283题 题目描述Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note: 1、You must do this in-place without making a copy of the array. 2、Minimize the total number of operations. 思路分析题目要求把数组中的0移到数组后面去，主要是需要考虑全0、前面几个连续的0、已经是只有后面有0的情况，一开始抓着0来做，后来发现找非0的数会更方便一点，将非0的数依次前移，然后将后面的空位全部补0就可以完成任务了。 LeetCode AC的代码123456789101112void moveZeroes(int* nums, int numsSize) &#123; int i,j,m=0; for(i=0;i&lt;numsSize;i++) &#123; if(nums[i] != 0) nums[m++] = nums[i]; //将不为0的数前移 &#125; for(j=m;j&lt;numsSize;j++) //将后面空出的位置补0 &#123; nums[j] = 0; &#125;&#125; Problem A. 众数北邮2014年研究生复试机试题 题目描述给定一个长度为N的非降数列，求数列中出现次数最多的数。如果答案不唯一，输出其中最小的数。 输入格式 输入数据第一行是一个整数T(1&lt;=T&lt;=100)，表示测试数据的组数。注意各组测试数据是相互独立的。 对于每组测试数据： 第一行是一个正整数N（1&lt;=N&lt;=100），表示数列长度。 第二行有N个正整数，整数之间用空格隔开，所有的整数都不超过10的5次方 ，表示这个数列。 输出格式 对于每组测试数据，输出一个整数。 输入样例 2 4 1 1 1 2 5 1 1 2 2 3 输出样例 1 1 思路分析对输入序列进行排序，然后从头开始统计相同整数的个数，将个数最多的整数输出即可。 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char* sort(int *s,int len)&#123; //简单选择排序 int i,j,min,temp; for(i=0;i&lt;len-1;i++) &#123; min = i; for(j=i+1;j&lt;len;j++) &#123; if(s[j]&lt;s[min]) min = j; &#125; if(min!=i) &#123; temp = s[i]; s[i] = s[min]; s[min] = temp; &#125; &#125; return s;&#125;int main()&#123; int n,m,i,j,*num,count,k,result; scanf(&quot;%d&quot;,&amp;n); while(n--)&#123; scanf(&quot;%d&quot;,&amp;m); num = (int *)malloc(sizeof(int)*m); for(i=0;i&lt;m;i++) scanf(&quot;%d&quot;,&amp;num[i]); num = sort(num,m); //对输入序列进行排序 count=0; k=1; for(i=0;i&lt;m-1;i++) &#123; if(num[i] == num[i+1])&#123; k++; //如果连续的数相等，则计数加1 &#125;else&#123; k=1; //如果连续的数不相等，则计数清空 &#125; if(count&lt;k) //如果此时的统计个数大于之前的记录值则当前为最大值 &#123; count = k; //统计个数最多的数 result = num[i]; //记录个数最多的数的值 &#125; &#125; printf(&quot;%d\n&quot;,result); &#125; return 0;&#125; Ugly NumberLeetCode第263题 题目分析Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. 思路分析把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。 所谓一个数m是另一个数n的因子，是指n能被m整除，也就是n % m == 0。根据丑数的定义，丑数只能被2、3和5整除。也就是说如果一个数如果它能被2整除，我们把它连续除以2；如果能被3整除，就连续除以3；如果能被5整除，就除以连续5。如果最后我们得到的是1，那么这个数就是丑数，否则不是。 LeetCode AC的代码1234567891011121314bool isUgly(int num) &#123; if(num&lt;=0) return false; while(num%2==0) //连续除以2 num /= 2; while(num%3==0) //连续除以3 num /= 3; while(num%5==0) //连续除以5 num /= 5; if(num == 1) //如果最后得到1，则证明只能被2，3，5整除，即为丑数 return true; else return false;&#125; Problem B. 旋转图像北邮2014年研究生复试机试题 题目描述在图形学中，我们经常需要对具体的图像进行一些处理。在这个问题中，你的任务是将一幅只包含01像素点的图片进行顺时针旋转。旋转的角度仅包含0度，90度，180度，270度。 输入格式 输入的第一行是一个整数T（T&lt;=50），表示输入的数据组数。 每组测试数据的第一行是两个整数N和M，（1&lt;=N,M&lt;=50），表示图片的高度和宽度。 接下来N行，每行是一个长度为M的01串，表示图片的像素点。 最后一行是一个整数angle，表示旋转的角度。 输出格式 对于每组测试数据，输出旋转后得到的图片。请注意不要输出多余的空格或空行。 12345678910111213141516171819输入样例22 3111000903 3111101111180输出样例010101111101111 思路分析此题的关键在于选择合适的存储方式，因为题目中图片有宽高，输入的情况类似于一个矩阵，因此可采用二维数组来存储输入的字符，然后根据旋转角度分情况将字符数组按要求输出即可。 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void rotate0(char** s,int n,int m)&#123; int i; for(i=0;i&lt;n;i++) printf(&quot;%s\n&quot;,s[i]);&#125;void rotate90(char** s,int n,int m)&#123; int i,j; for(i=0;i&lt;m;i++) &#123; for(j=n-1;j&gt;=0;j--) &#123; printf(&quot;%c&quot;,s[j][i]); &#125; printf(&quot;\n&quot;); &#125;&#125;void rotate180(char** s,int n,int m)&#123; int i,j; for(i=n-1;i&gt;=0;i--) &#123; for(j=0;j&lt;m;j++) &#123; printf(&quot;%c&quot;,s[i][j]); &#125; printf(&quot;\n&quot;); &#125;&#125;void rotate270(char** s,int n,int m)&#123; int i,j; for(i=0;i&lt;m;i++) &#123; for(j=0;j&lt;n;j++) &#123; printf(&quot;%c&quot;,s[j][i]); &#125; printf(&quot;\n&quot;); &#125;&#125;int main()&#123; int t,m,n,i,j,angle; char **s; //定义二维字符数组 scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); s = (char **)malloc(sizeof(char *)*n); //为二维数组动态分配内存 for(i=0;i&lt;n;i++) &#123; s[i] = (char *)malloc(sizeof(char)*m); scanf(&quot;%s&quot;,s[i]); //输入字符串 &#125; scanf(&quot;%d&quot;,&amp;angle); switch(angle)&#123; case 0: rotate0(s,n,m); break; //旋转0度 case 90: rotate90(s,n,m); break; //旋转90度 case 180: rotate180(s,n,m); break; //旋转180度 case 270: rotate270(s,n,m); break; //旋转270度 &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法学习-刷题(四)]]></title>
      <url>%2F2016%2F08%2F16%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%9B%9B%2F</url>
      <content type="text"><![CDATA[Add BinaryLeetCode第67题 题目描述Given two binary strings, return their sum (also a binary string). For example, a = “11” b = “1” Return “100”. 思路分析一开始想到的方法是先将字符串转换成十进制数，再按十进制进行加处理，最后再将结果转换成二进制进行输出，然后试了好久一直超时，可能是效率太低了吧，一直都没有得到AC的结果。 最后，还是参考了一下别人的思路：字符串按位相加，先将两个字符串的相同部分从字符串尾部开始进行按位加操作，记录进位，并且加到下一位去，将加的结果存到另一个字符串中，再将长那一部分字符与上一步得到的进位进行按位加，同样将加的结果存在第三个字符串，如果最后还有进位，再把最后的进位加到字符串的尾部，但是最后得到的字符串并不是题目要求的结果，而是题目要求的结果的逆序字符串，所以还得进行字符串反转。 LeetCode AC的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667char* addBinary(char* a, char* b) &#123; int len1,len2,len3,i,j,num,flag=0; char *c,temp; len1 = strlen(a) - 1; len2 = strlen(b) - 1; c = (char *)malloc(sizeof(char)*100); //为结果字符串分配内存空间 i=0; while(len1&gt;=0&amp;&amp;len2&gt;=0) //从最低位开始将a字符串与b字符串等长的那一部分按位加 &#123; num = (a[len1]-&apos;0&apos;)+(b[len2]-&apos;0&apos;)+flag; flag = num/2; //判断是否有进位 num = num%2; //得到该位相加的结果 c[i] = (char)(num+&apos;0&apos;); //添加到结果字符串 len1--; //移动到下一次字符 len2--; //移动到下一次字符 i++; &#125; while(len1&gt;=0) //如果a字符串比b长，则将a比b长的那一部分将入到结果字符串 &#123; num = (a[len1]-&apos;0&apos;)+flag; flag = num/2; num = num%2; c[i] = (char)(num+&apos;0&apos;); len1--; len2--; i++; &#125; while(len2&gt;=0) //如果b字符串比a长，则将b比a长的那一部分将入到结果字符串 &#123; num = (b[len2]-&apos;0&apos;)+flag; flag = num/2; num = num%2; c[i] = (char)(num+&apos;0&apos;); len1--; len2--; i++; &#125; if(flag&gt;0) //处理最后的进位 &#123; c[i] = (char)(flag+&apos;0&apos;); i++; &#125; c[i] = &apos;\0&apos;; //添加字符串结束符 len3 = strlen(c); for(j=0;j&lt;len3/2;j++) //将结果字符串反转 &#123; temp = c[j]; c[j] = c[len3-1-j]; c[len3-1-j] = temp; &#125; return c; //返回结果字符串&#125; Length of Last WordLeetCode第58题 题目描述Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example,Given s = “Hello World”,return 5. 思路分析从头开始记录每个单词的长度，再判断空格的位置，空格之后还有单词则清空对前一个单词长度的记录，记录这个单词的长度，直到找到最后一个单词。 LeetCode AC的代码123456789101112131415161718192021222324int lengthOfLastWord(char* s) &#123; int i,j,count=0; for(i=0;s[i]!=&apos;\0&apos;;i++) &#123; if(isalpha(s[i])) //判断是不是字母 &#123; count++; //记录word长度 continue; &#125; if(isspace(s[i])) //如果是空格，则判断之后是否还有空格，如果有则不是最后的字符串，否则是最后的字符串 &#123; for(j=i;a[j]!=&apos;\0&apos;;j++) &#123; if(isspace(s[j])) //如果是连续的空格则继续下一个字符 continue; else //如果空格后还有字符，则进入下一次循环 break; &#125; if(s[j]!=&apos;\0&apos;) //如果不是最后的word，则将计数清空 count=0; &#125; &#125; return count; //返回word的长度&#125; Power of ThreeLeetCode第326题 题目描述Given an integer, write a function to determine if it is a power of three. Follow up:Could you do it without using any loop / recursion? 思路分析判断是否是3的次方，让这个数一直除以3，如果余数全为0，则可判定为3的指数。 LeetCode AC的代码12345678910111213bool isPowerOfThree(int n) &#123; if(n&lt;=0) return false; if(n == 1) return true; while(n&gt;1) &#123; if(n%3) return false; //判断余数是不是0，是则继续下一步，否则判定为不是3的次方 n = n/3; //得到商 &#125; return true;&#125; Power of FourLeetCode第342题 题目描述Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example: Given num = 16, return true. Given num = 5, return false. Follow up: Could you solve it without loops/recursion? 思路分析此题与上一题思路一致。 LeetCode AC的代码12345678910111213bool isPowerOfFour(int num) &#123; if(num&lt;=0) return false; if(num == 1) return true; while(num&gt;1) &#123; if(num%4) return false; num = num/4; &#125; return true;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法学习-刷题(三)]]></title>
      <url>%2F2016%2F08%2F14%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%B8%89%2F</url>
      <content type="text"><![CDATA[Power of TwoLeetCode第231题 题目描述Given an integer, write a function to determine if it is a power of two. 思路分析i&amp;(i - 1)是用来判断一个数是否是2的指数的快捷方法，比如8，二进制位1000, 那么8&amp;(8-1)为0，只要&amp;的结果为0就是2的指数。 leetcode AC的代码12345678910111213bool isPowerOfTwo(int n) &#123; if(n&lt;=0) &#123; return false; &#125; else &#123; if(n&amp;(n-1)) return false; else return true; &#125;&#125; 提交上面的代码之后发现这个效率还是不太高啊，于是又到讨论区去学习了一下别人的思路，以下是一个相对高效的代码： 1234567891011121314bool isPowerOfTwo(int n) &#123; //int型最大32位，但是最大值取不到，所以最大的2的次方只能到0x40000000 int ref = 0x40000000; if(n&lt;=0) &#123; return false; &#125; else &#123; while( ref &gt; n) ref &gt;&gt;= 1; //如果n比ref小，则ref移位直到ref小于n //ref始终是2的次方 return ( n == ref ) ? true : false; //比较n与ref是否相等 &#125;&#125; Reverse StringLeetCode第344题 题目描述Write a function that takes a string as input and returns the string reversed. Example: Given s = “hello”, return “olleh”. 思路分析字符串反转，其实也是比较简单的一道题，最近在做考研数据结构的复习题，在线性表的课后习题中看到了类似的考题。基本思路就是字符互换。 leetcode AC的代码123456789101112char* reverseString(char* s) &#123; int len,i; char temp; len = strlen(s); //获取字符串长度 for(i=0;i&lt;len/2;i++) //进行前半段字符与后半段字符的依次互换 &#123; temp = s[i]; s[i] = s[len-1-i]; s[len-1-i] = temp; &#125; return s;&#125; 这也是AC的代码，从字符串两端开始互换，运行起来比上一个要快一点点 12345678910111213141516char* reverseString(char* s) &#123; int len,start,end; char temp; len = strlen(s); //获取字符串长度 start = 0; //字符串开始位置 end = len -1; //字符串结束位置 while(start&lt;end) //字符互换并移到下一个字符 &#123; temp = s[start]; s[start] = s[end]; s[end] = temp; start++; end--; &#125; return s;&#125; 本地测试时的代码1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; char *str; str = (char *)malloc(sizeof(char)*100); scanf(&quot;%s&quot;,str); len = strlen(str); for(i=0;i&lt;len/2;i++) &#123; temp = p[i]; p[i] = p[len-1-i]; p[len-1-i] = temp; &#125; printf(&quot;%s&quot;,p); return 0;&#125; Reverse Vowels of a StringLeetCode第345题 题目描述Write a function that takes a string as input and reverse only the vowels of a string. Example 1: Given s = “hello”, return “holle”. Example 2: Given s = “leetcode”, return “leotcede”. Note:The vowels does not include the letter “y”. 思路分析将字符串中的元音字母进行互换。从字符串的头尾两端进行扫描，发现元音字母就将标志位置为并停止移动，当两边都找到一个元音字母时就进行互换，再清空标志位，继续移位寻找。 leetcode AC的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950char isVowels(char c)&#123; switch(c) &#123; case &apos;a&apos;: case &apos;o&apos;: case &apos;e&apos;: case &apos;i&apos;: case &apos;u&apos;: case &apos;A&apos;: case &apos;O&apos;: case &apos;E&apos;: case &apos;I&apos;: case &apos;U&apos;: return 1; default: return 0; &#125; return 0;&#125;char* reverseVowels(char* s) &#123; int len,start,end,start_flag,end_flag; char temp; len = strlen(s); start = 0; end = len - 1; while(start &lt; end) &#123; if(isVowels(s[start])) start_flag = 1; //找到元音字母，则将标志位置为1，并停止移动 else start++; if(isVowels(s[end])) end_flag = 1; //找到元音字母，则将标志位置为1，并停止移动 else end--; if((start_flag == 1)&amp;&amp;(end_flag == 1)) //左右标志位均被置位时进行互换 &#123; temp = s[start]; s[start] = s[end]; s[end] = temp; start_flag = 0; //标志位清零 end_flag = 0; start++; //继续移动 end--; &#125; &#125; return s;&#125; 本地测试的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char isVowels(char c)&#123; switch(c) &#123; case &apos;a&apos;: case &apos;o&apos;: case &apos;e&apos;: case &apos;i&apos;: case &apos;u&apos;: case &apos;A&apos;: case &apos;O&apos;: case &apos;E&apos;: case &apos;I&apos;: case &apos;U&apos;: return 1; default: return 0; &#125; return 0;&#125;int main()&#123; int len,start,end,start_flag,end_flag; char *str,temp; str = (char *)malloc(sizeof(char)*100); scanf(&quot;%s&quot;,str); len = strlen(str); printf(&quot;%d&quot;,len); start = 0; end = len - 1; while(start &lt; end) &#123; if(isVowels(str[start])) start_flag = 1; else start++; if(isVowels(str[end])) end_flag = 1; else end--; if((start_flag == 1)&amp;&amp;(end_flag == 1)) &#123; temp = str[start]; str[start] = str[end]; str[end] = temp; start_flag = 0; end_flag = 0; start++; end--; &#125; &#125; printf(&quot;%s&quot;,str); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android网络请求框架Android-async-http]]></title>
      <url>%2F2016%2F08%2F14%2FAndroid%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6Android-async-http%2F</url>
      <content type="text"><![CDATA[Http网络数据交互是Android中极其重要并且使用很频繁的模块。前段时间写了一篇博客总结了Android Http网络请求，但是其中还有很多没有考虑到的问题。众所周知，网络请求方式的效率和性能直接影响到APP的整体用户体验流畅性，在我们自己编写网络请求方法中往往不会考虑这么周全。但是，还好有技术大牛为我们提供了开源的第三方网络请求框架：Android-async-http。 Android-async-http简介Async-http是一款国外的开源框架，是基于Apache HttpClient库的，使用它可以方便快速高效的进行网络数据请求和发送，文件下载和上传。 特点： 清晰的网络请求回调； 内部采用线程池来处理并发请求，限制并发资源使用情况； http请求发生在UI（主）线程之外的异步线程中； 内置多部分文件上传，不需要第三方库支持； 流式Json上传，不需要额外的库； 在各种各样的移动连接环境中具备自动智能请求重试机制； 等等 简单应用下载jar包（1）Github地址：https://github.com/loopj/android-async-http （2）CSDN下载地址：http://download.csdn.net/detail/bambooofmottled/7866567 （3）也可以自己百度去找，这是一个很受欢迎的开源框架，资源很丰富。 添加到工程将jar包复制到工程的libs目录下，右键移到Build Path然后点击Add to Build Path。 封装自己的Http请求类封装了HTTP请求中最常见的GET和POST方法的请求，通过Handler在异步网络请求与UI主线程之间来传递消息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class HttpUtil &#123; private static AsyncHttpClient client; public static void doGet(String url, final Handler handler) &#123; client = new AsyncHttpClient(); //可以为Http请求添加头部信息，比如很多开放的API都需要添加申请到的api-key client.addHeader(&quot;键&quot;, &quot;值&quot;); client.get(url, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int statusCode, Header[] headers,byte[] responseBody) &#123; // TODO Auto-generated method stub String response = new String(responseBody); System.out.println(response); //打印接收到的数据，以便调试 Message msg = new Message(); //将数据封装到Message中 msg.obj = response; handler.sendMessage(msg); //使用Handler将Message传给UI线程，以便刷新界面 &#125; @Override public void onFailure(int statusCode, Header[] headers,byte[] responseBody, Throwable error) &#123; // TODO Auto-generated method stub String response = new String(responseBody); System.out.println(response); //打印错误信息，以便调试 &#125; &#125;); &#125; public static void doPost(String url, RequestParams params,final Handler handler) &#123; client = new AsyncHttpClient(); //可以为Http请求添加头部信息，比如很多开放的API都需要添加申请到的api-key client.addHeader(&quot;键&quot;, &quot;值&quot;); client.post(url, params, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int statusCode, Header[] headers,byte[] responseBody) &#123; // TODO Auto-generated method stub String response = new String(responseBody); System.out.println(response); //打印接收到的数据，以便调试 Message msg = new Message(); msg.obj = response; //将数据封装到Message中 handler.sendMessage(msg); //使用Handler将Message传给UI线程，以便刷新界面 &#125; @Override public void onFailure(int statusCode, Header[] headers,byte[] responseBody, Throwable error) &#123; // TODO Auto-generated method stub String response = new String(responseBody); System.out.println(response); //打印错误信息，以便调试 &#125; &#125;); &#125;&#125; 使用示例调用自己封装好的GET请求和POST请求方法都需要传递Handler来传递消息，以便在网络请求我完成时，将服务器返回的数据传递给UI线程，然后进行UI更新。 12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends Activity &#123; private Handler mGetHandler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; String res = (String) msg.obj; Toast.makeText(MainActivity.this, &quot;请求成功&quot;, Toast.LENGTH_SHORT).show(); System.out.println(res); //打印传递过来的数据 //此处，拿到数据之后就可以解析数据，比如JSON数据解析，然后进行UI的更新 &#125;; &#125;; private Handler mPostHandler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; String res = (String) msg.obj; Toast.makeText(MainActivity.this, &quot;请求成功&quot;, Toast.LENGTH_SHORT).show(); System.out.println(res); //打印传递过来的数据 //此处，拿到数据之后就可以解析数据，比如JSON数据解析，然后进行UI的更新 &#125;; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); String getUrl = &quot;你的get请求的url&quot;; HttpUtil.doGet(getUrl, mGetHandler); String postUrl = &quot;你的post请求的url&quot;; RequestParams params = new RequestParams(); params.add(&quot;键&quot;, &quot;值&quot;); //可通过add方法添加多个请求参数 HttpUtil.doPost(postUrl, params, mPostHandler); &#125;&#125; 此博客主要展示了如何使用Android-async-http的GET和POST请求，这也是我自己在开发中最常用的两个请求方法，虽然这只是这个强大的网络请求库的一部分功能，但是这已经让我的开发变得更方便高效，也使得开发的应用程序的网络请求能够稳定高效，除此之外，Android-async-http还有很多优秀的功能，有机会再好好挖掘，先分享到这里。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android AlertDialog详解]]></title>
      <url>%2F2016%2F08%2F13%2FAndroid-AlertDialog%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[AlertDialog就是Android中的弹出式对话框，很多应用中都有对AlertDialog的应用。前段时间，一位学长问我自定义AlertDialog的问题，因为自己也只是之前用过，并不是很熟悉，所以我也只能很抱歉地回绝了，这一次通过写这篇博客对AlertDialog的操作进行了详细的总结，介绍了AlertDialog类和AlertDialog.Builder类，以及给AlertDialog设置不同的内容，最后还实现了自定义的AlertDialog。 AlertDialog继承自Dialog类，对于Android内置的AlertDialog，它可以包含一个标题、一个内容消息或者一个选择列表、最多三个按钮。而创建AlertDialog推荐使用它的一个内部类AlertDialog.Builder创 建，使用Builder对象，可以设置AlertDialog的各种属性，最后通过Builder.create()就可以得到AlertDialog对 象，再使用Builder.show()方法来显示。 官方图解： （1）区域1是AlertDialog对话框的头部信息区域，包括标题名或者是一个图标。 （2）区域2是AlertDialog对话框的内容部分，在这里我们可以设置Message信息或者是选择框，还可以设置自定义的布局弹出框。 （3）区域3是AlertDialog对话框的操作按钮部分，可以设置相应的按钮。 AlertDialog类常用方法 方法 描述 setTitle(CharSequence title) 为对话框设置标题 setIcon(Drawable icon) 通过Drawable资源对象为对话框设置图标 setIcon(int resId) 通过资源ID为对话框设置图标 setButton(int whichButton, CharSequence text, DialogInterface.OnClickListener listener) 为对话框添加按钮 setMessage(CharSequence message) 为对话框设置提示内容 使用示例12345678910111213141516171819202122AlertDialog dialog = new AlertDialog.Builder(this).create();dialog.setTitle(&quot;退出&quot;);dialog.setMessage(&quot;是否要退出&quot;);dialog.setButton(DialogInterface.BUTTON_NEGATIVE, &quot;取消&quot;,new OnClickListener() &#123; @Override public void onClick(DialogInterface arg0, int arg1) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;取消&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125;);dialog.setButton(DialogInterface.BUTTON_POSITIVE, &quot;确定&quot;,new OnClickListener() &#123; @Override public void onClick(DialogInterface arg0, int arg1) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;确定&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125;);dialog.show(); AlertDialog.Builder类AlertDialog类提供了弹出框的一些基本的方法，但是要想设置更多的元素来丰富我们的弹出框就要使用到AlertDialog.Builder类了。 常用方法 方法 描述 setTitle(CharSequence title) 为对话框设置标题 setIcon(Drawable icon) 通过Drawable资源对象为对话框设置图标 setIcon(int resId) 通过资源ID为对话框设置图标 setMessage(CharSequence message) 为对话框设置提示内容 setNegativeButton(CharSequence text, DialogInterface.OnClickListener listener) 为对话框添加取消按钮 setPositiveButton(CharSequence text, DialogInterface.OnClickListener listener) 为对话框添加确定按钮 setNeutralButton(CharSequence text, DialogInterface.OnClickListener listener) 为对话框添加中立按钮 setItems(CharSequence[] items, DialogInterface.OnClickListener listener) 为对话框设置列表项 setSingleChoiceItems(CharSequence[] items, int checkedItem, DialogInterface.OnClickListener listener) 为对话框设置单选列表项 setMultiChoiceItems(CharSequence[] items, boolean[] checkedItems, DialogInterface.OnMultiChoiceClickListener listener) 为对话框设置多选列表项 注意：setMessage()、setItems()、setSingleChoiceItems()、setMultiChoiceItems()方法不能同时使用。因为他们都是对弹出框的内容区域的设置。 设置按钮12345678910111213141516171819202122232425262728293031Builder builder = new AlertDialog.Builder(this);builder.setTitle(&quot;更新&quot;);builder.setMessage(&quot;是否要进行更新？&quot;);builder.setNegativeButton(&quot;取消&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;取消&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setPositiveButton(&quot;确定&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;确定&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setNeutralButton(&quot;忽略&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;忽略&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.show(); 设置列表项1234567891011121314final CharSequence items[] = new String[] &#123;&quot;北京&quot;,&quot;上海&quot;,&quot;广州&quot;,&quot;深圳&quot;,&quot;成都&quot;,&quot;南京&quot;&#125;;Builder builder = new AlertDialog.Builder(MainActivity.this);builder.setTitle(&quot;请选择&quot;);builder.setItems(items, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub String selectedItem = items[whitch].toString(); Toast.makeText(MainActivity.this, selectedItem, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.show(); 设置单选列表项1234567891011121314151617181920212223242526272829303132final CharSequence items[] = new String[] &#123;&quot;北京&quot;,&quot;上海&quot;,&quot;广州&quot;,&quot;深圳&quot;,&quot;成都&quot;,&quot;南京&quot;&#125;;Builder builder = new AlertDialog.Builder(MainActivity.this);builder.setTitle(&quot;请选择&quot;);builder.setSingleChoiceItems(items, 1, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub String selectedItem = items[whitch].toString(); Toast.makeText(MainActivity.this, selectedItem, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setNegativeButton(&quot;取消&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;取消&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setPositiveButton(&quot;确定&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub dialog.dismiss(); &#125;&#125;);builder.show(); 设置多选列表项123456789101112131415161718192021222324252627282930313233CharSequence items[] = new String[] &#123;&quot;北京&quot;,&quot;上海&quot;,&quot;广州&quot;,&quot;深圳&quot;,&quot;成都&quot;,&quot;南京&quot;&#125;;boolean[] checkedItems = new boolean[] &#123;true,false,true,true,false,true&#125;; Builder builder = new AlertDialog.Builder(MainActivity.this);builder.setTitle(&quot;请选择&quot;);builder.setMultiChoiceItems(items, checkedItems, new OnMultiChoiceClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch, boolean isChecked) &#123; // TODO Auto-generated method stub &#125;&#125;);builder.setNegativeButton(&quot;取消&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;取消&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setPositiveButton(&quot;确定&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub dialog.dismiss(); &#125;&#125;);builder.show(); 自定义AlertDialog123456789101112131415161718192021222324252627282930Builder builder = new AlertDialog.Builder(MainActivity.this);builder.setTitle(&quot;请输入&quot;);// 通过LayoutInflater来加载布局文件作为一个View对象View view = LayoutInflater.from(MainActivity.this).inflate(R.layout.alterdialog, null);// 设置自定义的布局文件作为弹出框的内容builder.setView(view);final EditText username = (EditText) view.findViewById(R.id.et_username);final EditText password = (EditText) view.findViewById(R.id.et_password);builder.setPositiveButton(&quot;确定&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub String name = username.getText().toString().trim(); String pwd = password.getText().toString().trim(); Toast.makeText(MainActivity.this, name + pwd, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setNegativeButton(&quot;取消&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub dialog.dismiss(); &#125;&#125;);builder.show(); 以上多个方法的参数列表都有用到CharSequence，但是我的例子中直接使用的String，所以在这里做一个补充说明。 CharSequence与String的区别： CharSequence与String都能用于定义字符串，但CharSequence的值是可读可写序列，而String的值是只读序列。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法学习-刷题(二)]]></title>
      <url>%2F2016%2F08%2F12%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[Counting BitsLeetCode第338题 题目描述Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array. Example:For num = 5 you should return [0,1,1,2,1,2]. Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. 思路分析列出前16个数的二进制表示以及1的个数： n(十进制表示) n(二进制表示) count[n]（1的个数） 0 0000 count[1] = 0 1 0001 count[1] = 1 2 0010 count[2] = 1 3 0011 count[3] = 2 4 0100 count[4] = 1 5 0101 count[5] = 2 = count[4] + count[1] 6 0110 count[6] = 2 = count[4] + count[2] 7 0111 count[7] = 3 = count[4] + count[3] 8 1000 count[8] = 1 9 1001 count[9] = 2 = count[8] + count[1] 10 1010 count[10] = 2 = count[8] + count[2] 11 1011 count[11] = 3 = count[8] + count[3] 12 1100 count[12] = 2 = count[8] + count[4] 13 1101 count[13] = 3 = count[8] + count[5] 14 1110 count[14] = 3 = count[8] + count[6] 15 1111 count[15] = 4 = count[8] + count[7] 16 10000 count[16] = 1 观察得： 在n&gt;3之后有如下规律： i&gt;2时，2的i次方中1的个数为1，例如，4，8，16； count[pow(2,i)] = 1； 4-8,8-16这些区间中的数的1的个数都可以拆分成两个数的1的个数的和。 count[pow(2,i) + j] = count[pow(2,i)] + count[j]，其中j在区间[1,pow(2,i)-1] leetcode AC的结果（C语言）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* countBits(int num, int* returnSize) &#123; int i,j; int m; int *p; *returnSize = ++num; p = (int *)malloc(sizeof(int)*(num)); //动态分配内存 if(num == 0) //num等于0时数组的值 &#123; p[0] = 0; &#125;else if(num == 1) //num等于1时数组的值 &#123; p[0] = 0; p[1] = 1; &#125;else if(num == 2) //num等于2时数组的值 &#123; p[0] = 0; p[1] = 1; p[2] = 1; &#125;else if(num == 3) //num等于3时数组的值 &#123; p[0] = 0; p[1] = 1; p[2] = 1; p[3] = 2; &#125;else //得到num大于4的情况下的数组的值（即1的个数） &#123; p[0] = 0; p[1] = 1; p[2] = 1; p[3] = 2; i=2; m = pow(2,i); while(m&lt;num)&#123; p[m] = 1; for(j=1;j&lt;m;j++) &#123; if(m+j&gt;=num) return p; p[m+j] = p[m] + p[j]; &#125; i++; m = pow(2,i); &#125; &#125; return p;&#125; AC之后去看了关于这道题的讨论，其实，自己把问题想的太复杂了，感觉还是智商不够用啊，看看别人的代码，长长见识： 解法一： 从1开始，遇到偶数时，其1的个数和该偶数除以2得到的数字的1的个数相同，遇到奇数时，其1的个数等于该奇数除以2得到的数字的1的个数再加1。 解法一C语言实现注：这是可直接运行的代码，并没有按leetcode的格式提交。123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int i,n; int *p; scanf(&quot;%d&quot;,&amp;n); p = (int *)malloc(sizeof(int)*(++n)); //动态分配内存 if(n == 1) p[0] = 0; else &#123; p[0] = 0; for(i=1;i&lt;n;i++) //得到1的个数 &#123; if(i%2 == 0) p[i] = p[i/2]; else p[i] = p[i/2] + 1; &#125; &#125; for(i=0;i&lt;n;i++) printf(&quot;%d &quot;,p[i]); printf(&quot;\n&quot;); return 0;&#125; 解法二： 利用此规律：每个i中1的个数都是i&amp;(i-1)中1的个数的值加1 解法二C语言实现注：这是可直接运行的代码，并没有按leetcode的格式提交。 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int i,n; int *p; scanf(&quot;%d&quot;,&amp;n); p = (int *)malloc(sizeof(int)*(++n)); //动态分配内存 if(n == 1) p[0] = 0; else &#123; p[0] = 0; for(i=1;i&lt;n;i++) p[i] = p[i&amp;(i-1)] + 1; //得到1的个数 &#125; for(i=0;i&lt;n;i++) printf(&quot;%d &quot;,p[i]); //输出数组 printf(&quot;\n&quot;); return 0;&#125; 奇偶校验华科2010年研究生复试机试题 题目描述输入一个字符串，然后对每个字符进行奇校验，最后输出校验后的二进制数(如’3’，输出：10110011)。 输入：输入包括一个字符串，字符串长度不超过100。 输出：可能有多组测试数据，对于每组数据，对于字符串中的每一个字符，输出按题目进行奇偶校验后的数，每个字符校验的结果占一行。 样例输入： 3 3a 样例输出： 10110011 10110011 01100001 思路分析先判断该字符的ASCLL码对应的二进制表示中1的个数是奇数还是偶数，如果是奇数则将该字符的ASCLL码对应的二进制表示的各个位直接输出，如果是偶数则先将最高位或上1，使其中1的个数为奇数个，再将该字符的ASCLL码对应的二进制表示的各个位输出。 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int oddCheck(char c) //判断二进制表示中1的个数为奇数个还是偶数个&#123; int count,i; for(i=0;i&lt;7;i++) &#123; if(c&amp;(1&lt;&lt;i)) count++; //计数 &#125; if((count%2) == 0) return 1; else return 0; &#125;int main()&#123; int len,i,j; char a[100]; scanf(&quot;%s&quot;,a); printf(&quot;%d\n&quot;,a[0]); len = strlen(a); for(i=0;i&lt;len;i++) &#123; if(oddCheck(a[i])) a[i] = a[i] | (1&lt;&lt;7); //如果1的个数为偶数个，则将最高位置为1 for(j=7;j&gt;=0;j--) &#123; if(a[i]&amp;(1&lt;&lt;j)) //按顺序输出各个位 printf(&quot;1&quot;); else printf(&quot;0&quot;); &#125; printf(&quot;\n&quot;); &#125; return 0; &#125; 比较奇偶数个数北邮2010年研究生复试机试题 题目描述第一行输入一个数，为n，第二行输入n个数，这n个数中，如果偶数比奇数多，输出NO，否则输出YES。 输入：输入有多组数据。每组输入n，然后输入n个整数（1&lt;=n&lt;=1000）。 输出：如果偶数比奇数多，输出NO，否则输出YES。 样例输入： 5 1 5 2 4 3 样例输出： YES 思路分析通过对2取余来判断这个数是奇数还是偶数，并进行计数，最后比较奇偶计数的大小得到结果进行输出。 C语言实现1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int even,odd,n,i; int *p; while(scanf(&quot;%d\n&quot;,&amp;n) != EOF) &#123; p = (int *)malloc(sizeof(int)*n); for(i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;p[i]); if(p[i]%2 == 0) even++; //偶数计数 else odd++; //奇数计数 &#125; if(even &gt; odd) printf(&quot;NO\n&quot;); else printf(&quot;YES\n&quot;); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法学习-刷题(一)]]></title>
      <url>%2F2016%2F08%2F10%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%B8%80%2F</url>
      <content type="text"><![CDATA[在知乎上看到别人分享算法学习之路，确实有很多的经验值得借鉴，其中LeetCode在线判题平台汇集了很多名企的笔试面试算法题，还有牛客网等网站都有不错的算法习题资源，所以打算要坚持刷一刷题。 因为不是纯粹为了刷题而刷题，而是为了学习和练习算法，需要总结，所以就把刷过的题都写进了博客，同时也算是将自己做题的一些过程进行分享。 Sum of Two IntegersLeetCode第371题 题目描述Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example: Given a = 1 and b = 2, return 3. 思路分析12345678910111213141516171819202122232425262728293031323334题目要求不能使用加减号，于是想到使用按位操作来进行解题。先将十进制数转换成二进制数观察规律，综合考虑如下情况：1、没有进位的情况10 + 5 = 15 即二进制的：1111使用异或运算可得到此结果：a = 10; b = 5;转换成二进制为：a = 1010 b = 0101a^b = 11112、有进位的情况20 + 25 = 45 即二进制的：101101使用异或运算:a = 10100 b = 11001 a^b = 01101 此结果没有进位要想得到结果，需将a^b的结果与a&amp;b然后左移一位的结果进行异或a&amp;b = 10000 a^b = 01101(a^b)^((a&amp;b)&lt;&lt;1) 即01101^100000 = 101101综合考虑，每次都需判断a&amp;b是否为0，如果不为0则需要将a^b的结果与a&amp;b然后左移一位的结果进行异或，直到a&amp;b的结果为0，即不再有进位时，才输出结果。例如：a = 10 b =10 a+b = 14 即二进制的：11000第一次：a=1010 b=1110 a&amp;b = 1010 不为0a^b = 0100第二次：a = 1010&lt;&lt;1 b = 0100a&amp;b = 00100 不为0a^b = 10000第三次：a = 001000 b = 10000a&amp;b = 00000a^b = 11000 即24 C语言实现12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int getSum(int a,int b)&#123; int carry,result; carry = a&amp;b; result = a^b; if(carry) &#123; return getSum(carry&lt;&lt;1,result); &#125;else &#123; return result; &#125; return 0;&#125;int main()&#123; int a,b,m; while(scanf(&quot;%d %d&quot;,&amp;a,&amp;b) != EOF) &#123; m = getSum(a,b); printf(&quot;%d\n&quot;,m); &#125; return 0;&#125; 二进制数北邮2012年研究生复试机试题 题目描述大家都知道，数据在计算机里中存储是以二进制的形式存储的。有一天，小明学了C语言之后，他想知道一个类型为unsigned int 类型的数字，存储在计算机中的二进制串是什么样子的。你能帮帮小明吗？并且，小明不想要二进制串中前面的没有意义的0串，即要去掉前导0。 输入： 第一行，一个数字T（T&lt;=1000），表示下面要求的数字的个数。接下来有T行，每行有一个数字n（0&lt;=n&lt;=10^8），表示要求的二进制串。 输出： 输出共T行。每行输出求得的二进制串。 样例输入： 5 23 535 2624 56275 989835 样例输出： 10111 1000010111 101001000000 1101101111010011 11110001101010001011 思路分析12345678910十进制数转二进制，很快就应该想到使用除二取余来解决问题，举个例子来分析一下：11/2 = 5 ---15/2 = 2 ---12/2 = 1 ---01/2 = 0 ---1结果为：1011，分析结果可知，先得到的余数在结果字符串的后面，即先得到的位后输出，后得到的位先输出，这不就是栈的后进先出特点吗？因此，我们使用除二取余的办法将得到的各个余数压入栈中，待除二的结果为0时，再将栈中的各位弹出，即可得到二进制串。 C语言实现：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; typedef struct&#123; int top; int data[100];&#125;stack;void convert_to_binary(stack *s, unsigned long int d)&#123; s-&gt;top = 0; while (d) &#123; s-&gt;data[s-&gt;top ++] = d % 2; d /= 2; &#125; while (s-&gt;top) &#123; printf(&quot;%d&quot;, s-&gt;data[-- s-&gt;top]); &#125; printf(&quot;\n&quot;);&#125; int main()&#123; int i, n; unsigned long int d; stack *s = (stack *)malloc(sizeof(stack)); while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; for (i = 0; i &lt; n; i ++) &#123; scanf(&quot;%ld&quot;, &amp;m); if (m != 0) &#123; convert_to_binary(s, m); &#125;else &#123; printf(&quot;0\n&quot;); &#125; &#125; &#125; return 0;&#125; 字符串连接华科2010年研究生复试机试题 题目描述不借用任何字符串库函数实现无冗余地接受两个字符串，然后把它们无冗余的连接起来。 输入：每一行包括两个字符串，长度不超过100。 输出：可能有多组测试数据，对于每组数据，不借用任何字符串库函数实现无冗余地接受两个字符串，然后把它们无冗余的连接起来。输出连接后的字符串。 样例输入： abc def 样例输出： abcdef 思路分析方案一： 开辟三个字符数组，使用循环遍历数组并将第二个数组的字符复制给第一个数组，再复制第三个数组到第一个数组。 方案一C语言实现123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void contact(char *str, char *str1, char *str2)&#123; int i,j; for(i=0;str1[i]!=&apos;\0&apos;;i++) &#123; str[i]=str1[i]; &#125; for(j=0;str2[j]!=&apos;\0&apos;;j++) &#123; str[i+j]=str2[j]; &#125; str[i+j]=&apos;\0&apos;;&#125;int main()&#123; char str[202],str1[101],str2[101]; while(scanf(&quot;%s%s&quot;,str1,str2) != EOF) &#123; contact(str, str1, str2); printf(&quot;%s\n&quot;,str); &#125; return 0;&#125; 方案二： 其实呢，这个题是可以取巧的，有没有发现输入是在一行，我们只要把这一行输入直接看成一个字符串，然后把除空格之外的其他字符全部输出不就好了？ 方案二C语言实现12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; char a[202]; int i; while(gets(a)!=&apos;\0&apos;) &#123; i=0; while(a[i]!=&apos;\0&apos;) &#123; if(a[i]!=&apos; &apos;) printf(&quot;%c&quot;,a[i]); i++; &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; 另外的思考： 搜这个题目的时候，看到别人提出的问题，确实有些道理啊。由于题目中并没有对”无冗余“的含义做出解释，我们可以把它理解为不占用多余的内存空间来存储输入的字符串。方案一直接定义字符数组，无法实现无冗余，因为数组大小已经固定，但是不一定有那么多字符，因此会造成空间的浪费。就想到用动态内存分配函数malloc和realloc来实现”无冗余“。 malloc：向系统申请分配指定size个字节的内存空间。返回类型是 void* 类型。 realloc：对malloc申请的内存进行大小的调整. 然后，由于上面已经发现了这个题的一个取巧的办法，所以这里将题目格式稍作更改，算是一个改编吧。 样例输入： abc def 样例输出： abcdef C语言实现1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int getString(char *str)&#123; int len = 1; char m; while((m = getchar()) != &apos;\n&apos;) &#123; str = (char *)realloc(str,sizeof(char)*len); *(str+len-1) = m; len++; &#125; str = (char *)realloc(str,sizeof(char)*len); *(str+len-1) = &apos;\0&apos;; return len;&#125;int main()&#123; int len1,len2,k; char m,n; char *str1 = (char *)malloc(sizeof(char)); char *str2 = (char *)malloc(sizeof(char)); len1 = getString(str1); len2 = getString(str2); str1 = (char *)realloc(str1,sizeof(char)*(len1+len2-1)); for(k=0;k&lt;len2;k++) &#123; *(str1+len1+k-1) = *(str2+k); &#125; printf(&quot;%s\n&quot;,str1); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Activity生命周期与启动模式]]></title>
      <url>%2F2016%2F08%2F09%2FAndroid-Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[Android 程序的生命周期是由系统控制而非程序自身直接控制，因此了解和管理Activity的生命周期对于Android应用程序开发来说都是十分重要的。本文通过实例演示了Activity的生命周期，并对Android的任务栈设计以及Activity的启动模式进行了介绍。 Activity生命周期官方文档对Activity的生命周期进行了详细的描述，其中，示意图如下： 在Activity的生命周期里会调用以下方法，具体的描述如下表： 方法 描述 onCreat() 当activity启动时调用 onStart() 当activity对用户来说可见时调用 onResume() 当activity将要开始与用户进行交互时调用 onPause() 当系统将要开始恢复以前的activity时调用。 onStop() 当activity不再对用户可见时调用，因为另一个活动已恢复，并覆盖了这一个。 onRestart() 当一个activity被停止后，被重新启动时调用 onDestroy() 当activity被销毁时调用 我们通过重写以上7个方法来观察各个方法的执行情况： MianActivity.java:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MainActivity extends Activity &#123; private Button mButton; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); System.out.println(&quot;MainActivity: onCreate()&quot;); mButton = (Button) findViewById(R.id.btn_to_another); mButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub Intent intent = new Intent(MainActivity.this,AnotherActivity.class); startActivity(intent); &#125; &#125;); &#125; @Override protected void onStart() &#123; // TODO Auto-generated method stub super.onStart(); System.out.println(&quot;MainActivity: onStart()&quot;); &#125; @Override protected void onResume() &#123; // TODO Auto-generated method stub super.onResume(); System.out.println(&quot;MainActivity: onResume()&quot;); &#125; @Override protected void onPause() &#123; // TODO Auto-generated method stub super.onPause(); System.out.println(&quot;MainActivity: onPause()&quot;); &#125; @Override protected void onRestart() &#123; // TODO Auto-generated method stub super.onRestart(); System.out.println(&quot;MainActivity: onRestart()&quot;); &#125; @Override protected void onStop() &#123; // TODO Auto-generated method stub super.onStop(); System.out.println(&quot;MainActivity: onStop()&quot;); &#125; @Override protected void onDestroy() &#123; // TODO Auto-generated method stub super.onDestroy(); System.out.println(&quot;MainActivity: onDestroy()&quot;); &#125; &#125; AnotherActivity的代码与MainActivity的代码基本相同，在这里就不再贴代码了。 以下是运行程序之后各个情况下的控制台输出： App启动时123MainActivity: onCreat()MainActivity: onStart()MainActivity: onResume() 锁屏或者按下Home键时12MainActivity: onPause()MainActivity: onStop() 解锁或者返回到App时123MainActivity: onRestart()MainActivity: onStart()MainActivity: onResume() 按下Back键时123MainActivity: onPause()MainActivity: onStop()MainActivity: onDestroy() 按下跳转到AnotherActivity按钮时12345MainActivity: onPause()AnotherActivity: onCreat()AnotherActivity: onStart()AnotherActivity: onResume()MainActivity: onStop() 按下跳转到MainActivity按钮时12345AnotherActivity: onPause()MainActivity: onCreat()MainActivity: onStart()MainActivity: onResume()AnotherActivity: onStop() 可以看到，我们在跳转到AnotherActivity时MainActivity并没有被Destroy掉，但是我们按下跳转到MainActivity的按钮时执行了onCeate()方法，即重新创建了一个MainActivity实例，这是为什么呢？其实，这就和Activity的启动模式有关了，请看下文Activity的启动模式。 再按下Back键时123456MainActivity: onPause()AnotherActivity: onRestart()AnotherActivity: onStart()AnotherActivity: onResume()MainActivity: onStop()MainActivity: onDestroy() 注意看，我们在不同的Activity之间切换时，都是先执行的本Activity的onPause()方法，待新的Activity创建启动并显示出来之后，才执行本Activity的onStop()方法，这样的生命周期设计是有他的道理的，首先防止同时显示两个Activity，然后防止另一个Activity启动失败，导致出现黑屏的情况。 Activity四种启动模式Android采用Task来管理多个Activity，任务栈(task stack)，又称为后退栈(back stack)，记录存放用户开启的activity的。在Android操作系统里面会存在多个任务栈，应用程序一被开启系统就给他分配一个任务栈，当所有的Activity都退出的时候，任务栈就清空了，置于栈顶的Activity就是用户看到的Activity。 standard模式默认模式，可以不用写配置。在这个模式下，每次激活Activity都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。 singleTop模式可以有多个实例，但是不允许多个相同Activity叠加。分为两种情况： （1）如果Activity在栈顶的时候，启动相同的Activity，不会创建新的实例，而会调用其onNewIntent方法。 （2）如果Activity不在栈顶的时候，启动Activity时会创建新的实例。 singleTask模式只有一个实例。分为三种情况： （1）如果启动的目标Activity不存在Task栈中,系统将会创建一个目标Activity实例,并将它加入到Task栈顶。 （2）如果启动的目标Activity已存在Task栈顶,此时模式和singleTop模式相同。 （3）若果启动的目标Activity已存在但没有位于Task栈顶,系统将会把该目标Activity上面的所有Activity移除Task栈,使该Activity置于Task栈顶。 singleInstance模式只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。 此启动模式和我们使用的浏览器工作原理类似，我们都知道在多个程序中访问浏览器时，如果当前浏览器没有打开，则打开浏览器，否则会在当前打开的浏览器中访问。此模式会节省大量的系统资源，因为他能保证要请求的Activity对象在当前的栈中只存在一个。 配置启动模式Android Activity的启动方式可以在AndroidManifest.xml文件的activity标签中的android:launchMode属性进行配置： 1234&lt;activity android:name=&quot;com.example.activitydemo.MainActivity&quot; android:label=&quot;@string/app_name&quot; android:launchMode=&quot;standard&quot;&gt;&lt;/activity&gt; 有兴趣的话也可以自己写一个小的Demo来对这四种启动模式进行测试，通过创建几个Activity以及切换按钮，然后在各个Activity的onCreat()方法中写入下面的语句来打印activity实例的标识信息： 1System.out.println(toString()); 通过控制台打印的内容我们可以区分Activity启动时是否创建了新的实例。 通过了解Android Activity的启动模式，我们就可以回答上文中Activity生命周期中留下的问题啦，因为Activity默认配置上启动模式是：standard，因此我们每次启动Activity都会创建新的实例。为Activity选择合适的启动模式可以节省更多的资源，这对于应用程序开发很重要。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android自带TTS与科大讯飞语音SDK]]></title>
      <url>%2F2016%2F08%2F08%2FAndroid%E8%87%AA%E5%B8%A6TTS%E4%B8%8E%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E8%AF%AD%E9%9F%B3SDK%2F</url>
      <content type="text"><![CDATA[Text-To-Speach简称TTS，指能够将指定的文本转换成不同的语言音频输出的技术。通过TTS技术我们可以为我们的应用添加语音提醒功能，也可以做具备朗读功能的电子词典或者电子书阅读器等，总之，语音合成、语音识别等技术的应用范围还是很广的。本博客主要介绍Android自带的TTS库以及科大讯飞语音SDK的使用。 Android TTS技术Android的TTS可以将文本随意的转换成以下任意五种语言（English、French、German、Italian和Spanish）的语音输出。很可惜，没有中文的，但是也不用担心，后面我们会介绍其他的办法。 先来使用Android系统自带的TTS库，实现起来很简单，示例如下： 1234567891011121314151617181920212223242526272829@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mButton = (Button) findViewById(R.id.btn_speak); // 创建TTS对象 mSpeech = new TextToSpeech(MainActivity.this, new OnInitListener() &#123; @Override public void onInit(int status) &#123; // TODO Auto-generated method stub if (status == TextToSpeech.SUCCESS) &#123; mSpeech.setLanguage(Locale.ENGLISH); //设置语言为英语 &#125; &#125; &#125;); //点击按钮说话 mButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub mSpeech.speak(&quot;Hello World!&quot;, TextToSpeech.QUEUE_FLUSH, null); &#125; &#125;);&#125; 运行程序化后点击按钮你就会听到Hello World！，除此之外还可以设置语速、语调等参数，具体的可以参考官方文档：http://www.android-doc.com/reference/android/speech/tts/package-summary.html 科大讯飞语音SDKAndroid自带的TTS是不支持中文的，但是国内也有很强大的公司在做语音识别，比如众所周知的科大迅飞，它提供了免费的SDK，很多App也都集成了科大讯飞的语音引擎，这里我们也来简单使用一下。 下载科大讯飞Android开发SDK官方地址：http://www.xfyun.cn/ 添加jar包将开发工具包中libs目录下的Msc.jar和armeabi复制到Android工程的libs目录 具体配置步骤可查看开发工具包中doc文件夹下的MSC Develop Manual for Android.pdf文件，里面有详细的介绍。 （1）在工程 AndroidManifest.xml 文件中添加如下权限 文档中还添加了很多其他权限，本博客只介绍了SDK中语音合成功能的使用，如果你需要用到其他的功能那那些权限也是必须要添加的。 123456789101112&lt;!-- 连接网络权限，用于执行云端语音能力 --&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;!-- 读取网络信息状态 --&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;!-- 获取当前wifi状态 --&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;!-- 允许程序改变网络连接状态 --&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;&lt;!-- 外存储读权限，构建语法需要用到此权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;!-- 外存储写权限，构建语法需要用到此权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; （2）初始化SDK 1SpeechUtility.createUtility(context, SpeechConstant.APPID + &quot;=你申请的APPID&quot;); （3）语音合成基本配置（摘抄自官方文档） 语音合成是将文字信息转化为可听的声音信息，让机器像人一样开口说话。 123456789101112131415161718192021222324252627282930313233//1.创建 SpeechSynthesizer 对象, 第二个参数：本地合成时传 InitListenerSpeechSynthesizer mTts= SpeechSynthesizer.createSynthesizer(context, null);//2.合成参数设置mTts.setParameter(SpeechConstant.VOICE_NAME, &quot;xiaoyan&quot;); //设置发音人mTts.setParameter(SpeechConstant.SPEED, &quot;50&quot;);//设置语速mTts.setParameter(SpeechConstant.VOLUME, &quot;80&quot;);//设置音量，范围 0~100mTts.setParameter(SpeechConstant.ENGINE_TYPE, SpeechConstant.TYPE_CLOUD); //设置合成音频保存位置（可自定义保存位置） ，保存在“./sdcard/iflytek.pcm”mTts.setParameter(SpeechConstant.TTS_AUDIO_PATH, &quot;./sdcard/iflytek.pcm&quot;);//3.开始合成mTts.startSpeaking(&quot;科大讯飞，让世界聆听我们的声音&quot;, mSynListener);//合成监听器private SynthesizerListener mSynListener = new SynthesizerListener()&#123; //会话结束回调接口，没有错误时，error为null public void onCompleted(SpeechError error) &#123;&#125; //缓冲进度回调 //percent为缓冲进度0~100，beginPos为缓冲音频在文本中开始位置，endPos表示缓冲音频在 文本中结束位置，info为附加信息。 public void onBufferProgress(int percent, int beginPos, int endPos, String info) &#123;&#125; //开始播放 public void onSpeakBegin() &#123;&#125; //暂停播放 public void onSpeakPaused() &#123;&#125; //播放进度回调 //percent为播放进度0~100,beginPos为播放音频在文本中开始位置，endPos表示播放音频在文 本中结束位置. public void onSpeakProgress(int percent, int beginPos, int endPos) &#123;&#125; //恢复播放回调接口 public void onSpeakResumed() &#123;&#125; //会话事件回调接口 public void onEvent(int arg0, int arg1, int arg2, Bundle arg3) &#123;&#125;&#125;; 简单的Demo博主使用科大讯飞SDK的语音合成功能制作了一个简单的Demo，它可以选择不同的发音人来发音，并且可以调节语速和音量。 以下是MainActivity.java的部分代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化SDK SpeechUtility.createUtility(this, SpeechConstant.APPID + &quot;=571771fd&quot;); mEditText = (EditText) findViewById(R.id.et_speak); mButton = (Button) findViewById(R.id.btn_speak); mSeekBarVolume = (SeekBar) findViewById(R.id.sb_speak_volume); mSeekBarSpeed = (SeekBar) findViewById(R.id.sb_speak_speed); mSpinner = (Spinner) findViewById(R.id.spinner); // 创建 SpeechSynthesizer 对象, 第二个参数：本地合成时传 InitListener mTts = SpeechSynthesizer.createSynthesizer(this, null); // 合成参数设置 mTts.setParameter(SpeechConstant.VOICE_NAME, &quot;xiaoyan&quot;); // 设置发音人 mTts.setParameter(SpeechConstant.SPEED, &quot;50&quot;);// 设置语速 mTts.setParameter(SpeechConstant.VOLUME, &quot;80&quot;);// 设置音量，范围 0~100 mTts.setParameter(SpeechConstant.ENGINE_TYPE, SpeechConstant.TYPE_CLOUD); // 设置云端 // 设置合成音频保存位置（可自定义保存位置） ，保存在“./sdcard/iflytek.pcm” mTts.setParameter(SpeechConstant.TTS_AUDIO_PATH, &quot;./sdcard/iflytek.wav&quot;); mSeekBarSpeed.setProgress(50); mSeekBarVolume.setProgress(80); mSpinner.setOnItemSelectedListener(new OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; arg0, View arg1,int position, long arg3) &#123; // TODO Auto-generated method stub // 设置发音人 mTts.setParameter(SpeechConstant.VOICE_NAME, str[position]); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; arg0) &#123; // TODO Auto-generated method stub &#125; &#125;); mSeekBarSpeed.setOnSeekBarChangeListener(new OnSeekBarChangeListener() &#123; @Override public void onStopTrackingTouch(SeekBar seekbar) &#123; // TODO Auto-generated method stub // 设置语速 mTts.setParameter(SpeechConstant.SPEED, seekbar.getProgress()+ &quot;&quot;); &#125; @Override public void onStartTrackingTouch(SeekBar arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void onProgressChanged(SeekBar arg0, int arg1, boolean arg2) &#123; // TODO Auto-generated method stub &#125; &#125;); mSeekBarVolume.setOnSeekBarChangeListener(new OnSeekBarChangeListener() &#123; @Override public void onStopTrackingTouch(SeekBar seekbar) &#123; // TODO Auto-generated method stub // 设置音量，范围 0~100 mTts.setParameter(SpeechConstant.VOLUME,seekbar.getProgress() + &quot;&quot;); &#125; @Override public void onStartTrackingTouch(SeekBar arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void onProgressChanged(SeekBar arg0, int arg1, boolean arg2) &#123; // TODO Auto-generated method stub &#125; &#125;); mButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View arg0) &#123; // TODO Auto-generated method stub String text = mEditText.getText().toString(); // 开始合成 mTts.startSpeaking(text, mSynListener); &#125; &#125;);&#125; 至此，我们就可以为我们的应用添加语音合成功能啦，是不是很方便？其实，除此之外，科大讯飞的SDK还具备语音识别、声纹密码、人脸识别等多种功能，具体的操作方法请参考下载的SDK工具包中的中文文档资料。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python Http网络请求]]></title>
      <url>%2F2016%2F08%2F07%2FPython-Http%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
      <content type="text"><![CDATA[Python网络爬虫开发离不开Http网络请求，此前的几篇Python网络爬虫博客中，对网络爬虫已经有了一些基本的介绍，也使用了一些网络请求库，但是没有对Python网络请求做详细的说明，此篇博客将对Python的Http网络请求进行一个总结，通过列举不同的Http请求库的不同请求写法来熟悉Python的网络请求，从而有利于后续的网络爬虫开发。 注：博主的Python环境为Python2.7.5，使用Python3的读者要注意个别的类库与Python2有很大区别。 urllib与urllib2模块urllib与urllib2比较urllib与urllib2是python自带的库，不需要额外导入，但是很多人可能会比较困惑这两个库有什么区别呢？很多人认为urllib2是urllib的升级版，我之前也是这么认为的，但是这是不对的。 urllib 和urllib2都是接受URL请求的相关模块，但是他们是不可相互替代的，因为提供了不同的功能。整体来说，urllib2是urllib的增强，但是urllib中有urllib2中所没有的函数。他们两个最显著的不同如下： urllib2可以接受一个Request类的实例来设置URL请求的Headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。如果你访问一个网站，想更改User Agent（可以伪装你的浏览器），你就要用urllib2。 urllib支持设置编码的函数，urllib.urlencode，在模拟登陆的时候，经常要post编码之后的参数，所以要想不使用第三方库完成模拟登录，你就需要使用urllib。也正因为如此，urllib常和urllib2一起使用。 urllib模块urlopen()函数的使用urlopen(url, data=None, proxies=None) 参数url：表示远程数据的路径，一般是http或者ftp路径。 可选参数data：表示以post方式提交到url的数据。 可选参数proxies：表示用于代理的设置。 urlopen返回一个类文件对象，它提供了如下方法： read() , readline() , readlines()，fileno()和close()：这些函数的使用与文件对象完全一样。 info()：返回一个httplib.HTTPMessage 对象，表示远程服务器返回的头信息。 getcode()：返回Http状态码，如果是http请求，200表示请求成功完成;404表示网址未找到。 geturl()：返回请求的url地址。 简单GET请求此处代码中的GET请求都是对博主博客的一个404页面发送的请求，会返回服务器响应信息以及网页源代码。 123456789# -*- coding:utf-8 -*-import urllibres = urllib.urlopen(&quot;http://blog.line-coding.tech/&quot;)print res.info()print res.getcode()print res.geturl()print res.read() 123456789101112131415运行结果如下：Date: Sat, 06 Aug 2016 13:48:53 GMTServer: Apache/2.4.6 (CentOS) mod_wsgi/4.5.3 Python/2.7.5 PHP/5.4.16Last-Modified: Thu, 14 Jul 2016 06:29:45 GMTETag: &quot;4f3-53792a0bfd6ca&quot;Accept-Ranges: bytesContent-Length: 1267Connection: closeContent-Type: text/html; charset=UTF-8200http://blog.line-coding.tech/篇幅有限，此处省略了请求页面的html文档。 简单POST请求此处代码的POST请求都是对博主服务器上的一个用户注册API接口发送的请求，其中请求参数包括用户名和密码，如果服务器中的数据库已经存在此账号则会返回一个exist，如果注册成功则会返回一个success，请求错误则返回一个go away。 123456789# -*- coding:utf-8 -*-import urlliburl = &apos;http://data.line-coding.tech/register.php&apos;data = &#123;&apos;username&apos;:&apos;13654852343&apos;,&apos;password&apos;:&apos;123456&apos;&#125;res = urllib.urlopen(url, data = urllib.urlencode(data))print res.info()print res.getcode()print res.geturl()print res.read() 123运行结果如下：篇幅有限，此处只写出服务器返回的内容exist urllib2模块urllib2用一个Request对象来映射你提出的HTTP请求,在它最简单的使用形式中你将用你要请求的地址创建一个Request对象，通过调用urlopen并传入Request对象，将返回一个相关请求response对象，这个应答对象如同一个文件对象，所以你同样可以像在使用urllib模块时调用info()、getcode()、geturl()、read()等函数。 简单GET请求12345678# -*- coding:utf-8 -*-import urllib2res = urllib2.urlopen(&quot;http://blog.line-coding.tech/&quot;)print res.info()print res.getcode()print res.geturl()print res.read() 1运行结果同urllib的GET方法 说明： 下文中使用到百度APIStore中一个既可以接收GET请求又可以接收POST请求的查询学校信息的API接口，该接口的使用方法可参考 相关文档（http://apistore.baidu.com/apiworks/servicedetail/2843.html），简单说来，使用它时需要传递一个学校名字的参数，以及添加自己的百度API Store的API-key。由于它既可以接收GET请求又可以接收POST请求，所以下文的示例代码中会得到很多同样的结果，但是采用GET方法时参数是连接在在url后面的，而POST方法则不是，请大家注意区分。 带Header的POST请求12345678910# -*- coding:utf-8 -*-import urllib,urllib2from urllib import urlencodeurl = &apos;http://apis.baidu.com/jidichong/school_search/school_search&apos;data = &#123;&apos;name&apos;:&apos;清华大学&apos;&#125;req = urllib2.Request(url, urlencode(data))req.add_header(&quot;apikey&quot;, &quot;c57bc70b78d5926e8cfbb3ad9c195465&quot;) #此处添加自己的百度API Stroe的APIKEYresp = urllib2.urlopen(req)print resp.read() 12运行结果如下：&#123;&quot;status&quot;:1,&quot;msg&quot;:&quot;请求成功&quot;,&quot;result&quot;:&#123;&quot;npage&quot;:1,&quot;pageSize&quot;:10,&quot;total&quot;:1,&quot;data&quot;:[&#123;&quot;phone&quot;:&quot;010-62770334;010-62782051&quot;,&quot;website&quot;:&quot;www.tsinghua.edu.cn&quot;,&quot;email&quot;:&quot;zsb@mail.tsinghua.edu.cn&quot;,&quot;address&quot;:&quot;北京市海淀区清华大学&quot;,&quot;zipcode&quot;:&quot;&quot;,&quot;name&quot;:&quot;清华大学&quot;,&quot;img&quot;:&quot;http://img.jidichong.com/school/3.png&quot;,&quot;parent&quot;:&quot;教育部&quot;,&quot;type&quot;:&quot; 211 985&quot;,&quot;profile&quot;:&quot;&quot;,&quot;info&quot;:&quot;院士：68人 博士点：198个 硕士点：181个&quot;,&quot;city&quot;:&quot;北京&quot;&#125;]&#125;&#125; httplib2模块安装httplib2模块httplib2是一个全面的HTTP客户端库，它也是一个第三方开源库，所以需要自行安装。 1pip install httplib2 带参数和Header的GET请求12345678# -*- coding:utf-8 -*-import httplib2 h = httplib2.Http() url = &apos;http://apis.baidu.com/jidichong/school_search/school_search/?name=清华大学&apos; #带请求参数的urlheaders = &#123;&apos;apikey&apos;: &apos;c57bc70b78d5926e8cfbb3ad9c195465&apos;&#125;resp, content = h.request (url,&apos;GET&apos;, None , headers) #使用GET方法时，这里的Body参数必须写成None# print respprint content httplib2 Http对象的request()方法返回两个值： 第一个是httplib2.Response对象，其中包含了服务器返回的所有http头。比如, status为200 表示请求成功。 第二个返回值包含了http服务器返回的实际数据。数据以bytes对象返回，不是字符串。 如果你需要一个字符串，你需要确定字符编码并自己进行转换 12程序运行结果：&#123;&quot;status&quot;:1,&quot;msg&quot;:&quot;请求成功&quot;,&quot;result&quot;:&#123;&quot;npage&quot;:1,&quot;pageSize&quot;:10,&quot;total&quot;:1,&quot;data&quot;:[&#123;&quot;phone&quot;:&quot;010-62770334;010-62782051&quot;,&quot;website&quot;:&quot;www.tsinghua.edu.cn&quot;,&quot;email&quot;:&quot;zsb@mail.tsinghua.edu.cn&quot;,&quot;address&quot;:&quot;北京市海淀区清华大学&quot;,&quot;zipcode&quot;:&quot;&quot;,&quot;name&quot;:&quot;清华大学&quot;,&quot;img&quot;:&quot;http://img.jidichong.com/school/3.png&quot;,&quot;parent&quot;:&quot;教育部&quot;,&quot;type&quot;:&quot; 211 985&quot;,&quot;profile&quot;:&quot;&quot;,&quot;info&quot;:&quot;院士：68人 博士点：198个 硕士点：181个&quot;,&quot;city&quot;:&quot;北京&quot;&#125;]&#125;&#125; 带参数和Header的POST请求1234567891011# -*- coding:utf-8 -*-import httplib2 from urllib import urlencodeh = httplib2.Http() url = &apos;http://apis.baidu.com/jidichong/school_search/school_search&apos;data = &#123;&apos;name&apos;:&apos;清华大学&apos;&#125; headers = &#123;&apos;apikey&apos;: &apos;c57bc70b78d5926e8cfbb3ad9c195465&apos;,&apos;Content-type&apos;: &apos;application/x-www-form-urlencoded&apos;&#125;# 必须带上headers参数，否则POST不成功resp, content = h.request(url,&apos;POST&apos;,urlencode(data),headers) # print resp print content 1程序运行结果同上GET方法 requests模块requests是第三方库，它使用的是urllib3，继承了urllib2的所有特性。Requests支持HTTP连接保持和连接池，支持使用cookie保持会话，支持文件上传，支持自动确定响应内容的编码，支持国际化的URL和POST数据自动编码。同时，它支持Http协议的GET、POST、PUT、DELETE等多种请求方式。 安装1pip install requests 简单GET请求12345678910# -*- coding:utf-8 -*-import requestsimport sys reload(sys) sys.setdefaultencoding(&apos;utf8&apos;) #设置文件的编码方式req = requests.get(url=&apos;http://blog.line-coding.tech&apos;) print req.urlprint req.status_code print req.text 1234程序运行结果：http://blog.line-coding.tech/200篇幅有限，此处省去网页源代码 带参数和Header的GET请求如果你想为请求添加HTTP头部，只要简单地传递一个dict给headers参数就可以了。 1234567891011# -*- coding:utf-8 -*-import requestsimport sys reload(sys) sys.setdefaultencoding(&apos;utf8&apos;) #设置文件的编码方式url = &apos;http://apis.baidu.com/jidichong/school_search/school_search&apos;headers = &#123;&apos;apikey&apos;:&apos;c57bc70b78d5926e8cfbb3ad9c195465&apos;&#125;params = &#123;&apos;name&apos;:&apos;清华大学&apos;&#125;rep = requests.get(url, params = params, headers = headers)print rep.text 12程序运行结果：&#123;&quot;status&quot;:1,&quot;msg&quot;:&quot;请求成功&quot;,&quot;result&quot;:&#123;&quot;npage&quot;:1,&quot;pageSize&quot;:10,&quot;total&quot;:1,&quot;data&quot;:[&#123;&quot;phone&quot;:&quot;010-62770334;010-62782051&quot;,&quot;website&quot;:&quot;www.tsinghua.edu.cn&quot;,&quot;email&quot;:&quot;zsb@mail.tsinghua.edu.cn&quot;,&quot;address&quot;:&quot;北京市海淀区清华大学&quot;,&quot;zipcode&quot;:&quot;&quot;,&quot;name&quot;:&quot;清华大学&quot;,&quot;img&quot;:&quot;http://img.jidichong.com/school/3.png&quot;,&quot;parent&quot;:&quot;教育部&quot;,&quot;type&quot;:&quot; 211 985&quot;,&quot;profile&quot;:&quot;&quot;,&quot;info&quot;:&quot;院士：68人 博士点：198个 硕士点：181个&quot;,&quot;city&quot;:&quot;北京&quot;&#125;]&#125;&#125; 带参数和Header的POST请求1234567891011# -*- coding:utf-8 -*-import requestsimport sys reload(sys) sys.setdefaultencoding(&apos;utf8&apos;) #设置文件的编码方式url = &apos;http://apis.baidu.com/jidichong/school_search/school_search&apos;headers = &#123;&apos;apikey&apos;:&apos;c57bc70b78d5926e8cfbb3ad9c195465&apos;&#125;data = &#123;&apos;name&apos;: &apos;清华大学&apos;&#125;r = requests.post(url , data = data, headers = headers )print r.text 12程序运行结果同上带参数和Header的GET请求，注意这是因为这个接口能够接收GET和POST两种方式的请求，如果你使用的接口有规定只使用GET方法，那还是按规定来吧，要不然请求肯定失败。 POST发送JSON数据由于没有找到合适的可以接收JSON数据的API来做这个测试，所以这里摘抄了别人的一段代码，貌似这个接口也不能用了，悲剧啊。不过，反正就是使用json.dumps将dict转换成json格式的数据之后添加到post的参数中然后再发送post请求就对了。 12345678# -*- coding:utf-8 -*-import requestsimport jsonurl = &apos;https://api.github.com/some/endpoint&apos;payload = &#123;&apos;some&apos;: &apos;data&apos;&#125;r = requests.post(url, data = json.dumps(payload))print r.text 貌似这个接口也不能用了，待博主找到一个更好的API接口再来更新吧，先写到这里了。说实话，总结了四个网络请求模块，把我自己都搞晕了，但是最后也还是弄清楚了，可能放在一起来看有点容易搞混，但是有对比才有知道自己应该用哪个啊。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Http网络请求]]></title>
      <url>%2F2016%2F08%2F05%2FAndroid-Http%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
      <content type="text"><![CDATA[Android网络编程（特别是Http请求）是Android学习中比较重要的内容，也是Android开发中比较常用的内。虽然已经有很多优秀的第三方开源框架供我们使用，也大大提升了我们的开发效率，但是也因此我们对基本Http请求的并不熟悉，我们应该重视基础，从底层去了解网络请求的实现机制。此篇博客总结了Android两种基本的网络请求方式，并通过一个简单的Demo进行实践。 Android网络编程注意事项 安卓的耗时操作（如I/O流操作）的逻辑不能写在主线程，必须写在子线程。 子线程在安卓2.3以后不能更新UI界面（更新就报错），子线程想要更新界面必须结合Handler或者AsyncTask等才可以。 Android网络操作均需添加网络访问权限： 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 说明事项以下代码中的GET请求都是对博主博客的一个404页面发送的请求，会返回该页面的html代码，POST请求都是对博主服务器上的一个用户注册API接口发送的请求，其中请求参数包括用户名和密码，如果服务器中的数据库已经存在此账号则会返回一个exist，如果注册成功则会返回一个success，否则返回一个error。 使用HttpURLConnection访问网络HttpURLConnection类位于java.net包中，用于发送HTTP请求和获取HTTP响应。该类是抽象类，不能直接实例化，要使用URL的openConnection()方法获得。 发送GET请求1234567891011121314151617181920public void get() &#123; try &#123; URL url = new URL(&quot;http://blog.line-coding.tech/&quot;); HttpURLConnection huc = (HttpURLConnection) url.openConnection(); // mUrlConnection.setRequestMethod(&quot;GET&quot;); //默认就是GET方式，此声明可不要 //获取字节流，并将字节流转换成字符流 InputStreamReader isr = new InputStreamReader(huc.getInputStream()); //缓冲字符流，以便读取 BufferedReader br = new BufferedReader(isr); String inputLine = null; //按行读取数据 while ((inputLine = br.readLine()) != null) &#123; result += inputLine + &quot;\n&quot;; &#125; isr.close(); //关闭输入流 huc.disconnect(); //关闭连接 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; GET方法在传递中文参数时，会产生乱码，要进行Base64编码来解决乱码问题。 12345678910public String base64Encode(String params) &#123; try &#123; params = Base64.encodeToString(params.getBytes(&quot;utf-8&quot;), Base64.DEFAULT); params = URLEncoder.encode(params,&quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return params;&#125; 发送POST请求12345678910111213141516171819202122232425262728293031public void post() &#123; try &#123; URL url = new URL(&quot;http://data.line-coding.tech/register.php&quot;); HttpURLConnection huc = (HttpURLConnection) url.openConnection(); huc.setRequestMethod(&quot;POST&quot;); huc.setDoInput(true); // 向连接中写入数据 huc.setDoOutput(true); // 向连接中读取数据 huc.setUseCaches(false); // 禁止缓存 huc.setInstanceFollowRedirects(true); // 自动执行Http重定向 huc.setRequestProperty(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); //设置内容类型 DataOutputStream dos = new DataOutputStream(huc.getOutputStream()); //获取输出流 String params = &quot;username=13674852343&quot; + &quot;&amp;password=123456&quot;; //添加请求参数 dos.writeBytes(params); //将数据写入到输出流 dos.flush(); //输出缓存 dos.close(); //关闭输出流 if (huc.getResponseCode() == HttpURLConnection.HTTP_OK) &#123; InputStreamReader isr = new InputStreamReader( huc.getInputStream()); BufferedReader br = new BufferedReader(isr); String inputLine = null; while ((inputLine = br.readLine()) != null) &#123; result += inputLine + &quot;\n&quot;; &#125; isr.close(); &#125; huc.disconnect(); //关闭连接 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; 使用HttpClient访问网络对于比较复杂的联网操作，使用HttpUrlConnection就不一定能够满足要求，此时，可以使用Apache组织提供的HttpClient项目来实现。HttpClient中将HttpUrlConnection类中的输入/输出流操作统一封装成HttpGet、HttpPost和HttpResponse类。其中HttpGet类代表发送GET请求、HttpPost代表发送POST请求、HttpResponse类代表处理响应的对象。 发送GET请求使用流程（1）创建HttpClient对象 （2）创建HttpGet对象 （3）如需添加参数，可以在url中添加参数，也可调用HttpGet的setParams()方法来添加请求参数。 （4）调用HttpClient对象的execute()方法发送请求。 （5）调用HttpResponse的getEntity()方法获得包含服务器响应内容的HttpEntity对象。 使用示例1234567891011121314151617181920public void getMethod() &#123; String url = &quot;http://blog.line-coding.tech/&quot;; try &#123; HttpClient client = new DefaultHttpClient(); //创建HttpClient对象 HttpGet get = new HttpGet(url); //创建HttpGet对象 HttpResponse response = client.execute(get); //执行HttpClient请求 if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; result = EntityUtils.toString(response.getEntity()); //获取返回结果 &#125; else &#123; result = &quot;请求失败&quot;; &#125; &#125; catch (ClientProtocolException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; 发送POST请求使用流程（1）创建HttpClient对象 （2）创建HttpGet对象 （3）调用HttpPost的setParams()方法来添加请求参数，也可调用setEntity()方法来设置请求参数。 （4）调用HttpClient对象的execute()方法发送请求。 （5）调用HttpResponse的getEntity()方法获得包含服务器响应内容的HttpEntity对象。 使用示例：123456789101112131415161718192021222324252627public void postMethod() &#123; String url = &quot;http://data.line-coding.tech/register.php&quot;; HttpClient client = new DefaultHttpClient(); //创建HttpClient对象 HttpPost post = new HttpPost(url); //创建HttpGet对象 List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;(); params.add(new BasicNameValuePair(&quot;username&quot;, &quot;13674852343&quot;)); params.add(new BasicNameValuePair(&quot;password&quot;, &quot;123456&quot;)); try &#123; post.setEntity(new UrlEncodedFormEntity(params,&quot;utf-8&quot;)); //添加参数 HttpResponse response = client.execute(post); //执行HttpClient请求 if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; //判断请求是否成功 result = EntityUtils.toString(response.getEntity()); //获取返回结果 &#125; else &#123; result = &quot;请求失败&quot;; &#125; &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (ClientProtocolException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;; &#125; 简单的Demo通过在MainActivity中使用子线程分别调用以上四个方法来发送Http请求，并通过Handler在子线程和主线程之间传递消息，通知主线程更新UI，以此来测试所写的方法是否可行。 1234567891011121314151617181920212223242526272829303132private TextView mTextView;private String result = &quot;&quot;;private Handler mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; if (result != null) &#123; mTextView.setText(result); //收到通知，则将Http请求的结果显示在界面上 &#125; &#125;;&#125;;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView) findViewById(R.id.tv_result); new Thread(new Runnable() &#123; //开启子线程来执行网络请求 @Override public void run() &#123; // TODO Auto-generated method stub get(); //使用HttpURLConnection的GET方法 //post(); //使用HttpURLConnection的POST方法 //getMethod(); //使用HttpClient的GET方法 //postMethod(); //使用HttpClient的POST方法 Message msg = mHandler.obtainMessage(); //获取一个Message对象 mHandler.sendMessage(msg); //通知UI进行更新 &#125; &#125;).start();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python文件操作]]></title>
      <url>%2F2016%2F08%2F03%2FPython%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[上一篇博文中我们介绍了Python使用Mysql数据库进行数据存储，数据库存储的数据需要特定的工具进行打开，而普通的数据文件是一般的电脑都能打开进行查看的，因此数据库存储的通用性没有文件存储那么好，文件存储也是Python网络爬虫的常用存储方式之一，特别是csv文件，所以我们对于文件的输入输出流操作、缓存、基本的读写方式、文件迭代器等我们都需要有一些基本的了解，并熟练掌握文件的读写操作，为我们的爬虫实战打下坚实的基础。 打开文件打开文件使用open函数，其中文件名是必选参数，文件模式和缓冲是可选参数 1open(name[,mode[,buffering]]) 参数1：文件名文件名一般采用绝对路径，其中会包含\字符，所以可在字符串前加r。 ‘r’是防止字符转义的，如果路径中出现’\t’的话，不加r的话\t就会被转义 而加了’r’之后’\t’就能保留原有的样子。例如： 123456&gt;&gt;&gt; s = &apos;C:\Python27\tcl&apos;&gt;&gt;&gt; print sC:\Python27 cl #解释器将\t识别成一个制表符的间隔&gt;&gt;&gt; s = r&apos;C:\Python27\tcl&apos;&gt;&gt;&gt; print sC:\Python27\tcl #不进行转义，正常输出 可见在字符串前加’r’才能正确使用文件路径 参数2：文件模式 值 描述 值 描述 ‘r’ 读模式 ‘a’ 追加模式 ‘w’ 写模式 ‘b’ 二进制模式 ‘+’ 读/写模式 参数3：缓冲参数是0或者False，输入输出是无缓冲的 参数是1或者True，输入输出是有缓冲的 文件读写写入数据（1）以字符串形式写入 1234567#以写模式打开py.txt文件，若文件不存在，则会创建，若存在则覆盖文件原来的内容f = open(r&apos;D:\Python\py.txt&apos;,&apos;w&apos;)#写入Python之禅的前两句f.write(&apos;Beautiful is better than ugly.\n&apos;)f.write(&apos;Explicit is better than implicit.\n&apos;) f.flush()f.close() 成功写入之后，txt文件内容为以下两行： Beautiful is better than ugly. Explicit is better than implicit. （2）写入行 writelines()将传递进来的一个字符串列表中的所有的字符串写入文件，但是不会增加新行，需要自己手动添加。 123456#采用追加模式，再向py.txt文件写入Python之禅的三四句f = open(r&apos;D:\Python\py.txt&apos;,&apos;a&apos;)content = [&apos;Simple is better than complex.\n&apos;,&apos;Complex is better than complicated.\n&apos;]f.writelines(content) f.flush()f.close() 成功写入之后，txt文件内容为以下四行： Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. 读取数据（1）以字符串形式读取1234f = open(r&apos;D:\Python\py.txt&apos;,&apos;r&apos;)print f.read(6) #读取6个字符print f.read() #读取整个文件f.close() 运行结果如下： Beauti ful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. 可以看出，f.read(6)先读出了6个字符，然后f.read()将其余的内容全部读出来了。 （2）读取行 123f = open(r&apos;D:\Python\py.txt&apos;,&apos;r&apos;)print f.readline() #读取一行数据f.close() readline()函数，读取一行，运行结果如下： Beautiful is better than ugly. 123f = open(r&apos;D:\Python\py.txt&apos;,&apos;r&apos;)print f.readlines() #读取文件的所有行f.close() readlines()函数，读取一个文件的所有行，并将其作为列表返回，运行结果如下： [&apos;Beautiful is better than ugly.\n&apos;, &apos;Explicit is better than implicit.\n&apos;, &apos;Simple is better than complex.\n&apos;, &apos;Complex is better than complicated.\n&apos;] 对文件内容进行迭代按字节处理1234567filename = r&apos;D:\Python\py.txt&apos;f = open(filename)while True: char = f.read(1) #每次读取一个字符 if not char: break #没有字符可读了则停止 print char #打印字符f.close() 按行处理1234567filename = r&apos;D:\Python\py.txt&apos;f = open(filename)while True: line = f.readline().strip() #读取一行，并去除空行 if not line: break #如果没有下一行了则停止 print line #打印读取到的一行f.close() 程序运行结果如下： Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. 使用fileinput实现懒惰行迭代1234import fileinputfilename = r&apos;D:\Python\py.txt&apos;for line in fileinput.input(filename): print line.strip() #打印读取到的行，并去除空行 程序运行结果同2 文件迭代器12345filename = r&apos;D:\Python\py.txt&apos;f = open(filename)for line in f: print line.strip() #打印读取到的行，并去除空行f.close() 程序运行结果同2 关闭文件写入过的文件总应该关闭，因为Python可能会缓存写入的数据，如果程序奔溃了，那么数据就不会被写入到文件，为了安全起见，在使用完文件后要进行关闭操作。 12345#打开文件try: #写入数据finally: file.close() csv文件处理逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。csv文件经常用于网络数据爬取的数据存储。csv文件可以用记事本和excel打开进行查看。 123456789101112131415161718192021# -*- coding: utf-8 -*-import csvcsvFile = open(&quot;D:/Python/data.csv&quot;,&apos;wb+&apos; )try: writer = csv.writer(csvFile) writer.writerow((&apos;Id&apos;,&apos;Name&apos;,&apos;Age&apos;)) #写入一行数据做列名 data = [(20160001,&apos;fzy&apos;,&apos;21&apos;),(20160002,&apos;lyj&apos;,&apos;21&apos;),(20160003,&apos;ljj&apos;,&apos;20&apos;)] writer.writerows(data) #写入多行 writer.writerow((20160004,&apos;cyx&apos;,&apos;24&apos;)) #写入一行数据finally: csvFile.close()csvFile = open(&quot;D:/Python/data.csv&quot;,&apos;rb+&apos; )try: reader = csv.reader(csvFile) for line in reader: print linefinally: csvFile.close() 程序运行结果： [&apos;Id&apos;, &apos;Name&apos;, &apos;Age&apos;] [&apos;20160001&apos;, &apos;fzy&apos;, &apos;21&apos;] [&apos;20160002&apos;, &apos;lyj&apos;, &apos;21&apos;] [&apos;20160003&apos;, &apos;ljj&apos;, &apos;20&apos;] [&apos;20160004&apos;, &apos;cyx&apos;, &apos;24&apos;]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android数据存储之文件存储]]></title>
      <url>%2F2016%2F07%2F29%2FAndroid%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8B%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%2F</url>
      <content type="text"><![CDATA[前面两篇博客分别介绍了Android的SharedPreferences数据存储和SQLite数据库存储，此篇博客介绍Android数据存储的第三种方式：文件存储，这也是我们平时最为常用的，他的很多操作与Java文件操作基本一致，只是因为Android是基于Linux操作系统，所以需要对于文件目录结构需要有更深入的理解。 Android内部存储与外部存储Android本身基于Linux操作系统，所以它的内部存储空间，对于应用程序和用户来讲就是“/data/data”目录。它与其他的（外部存储）相比有着存储方便，操作简单，更加稳定、安全等优点。但是它比较有限，比较可贵。 内部存储（internal storage）内部存储不是内存。内部存储位于系统中很特殊的一个位置，如果你想将文件存储于内部存储中，那么文件默认只能被你的应用访问到，且一个应用所创建的所有文件都在和应用包名相同的目录下。也就是说应用创建于内部存储的文件，与这个应用是关联起来的。当一个应用卸载之后，内部存储中的这些文件也被删除。 内部存储空间十分有限，因而显得可贵，另外，它也是系统本身和系统应用程序主要的数据存储所在地，一旦内部存储空间耗尽，手机也就无法使用了。所以对于内部存储空间，我们要尽量避免使用。 内部存储目录/data/data/包名/ 说明 /data/data/包名/shared_prefs sharedpreferrence文件存放目录 /data/data/包名/databases 数据库文件存放目录 /data/data/包名/files 应用程序默认的数据存储目录 /data/data/包名/cache 应用程序默认的缓存文件存放目录 外部存储（external storage）外部存储一般就是storage文件夹或者mnt文件夹，在storage文件夹中有一个sdcard文件夹，这个文件夹中的文件又分为两类，一类是公有目录，还有一类是私有目录 由于内部存储空间有限，在开发中我们一般都是操作外部存储空间，Google官方建议我们App的数据应该存储在外部存储的私有目录中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除，如果你直接在/storage/sdcard目录下创建了一个应用的文件夹，那么当你删除应用的时候，这个文件夹就不会被删除。 外部存储目录storage/sdcard，它又分为公有目录和私有目录，其中的公有目录有九大类，比如DCIM、DOWNLOAD等这种系统为我们创建的文件夹，私有目录就是Android这个文件夹，这个文件夹打开之后里边有一个data文件夹，打开这个data文件夹，里边有许多包名组成的文件夹。 注：所有的这些目录结构都可以通过打开Android模拟器，然后使用DDMS中的File Explorer进行查看。 res/raw和assetsres/raw和assets的相同点两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。 res/raw和assets的不同点（1）res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename；assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类。 （2）res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹 另外： assets：用于存放需要打包到应用程序的静态文件，以便部署到设备中。与res/raw不同点在于，ASSETS支持任意深度的子目录。这些文件不会生成任何资源ID，必须使用/assets开始（不包含它）的相对路径名。 res:用于存放应用程序的资源（如图标、GUI布局等），将被打包到编译后的Java中。不支持深度子目录 res/raw:存放通用的文件， 该文件夹内的文件将不会被编译成二进制文件，按原样复制到设备上。 文件存储操作读写/data/data/&lt;应用程序名&gt;/files/目录上的文件（1）文件权限 MODE_PRIVATE-默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容。 MODE_APPEND-该模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。 MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE-用来控制其他应用程序是否有权限读写该文件。 （2）读文件 1234567891011121314public String readFile(String fileName) throws IOException &#123; String res = &quot;&quot;; try &#123; FileInputStream fis = openFileInput(fileName); int length = fis.available(); byte[] bytes = new byte[length]; fis.read(bytes); res = EncodingUtils.getString(bytes, &quot;UTF-8&quot;); fis.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return res;&#125; （3）写文件12345678910public void writeFile(String fileName, String str) throws IOException &#123; try &#123; FileOutputStream fos = openFileOutput(fileName, MODE_PRIVATE); byte[] bytes = str.getBytes(); fos.write(bytes); fos.close(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 读写SD卡中的文件。也就是/storage/sdcard/目录下面的文件目录/mnt/sdcard和目录/sdcard没有区别，它们都是指向目录/storage/sdcard的快捷方式。 （1）添加权限 1234&lt;!-- SDCard中创建与删除文件权限 --&gt; &lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;/&gt; &lt;!-- 向SDCard写入数据权限 --&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; （2）判断SDCard是否存在1234public boolean isSdCardExist() &#123; return Environment.getExternalStorageState().equals( Environment.MEDIA_MOUNTED); &#125; （3）获取SD卡根目录1234567891011 public File getSdCardPath() &#123; boolean exist = isSdCardExist(); File dir; if (exist) &#123; dir = Environment.getExternalStorageDirectory(); &#125; else &#123; dir = null; &#125; return dir;&#125; （4）写文件 1234567891011121314151617181920public void writeSDCardFile(String fileName, String str) &#123; File myfile = new File(getSdCardPath(), fileName); try &#123; if(!myfile.exists())&#123; //如果文件不存在则创建新文件 myfile.createNewFile(); &#125; FileOutputStream fos = new FileOutputStream(myfile); byte[] bytes = str.getBytes(&quot;UTF-8&quot;); //将字符串转换成字节序列，并制定编码为UTF-8 fos.write(bytes); fos.flush(); //将缓冲区中的数据强制写出 fos.close(); //关闭数据流 &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; （5）读文件 1234567891011121314151617181920public String readSDCardFile(String fileName) &#123; String res = null; File myfile = new File(getSdCardPath(), fileName); try &#123; FileInputStream fis = new FileInputStream(myfile); int length = fis.available(); //得到数据长度 byte[] bytes = new byte[length]; //开辟一个字节数组 fis.read(bytes); //读出数据 fis.close(); //关闭数据流 res = new String(bytes, &quot;UTF-8&quot;); //将字符数组转换成字符串，指定编码为UTF-8 &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return res;&#125; （6）删除文件 1234public void deleteSDCardFile(String fileName) &#123; File myfile = new File(getSdCardPath(), fileName); myfile.delete();&#125; 除了上面讲到的读文件、写文件、删除文件外，File对象还有创建文件、设置可读可写等方法，具体的可以自己取查看相应的文档。 从res/raw中读取文件数据读取文本文件时需要考虑编码格式的问题。在简体中文Windows操作系统中，ANSI 编码代表 GBK 编码，文本文件保存时默认使用ANSI编码，所以在读取文件获取字符串时要使用GBK进行编码。以下代码以读取txt文件为例。 12345678910111213141516171819public String getRawFile(int resId) &#123; String res = &quot;&quot;; try &#123; // 得到资源中的Raw数据流 InputStream in = getResources().openRawResource(resId); int length = in.available(); byte[] bytes = new byte[length]; // 读取数据 in.read(bytes); // 依test.txt的编码类型选择合适的编码，如果不调整会乱码 res = EncodingUtils.getString(bytes, &quot;GBK&quot;); in.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return res;&#125; 从assets中读取文件数据以下代码同样以读取txt文件为例。 1234567891011121314151617public String getAssertFile(String fileName) &#123; String res = null; try &#123; // 得到资源中的asset数据流 InputStream in = getResources().getAssets().open(fileName); int length = in.available(); byte[] bytes = new byte[length]; in.read(bytes); in.close(); res = EncodingUtils.getString(bytes, &quot;GBK&quot;); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return res;&#125; 参考博客： [1] android中的文件操作详解以及内部存储和外部存储 [2] android资源目录—assets与res/raw区别 [3] Android - 文件读写操作 总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android SQLite基本操作详解]]></title>
      <url>%2F2016%2F07%2F26%2FAndroid-SQLite%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[SQLite 是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。之前写过一个简单的Android记事本程序，使用过SQLite数据库，但是并没有真正理解并消化。前段时间认真学习了Mysql数据库的相关知识，对数据库有了更深入的认识，于是，也准备把Android这一块的SQLite数据库好好整理一下。 SQLite支持的数据类型： NULL(空值)、INTEGER(整型值)、REAL(浮点值)、TEXT(字符串值)、BLOB(二进制对象) 数据库创建与管理使用辅助类SQLiteOpenHelper来管理数据库的创建和版本更新，在工程中新建一个类SQLiteUtil用于管理数据库，继承自SQLiteOpenHelper。 必须实现构造方法public DatabaseHelper(Context context, String name, CursorFactory factory, int version) 重写两个抽象方法public void onCreate(SQLiteDatabase db)，方法当数据库第一次被建立的时候被执行，一般把创建表,初始化数据等操作放在这里。 public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)方法，当数据库版本更新时会自动执行。 1234567891011121314151617181920212223242526272829303132333435public class SQLiteUtil extends SQLiteOpenHelper&#123; public static final String TABLE_NAME_STUDENT = &quot;student&quot;; public static final String COLUMN_NAME_ID = &quot;_id&quot;; public static final String COLUMN_NOTE_NO = &quot;Sno&quot;; public static final String COLUMN_NOTE_NAME = &quot;Sname&quot;; public static final String COLUMN_NOTE_AGE = &quot;Sage&quot;; public static final String COLUMN_NOTE_SEX = &quot;Ssex&quot;; public SQLiteUtil(Context context, String name, CursorFactory factory,int version) &#123; super(context, name, factory, version); // TODO Auto-generated constructor stub &#125; @Override public void onCreate(SQLiteDatabase db) &#123; // TODO Auto-generated method stub //在这里创建数据库，后文会用到 db.execSQL(&quot;CREATE TABLE &quot; + TABLE_NAME_STUDENT + &quot;(&quot; + COLUMN_NAME_ID + &quot; INTEGER PRIMARY KEY AUTOINCREMENT,&quot; + COLUMN_NOTE_NO + &quot; TEXT NOT NULL DEFAULT \&quot;\&quot;,&quot; + COLUMN_NOTE_NAME + &quot; TEXT NOT NULL DEFAULT \&quot;\&quot;,&quot; + COLUMN_NOTE_AGE + &quot; INTEGER NOT NULL,&quot; + COLUMN_NOTE_SEX + &quot; TEXT NOT NULL DEFAULT \&quot;男\&quot;&quot; + &quot;)&quot; ); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)&#123; // TODO Auto-generated method stub //在这里更新数据库版本 &#125;&#125; 在这个类被实例化的时候，系统会检测这个数据库是否存在，如果已经存在就不再创建，如果不存在则创建。还会检测数据库的版本，当版本号不同时会执行更新操作。 数据库基本操作SQLiteDataBase类提供了大量的API来操控SQLite数据库,每一个SQLiteDatabase的实例就代表了一个数据库(对应底层的一个数据库文件)，一旦应用程序获得了SQLiteDatabase对象，就可以通过该对象来操作与之相对应的数据库。 12SQLiteUtil mSqLiteUtil = new SQLiteUtil(this, &quot;fzy&quot;, null, 1);SQLiteDatabase db = mSqLiteUtil.getWritableDatabase(); //得到一个SQLiteDatabase对象 基本操作写法一对于插入、删除和更新来说都可以通过executeSQL方法执行sql语句来实现。 12db.executeSQL(String sql); db.executeSQL(String sql, Object[] bindArgs); //sql语句中使用占位符，然后第二个参数是实际的参数集 查询可以使用rawQuery方法执行sql语句来实现。 1db.rawQuery(String sql, String[] selectionArgs); 将所有的SQL语句都组织到一个字符串中，使用占位符代替实际参数，selectionArgs就是占位符实际参数集。 基本操作写法二除了统一的形式之外，他们还有各自的操作方法： 插入1db.insert(String table, String nullColumnHack, ContentValues values); 第一个参数都是表示要操作的表名，第二个参数表示如果插入的数据每一列都为空的话，需要指定此行中某一列的名称，系统将此列设置为NULL，不至于出现错误，第三个参数ContentValues类型的变量，是键值对组成的Map，key代表列名，value代表该列要插入的值。 删除1db.delete(String table, String whereClause, String whereArgs); 第一个参数都是表示要操作的表名，第二个参数是用来指定删除条件，传递空值时将删除所有行，第三个参数是删除条件的数组值，将与第二个参数组成条件字符串。 更新1db.update(String table, Contentvalues values, String whereClause, String whereArgs); 第一个参数都是表示要操作的表，第二个参数ContentValues类型的变量，是键值对组成的Map，key代表列名，value代表该列要插入的值。第三个参数用来指定更新条件，传递空值将更新所有行。第四个参数是更新条件的数组值，将与第三个参数组成条件字符串。 查询查询有很多不同参数的方法，这里只列举一例，其他的可以参考官方文档查看。1db.query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy); 第一个参数都是表示要操作的表名，第二个参数表示要查询的列所有名称集，第三个参数selection表示WHERE之后的条件语句，可以使用占位符，groupBy指定分组的列名，having指定分组条件，配合groupBy使用，orderBy指定排序的列名，limit指定分页参数，distinct可以指定“true”或“false”表示要不要过滤重复值。需要注意的是，selection、groupBy、having、orderBy、limit这几个参数中不包括“WHERE”、“GROUP BY”、“HAVING”、“ORDER BY”、“LIMIT”等SQL关键字。 结果集的处理最后，他们同时返回一个Cursor对象，代表数据集的游标，有点类似于JavaSE中的ResultSet。 方法 描述 move(int offset) 以当前位置为参考,移动到指定行 moveToFirst() 移动到第一行 moveToLast() 动到最后一行 moveToPosition(int position) 移动到指定行 moveToPrevious() 移动到前一行 moveToNext() 移动到下一行 isFirst() 是否指向第一条 isLast() 是否指向最后一条 isBeforeFirst() 是否指向第一条之前 isAfterLast() 是否指向最后一条之后 isNull(int columnIndex) 指定列是否为空(列基数为0) isClosed() 游标是否已关闭 getCount() 总数据项数 getPosition() 返回当前游标所指向的行数 getColumnIndex(String columnName) 返回某列名对应的列索引值 getString(int columnIndex) 返回当前行指定列的值 遍历结果集的方法： 1234567Cursor cs = db.query(传入相关参数); //得到结果集if(cs!=null)&#123; while(cs.moveToNext())&#123; cs.getString(cs.getColumnIndex(列名)); //通过列名获得列索引，然后再取出其值 //...获取更多的列值 &#125;&#125; Demo演示这篇博客准备很久了，之前只是知道怎么使用Android的SQLite数据库，并没有系统地去熟悉相关的知识，现在通过查看官方的API文档与别人的博客将这些知识整理了一下，自己写了一个小Demo来熟悉Android的SQLite数据库操作。 核心的代码如下： MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public void insertData() &#123; //插入数据 // 通过直接执行SQL语句来给学生表插入3条数据 db.execSQL(&quot;INSERT INTO &quot; + SQLiteUtil.TABLE_NAME_STUDENT + &quot; (Sno,Sname,Sage,Ssex) VALUES (&apos;2016001&apos;,&apos;fzy&apos;,&apos;22&apos;,&apos;男&apos;)&quot;); db.execSQL(&quot;INSERT INTO &quot; + SQLiteUtil.TABLE_NAME_STUDENT + &quot; (Sno,Sname,Sage,Ssex) VALUES (&apos;2016002&apos;,&apos;qwe&apos;,&apos;20&apos;,&apos;女&apos;)&quot;); db.execSQL(&quot;INSERT INTO &quot; + SQLiteUtil.TABLE_NAME_STUDENT + &quot; (Sno,Sname,Sage,Ssex) VALUES (&apos;2016003&apos;,&apos;asd&apos;,&apos;19&apos;,&apos;男&apos;)&quot;); // 使用insert方法来给学生表插入一条记录 ContentValues cv = new ContentValues(); cv.put(SQLiteUtil.COLUMN_NOTE_NO, &quot;20160004&quot;); cv.put(SQLiteUtil.COLUMN_NOTE_NAME, &quot;rty&quot;); cv.put(SQLiteUtil.COLUMN_NOTE_AGE, &quot;24&quot;); cv.put(SQLiteUtil.COLUMN_NOTE_SEX, &quot;男&quot;); db.insert(SQLiteUtil.TABLE_NAME_STUDENT, null, cv);&#125;public void deleteData() &#123; // 直接执行SQL语句删除学生表中Sage大于18的学生的所有信息 db.execSQL(&quot;DELETE FROM &quot; + SQLiteUtil.TABLE_NAME_STUDENT + &quot; WHERE Sage = 18&quot;); // 使用delete方法来删除学生表中_id大于1的学生的所有信息 db.delete(SQLiteUtil.TABLE_NAME_STUDENT, &quot;_id&gt;&quot;, new String[] &#123; &quot;1&quot; &#125;);&#125; public void updateData() &#123; // 直接执行SQL语句表中Sno为20160002的学生的名字Sname更新为xxx db.execSQL(&quot;UPDATE &quot; + SQLiteUtil.TABLE_NAME_STUDENT + &quot; SET Sname = &apos;xxx&apos; WHERE Sno = &apos;2016002&apos;&quot;); // 使用update方法来更新学生表中_id大于2的学生的年龄信息 ContentValues cv = new ContentValues(); cv.put(SQLiteUtil.COLUMN_NOTE_AGE, &quot;18&quot;); db.update(SQLiteUtil.TABLE_NAME_STUDENT, cv, &quot;_id&gt;?&quot;, new String[] &#123; &quot;2&quot; &#125;);&#125;public void queryData() &#123; Cursor cs = db.query(SQLiteUtil.TABLE_NAME_STUDENT, null, null, null,null, null, null, null); StringBuilder result = new StringBuilder(); while (cs.moveToNext()) &#123; //遍历结果集 String line = cs.getString(cs.getColumnIndex(SQLiteUtil.COLUMN_NOTE_NO)) + cs.getString(cs.getColumnIndex(SQLiteUtil.COLUMN_NOTE_NAME)) + cs.getInt(cs.getColumnIndex(SQLiteUtil.COLUMN_NOTE_AGE)) + cs.getString(cs.getColumnIndex(SQLiteUtil.COLUMN_NOTE_SEX)) + &quot;\n&quot;; result.append(line); &#125; mResult.setText(result); //使用TextView显示出来 cs.close();&#125; 通过在按钮的监听事件中调用这些方法就可以实现我的Demo的功能，这个Demo主要是通过不同的方式来实践数据库的操作，比较简单。效果如下： 数据库管理工具将程序运行在模拟器中后，我们可以打开DDMS工具看到我创建的数据库文件：fzy，将其导出到电脑，使用第三方工具查看。这里讲解一种比较方便的方法，直接使用SDK提供的数据库管理工具来操作，不需要每次更改都将数据库文件导出到windows，具体方法如下： 1、打开Windowsx系统的cmd窗口 2、进入到你的SDK目录下的platform-tools目录下，输入如下命令： 1adb shell 进入调试环境，然后输入如下命令进入到数据库文件夹： 12cd /data/data/包名/databasesls //查看有哪些数据库文件 然后，使用如下sqlite工具打开数据库文件 1sqlite3 数据库文件名 进入sqlite3命令行管理工具，可以通过以下命令进行操作，这与mysql数据库有些区别，命令都是以.号开。 12.help 查看帮助.tables 查看数据库中存在的表 然后就可以对相应的表执行sql语句啦！需要注意的是，sql语句末尾需要加分号，sqlite命令行工具的操作命令不需要加分号。 如下图所示： 参考博客： [1] Android中SQLite应用详解[2] Android 操作SQLite基本用法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每个认真生活的人，都值得被认真对待]]></title>
      <url>%2F2016%2F07%2F25%2F%E6%AF%8F%E4%B8%AA%E8%AE%A4%E7%9C%9F%E7%94%9F%E6%B4%BB%E7%9A%84%E4%BA%BA%EF%BC%8C%E9%83%BD%E5%80%BC%E5%BE%97%E8%A2%AB%E8%AE%A4%E7%9C%9F%E5%AF%B9%E5%BE%85%2F</url>
      <content type="text"><![CDATA[突然，有那么一刻，我会特别想哭。平时，很少总结也很少煽情，现在，回想总结起来，带实验室的这一年里，收获很多，感慨也很多。 这一年里，自己真的花了很多时间很多精力，想各种办法来带大家，虽然我现在也知道自己当时讲课讲得并不好，大家可能在我的课堂上并没有学到太多的东西，所以也很感谢大家能一直听我讲完。现在回想起来可能也是自己当时太急了，想尽快把大家都教会，所以课程讲得很快，也没有很好的考虑大家的感受。也因为深知责任重大，我将自己的很多时间都花在了这里。大三第一个学期，正在带14级的学弟学妹，平时上课，周末的时间都花在实验室，然而自己又报名了软考，那段时间，很纠结，要带大家就不能好好复习，结果第一次考果然没过，还好这学期顺利拿到了软件设计师的证。然后为了蓝桥杯的板子，压缩复习时间，到实验室和陈老师一起调试板子，都是为了大家能够有一个好的训练平台，拿个好的名次。想想，那些纠结的时候义无反顾的抉择又有多少人知道，现在想起来，真的很艰难。但是，看到现在实验室取得的成绩，我也是很感动的，毕竟努力有了收获。 其实，一年下来，坚持下来的人是一定有收获的。有的人慢慢的慢慢的就放弃了，很可惜，这一路上，见证了很多中途退出的人，我也曾经试图挽留，但是都没能留得住。或许，每个人都有每个人的理想。能够一直坚持下来的也算是一种缘分，因为已经不记得有多少个在203奋斗的深夜，不记得有多少一起开怀大笑的日子。也只有真正经常混在一起的这一群人才会有机会一起去聚餐了吧，在一起喝喝酒，聊聊天，就这样也挺好。 这一路走来，要感谢的人也很多。 首先就是一直给予我们支持的指导老师了，很感谢匡老师的到来，没有她也没有实验室的今天，曾经想要放弃的我，在匡老师的带领下一起把实验室带到今天的样子，没有她的支持也没有我当初努力的样子。还记得去北京参加蓝桥杯国赛的时候，比赛完感觉不太好，心情差极了，就怕对不起一直给我们支持和鼓励的匡老师，不过还好，虽然没拿一等奖，但是成绩也不坏。在实验室的管理方面，匡老师确实花了不少的功夫，在协调各个指导老师的时候，我也知道有多难，因为一个实验室五个指导老师，很多事情都需要去协调去处理。然后，就是一直带我们的陈老师了，这学期很多的比赛获奖都是在陈老师的带领下获得的，也确实，陈老师自己也付出了很多，这学期在实验室经常能见到他忙碌的身影，对于每个比赛他都认真对待，自然也能够获得不错的成绩。然后，很感谢陈老师能够和我一起把蓝桥杯的板子做好，这块板子确实起了很大的作用。技术方面，陈老师确实付出了不少，感谢！ 其次，要感谢13级的这几个小伙伴，是你们的坚持，造就了实验室的今天，一直都是你们在支持着我，很感谢，没有你们的付出也没有实验室今天的成绩。看到现在大家的成长我也是很欣慰的，大家都要找工作了，希望大家都能有个美好的未来，说不定以后就是我的面试官了呢，哈哈。 最后，还是要感谢欧超、杨勇锋、李维维等学长为这个实验室的付出，没有你们的基础也没有实验室今天的发展。谢谢欧超学长带我走进这个实验室，带我学习单片机，谢谢杨勇锋学长为电子协会的辛勤付出，也谢谢李维维学长带了我几个假期，还谢谢其他学长平时对我的教导。没有一届一届的付出也就没有未来，希望这种精神能够一届届传递下去。 一直觉得自己是一个很幸运的人，因为大学三年来一直有老师的关心与支持，有学长学姐的帮助与指引，有小伙伴的共同努力，有学弟学妹们的支持。一直很相信一句话：每个认真生活的人，都值得被认真对待。希望你们也如此。 电子设计创新实验室的时光，谢谢有你！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python操作Mysql数据库]]></title>
      <url>%2F2016%2F07%2F24%2FPython%E6%93%8D%E4%BD%9CMysql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
      <content type="text"><![CDATA[在正式开始Python网络爬虫实战之前，我们需要先来了解一下Python的一些基础知识，包括网络请求、数据存储以及异常处理等，这篇博客主要讲解Python的Mysql数据库操作，我们使用爬虫爬取下来的数据需要存储，而数据库就是常用的存储方式之一，所以熟练地掌握数据库操作对于网络爬虫的学习是很有必要的。 安装访问数据库的类库windows下cmd直接执行如下命令进行安装：1pip install pymysql 注：如果没有安装pip包管理器，请先安装pip才能用此命令安装pymysql 基本操作导入库1import mysql 连接数据库123456conn = pymysql.connect(host = &apos;localhost&apos;, user = &apos;你的用户名&apos;, passwd = &apos;你的密码&apos;, charset=&apos;utf8&apos;) #得到连接对象cur=conn.cursor() #得到游标对象cur.execute(&quot;USE school&quot;) #指定使用哪个数据库 插入、查询等基本操作创建表：1cur.execute(&quot;CREATE TABLE student (id TINYINT, Sno VARCHAR(255) UNIQUE KEY, )&quot;) 插入数据：方式一：直接赋值 12cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (&apos;20160001&apos;, &apos;xxx&apos;, 20, &apos;男&apos;)&quot;)conn.commit() #更改数据后需进行提交 方式二：由变量赋值 123456Sno = &apos;20160004&apos;Sname = &apos;lll&apos;Sage = &apos;20&apos;Ssex = &apos;男&apos;cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (\&quot;%s\&quot;,\&quot;%s\&quot;,\&quot;%s\&quot;,\&quot;%s\&quot;)&quot;%(Sno, Sname, Sage, Ssex))conn.commit() #更改数据后需进行提交 查询数据：1cur.execute(&quot;SELECT * FROM Student&quot;) 打印查询结果：12print cur.fetchone() #打印第一条查询结果print cur.fetchall() #打印所有查询结果 关闭连接12cur.close()conn.close() 完整示例创建一张学生表，有id，学号、姓名、年龄、性别五列，然后插入四条数据，在进行查询并打印所有查询结果。 1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf8 -*-import pymysqlconn = pymysql.connect(host = &apos;localhost&apos;, user = &apos;root&apos;, passwd = &apos;fzy1686&apos;, charset=&apos;utf8&apos;)cur=conn.cursor()cur.execute(&quot;USE school&quot;)try: cur.execute(&quot;CREATE TABLE Student (id BIGINT(10) NOT NULL AUTO_INCREMENT,\ Sno VARCHAR(20) NOT NULL,\ Sname VARCHAR(20) NOT NULL,\ Sage VARCHAR(10) NOT NULL,\ Ssex VARCHAR(10) DEFAULT &apos;男&apos;,\ PRIMARY KEY(id))&quot;) cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (&apos;20160001&apos;, &apos;xxx&apos;, 20, &apos;男&apos;)&quot;) cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (&apos;20160002&apos;, &apos;yyy&apos;, 18, &apos;女&apos;)&quot;) cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (&apos;20160003&apos;, &apos;zzz&apos;, 22, &apos;女&apos;)&quot;) Sno = &apos;20160004&apos; Sname = &apos;lll&apos; Sage = &apos;20&apos; Ssex = &apos;男&apos; cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (\&quot;%s\&quot;,\&quot;%s\&quot;,\&quot;%s\&quot;,\&quot;%s\&quot;)&quot;%(Sno, Sname, Sage, Ssex)) conn.commit() cur.execute(&quot;select * from Student&quot;) print cur.fetchall()finally: cur.close() conn.close()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android数据存储之SharedPreferences]]></title>
      <url>%2F2016%2F07%2F21%2FAndroid%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8BSharedPreferences%2F</url>
      <content type="text"><![CDATA[SharedPreferences是一种轻型的数据存储方式，它的本质是基于xml文件存储的key-value键值对数据，它的使用非常简单,能够轻松的存放数据和读取数据。App都有相应的配置文件，但是由于App的配置信息并不多，如果采用数据库来存放并不划算，因为数据库连接跟操作等耗时大大影响了程序的效率，因此通常使用SharedPreferences来存储一些简单的配置信息。 使用SharedPreferences保存数据获得SharedPreferences对象使用getSharedPreferences方法得到SharedPreferences对象，该方法有两个参数，第一个参数是文件名，第二个参数是权限模式。文件名不需要加后缀，系统在生成该文件时会自动加上.xml后缀。 SharedPreferences的四种操作模式:Context.MODE_PRIVATE：为默认操作模式,代表该文件是私有数据,只能被应用本身访问,在该模式下,写入的内容会覆盖原文件的内容. Context.MODE_APPEND：模式会检查文件是否存在,存在就往文件追加内容,否则就创建新文件. Context.MODE_WORLD_READABLE和Context.MODE_WORLD_WRITEABLE用来控制其他应用是否有权限读写该文件. Context.MODE_WORLD_READABLE：表示当前文件可以被其他应用读取. Context.MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入. 获取Editor对象，并使用相应的方法来创建、修和清除数据调用该SharedPreferences对象的Editor接口得到一个Editor对象，使用该对象有putInt，putString等putXxx方法来存储键值对信息，通过remove()方法来移除一个键值对，或者通过clear()方法来清除数据等。 使用commit()方法提交数据。12345SharedPreferences sharedPreferences = getSharedPreferences(&quot;mysp&quot;,Context.MODE_PRIVATE);Editor editor=sharedPreferences.edit();editor.putString(&quot;name&quot;, &quot;fzy&quot;);editor.putString(&quot;age&quot;, &quot;22&quot;);editor.commit(); //提交数据 记得每次更改数据后都要调用editor对象的commit()方法提交数据，执行以上代码后，SharedPreferences将会把这些数据保存在mysp.xml文件中，可以打开eclipse的DDMS工具在File Explorer的data/data/相应的包名/shared_prefs/mysp.xml 下导出该文件，并查看。（如下图红色箭头标注） 我们可以将此xml文件导出来看看，点击右上角pull a file from the device(如下图蓝色箭头标注) 从SharedPreferences获取数据1234SharedPreferences sharedPreferences=getSharedPreferences(&quot;mysp&quot;, Context.MODE_PRIVATE);String name=sharedPreferences.getString(&quot;name&quot;, &quot;defaultname&quot;);String age=sharedPreferences.getString(&quot;age&quot;, &quot;0&quot;);System.out.println(&quot;name: &quot;+ name + &quot;,age: &quot; + age); 取出结果如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android真机抓屏- Android Screen Monitor]]></title>
      <url>%2F2016%2F07%2F21%2FAndroid%E7%9C%9F%E6%9C%BA%E6%8A%93%E5%B1%8F-Android-Screen-Monitor%2F</url>
      <content type="text"><![CDATA[最近遇到一个比较尴尬的问题，博客需要做一个Android手机网络状态检测的操作演示gif动图，虽然找到一款可以在电脑上录屏并自动生成gif文件的软件，但是eclipse自带的模拟器又不能切换到GPRS网络，于是，想着将真机的屏幕分享到电脑再进行录屏操作，试了华为助手和360助手，但是他们都需要全屏演示，不能很好的结合我的录屏软件，于是又百度找了找，最后还真有个小工具可以实现真机抓屏，反应还挺快，这就是Android Screen Monitor。 ASM简介Android Screen Monitor，简称为ASM，它是一个监视设备或模拟器屏幕的工具，ASM是 ADB调试桥的客户端应用程序，当ASM开始监控屏幕的时候，它通过5037端口连接至ADB，不断地把所监控设备的屏幕数据保存在帧缓存中并且把图像数据转换成用户可观测的内容。 ASM使用方法1、确保你的手机可以进行真机调试 一般我们只要将手机通过USB连接上电脑，并打开USB调试，允许电脑控制我们的手机，然后将项目运行看是否能够运行在我们的真机。 2、ASM下载 最新版本是2.5，下载地址： https://code.google.com/p/android-screen-monitor/downloads/list 貌似要翻墙才能下载，不想翻墙单的话可以私聊我。 3、解压后文件夹中的asm.jar复制到Android SDK的platform-tools目录下 4、打开ASM 方法一：打开cmd，进入到Android SDK的platform-tools目录，然后输入如下命令 1java -jar asm.jar 方法二：直接双击Android SDK的platform-tools目录下的asm.jar文件 5、进入选择界面，选择我们的手机 6、进行相关配置 可右键选择调整窗体大小 至此，我们就实现了将自己的手机屏幕分享到电脑的功能，赶快来体验一下反应快、画面流畅的Android Screen Monitor吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 网络状态检查总结]]></title>
      <url>%2F2016%2F07%2F20%2FAndroid-%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[几乎每个具有连网功能的App都会有网络检测代码专门负责网络检测，需要实时检测网络是否可用，当出现网络不可用或者无连接时提示用户，当需要观看视频时自动检测是否处于wifi网络，并提示用户避免带来大量的流量消耗，所有的这些功能都是为了使App的用户体验更好。此篇博客主要介绍检测网络状态的相关方法，并通过一个小例子来实现实时的网络状态检测。 添加权限在AndroidManifest.xml文件添加： 12&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 编写相应的检测方法判断网络是否可用的方法12345678910public boolean isNetworkAvailable(Context context) &#123; ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (mConnectivityManager != null) &#123; NetworkInfo mNetworkinfo = mConnectivityManager.getActiveNetworkInfo(); if (mNetworkinfo != null) &#123; return mNetworkinfo.isAvailable(); &#125; &#125; return false;&#125; 判断WIFI网络是否连接上的方法1234567891011public boolean isWifiConnected(Context context) &#123; ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (mConnectivityManager != null) &#123; NetworkInfo mWiFiNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI); if (mWiFiNetworkInfo != null &amp;&amp; mWiFiNetworkInfo.isConnected()) &#123; return true; &#125; &#125; return false;&#125; 判断GPRS网络是否连接上的方法1234567891011public boolean isMobileConnected(Context context) &#123; ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (mConnectivityManager != null) &#123; NetworkInfo mMobileNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE); if (mMobileNetworkInfo != null &amp;&amp; mMobileNetworkInfo.isConnected()) &#123; return true; &#125; &#125; return false;&#125; 获取所连接网络的类型的方法1234567891011public String getNetworkType(Context context) &#123; ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (mConnectivityManager != null) &#123; NetworkInfo mNetworkinfo = mConnectivityManager.getActiveNetworkInfo(); if (mNetworkinfo != null &amp;&amp; mNetworkinfo.isAvailable()) &#123; String info = &quot;Type: &quot; + mNetworkinfo.getType() + &quot; Name: &quot;+ mNetworkinfo.getTypeName(); return info; &#125; &#125; return &quot;网络无连接，请检查网络&quot;; &#125; 实现网络状态监测使用Service+BroadcastReceiver来实现相应的功能。 编写网络状态检测类12345678910111213141516171819public class NetState extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO Auto-generated method stub ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (mConnectivityManager != null) &#123; NetworkInfo mMobileNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE); NetworkInfo mWiFiNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI); if (!mMobileNetworkInfo.isConnected()&amp;&amp; !mWiFiNetworkInfo.isConnected()) &#123; Toast.makeText(context, &quot;网络连接断开，请检查网络&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, &quot;网络连接成功&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;&#125; 在Activity的onCreate方法中注册监听12345NetState mNetState = new NetState(); //获取网络监听实例IntentFilter mFilter = new IntentFilter(); //获取意图过滤器实例mFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); //过滤Action，使只监听网络动作事件的广播this.registerReceiver(mNetState, mFilter); //注册广播接收器mNetState.onReceive(this, null); //调用广播接收方法 效果演示自己写了一个Android网络检测的演示demo，使用了刚刚学会的录屏生成动图软件以及刚刚安装上的wordpress动图插件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python爬虫利器---BeautifulSoup]]></title>
      <url>%2F2016%2F07%2F17%2FPython%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8-BeautifulSoup%2F</url>
      <content type="text"><![CDATA[Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。 BeautifulSoup4安装由于BeatifulSoup库不是Python标准库，因此需要单独安装。 在Linux系统上安装1$sudo apt-get install python-bs4 在Windows系统安装可以利用 pip 或者 easy_install 来安装 1pip install beautifulsoup4 1easy_install beautifulsoup4 Beautifulsoup4使用导入库（1）导入网络请求库 Python2.x里的urllib2与urllib有些不同，在Python3.x里，urllib2改名为urllib，被分成一些子模块：urllib.request、urllib.parse、urllib.error。所以不同的版本使用时略有区别。 Python3.x版本：1from urllib.request import urlopen Python2.x版本：1from urllib import urlopen （2）导入Beautifulsoup41from bs4 import BeautifulSoup 运行Beautifulsoup首先我准备了一个简单的测试页面，网址是：blog.line-coding.tech，页面的结构如下： 可以看到我们的img标签在红色箭头标注的位置，我们通过代码一步步的去获取中心404图片的url地址，如下： Python3.x版本： 123456789from urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen(&quot;http://blog.line-coding.com&quot;)bsObj = BeautifulSoup(html.read())print(bsObj.body)print(bsObj.body.div)print(bsObj.body.div.div)print(bsObj.body.div.div.img)print(bsObj.body.div.div.img[&apos;src&apos;]) Python2.x版本： 123456789import urllibfrom bs4 import BeautifulSouphtml = urllib.urlopen(&quot;http://blog.line-coding.com&quot;)bsObj = BeautifulSoup(html,&quot;html.parser&quot;)print bsObj.body #得到body标签的内容print bsObj.body.div #得到body标签下div标签的内容print bsObj.body.div.div #得到body标签下div标签下的div标签的内容print bsObj.body.div.div.img #得到img标签的内容print bsObj.body.div.div.img[&apos;src&apos;] #得到图片url地址 结果如下： 有了Beautiful4，我们就可以将网页代码转换成一个对象，并通过再通过.号去访问这个对象的信息，一级一级的去查找来所需的信息。接下来的博客中，我会使用Beautiful4来进行数据爬取，敬请关注。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android ip地址信息查询]]></title>
      <url>%2F2016%2F07%2F12%2FAndroid-ip%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%2F</url>
      <content type="text"><![CDATA[上一篇博客中我们讲解了如何获取外网的ip地址，获取到的ip地址总是会有用的，我们现在就来使用它，通过查询ip地址的相关信息我们可以获取当前所在城市信息，即ip地址定位。其实，实现起来也比较简单，主要还是使用的第三方API接口，通过http请求来获取信息。 实现方法百度API Store Ip地址定位API的使用上一步我们获取了本机的外网ip地址，然后我们使用百度API Store的ip地址定位API来进行ip地址定位。API的地址，他有很详细的文档，可以很容易使用。通过Http的GET方法将ip地址发送给服务器，将获取JSON格式的返回值进行解析即可实现定位。如下图所示： android-async-httpandroid-async-http是一个第三方网络请求库，由于在上一篇博客中我们已经为工程添加android-async-http的jar包，所以这里不需要重复添加，可直接进入下一步。 代码编写Handler新建一个Handler用于将Http请求获得的定位数据传回Activity： 123456789101112131415161718192021private Handler mCityHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; String res = (String) msg.obj; //获取传回的定位数据 res = decodeUnicode(res); System.out.println(res); mAddr.setText(res); //显示ip地址定位信息 //也可以进一步解析JSON数据取出所在国家、省份、城市等信息 try &#123; JSONObject js = new JSONObject(res); js = js.getJSONObject(&quot;retData&quot;); String country = js.getString(&quot;country&quot;); String province = js.getString(&quot;province&quot;); String city = js.getString(&quot;city&quot;); System.out.println(&quot;city:&quot; + city); &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;;&#125;; Http请求在IpHttpUtil类中编写Http请求静态方法，这里还是使用的android-async-http网络请求库，因为它方便、简洁，而且稳定，所以一直喜欢用它。 1234567891011121314151617181920212223242526272829303132333435363738public static void getAddress(final Handler handler, String ip) &#123; //定位信息请求地址 String url = &quot;http://apis.baidu.com/apistore/iplookupservice/iplookup&quot;; AsyncHttpClient client = new AsyncHttpClient(); client.addHeader(&quot;apikey&quot;, &quot;这里填你自己百度API商店注册后的apikey&quot;); RequestParams params = new RequestParams(); params.add(&quot;ip&quot;, ip); //添加参数 client.get(url, params, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int arg0, Header[] arg1, byte[] bytes) &#123; // TODO Auto-generated method stub String response = null; try &#123; response = new String(bytes, &quot;GBK&quot;); //获取服务器返回数据 &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; Message msg = new Message(); msg.obj = response; handler.sendMessage(msg); &#125; @Override public void onFailure(int arg0, Header[] arg1, byte[] bytes, Throwable arg3) &#123; // TODO Auto-generated method stub String response = null; try &#123; response = new String(bytes, &quot;GBK&quot;); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(response); &#125; &#125;);&#125; 执行请求在mIpHandler接收到ip地址后，再调用获取定位信息的Http方法（即在mIpHandler的handleMessage方法的最后加入下面这行代码） 1IpHttpUtil.getAddress(mCityHandler, res); //发送获取定位信息的http请求 效果展示我们在获取ip地址那篇博客的例子的基础上增加了一个TextView来显示本篇博客获取的定位信息，如下图所示，我们获取并显示了得到的JSON格式的返回数据，即通过该ip地址获得的定位信息。如下图所示，我们可以看到已经获得了服务器返回的JSON数据，但是可以很清楚的看到，显示的unicode编码，并不是汉字，那就需要将接收到的数据转化成汉字咯。 在网上摘抄了一段unicode转汉字的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private String decodeUnicode(String theString) &#123; char aChar; int len = theString.length(); StringBuffer outBuffer = new StringBuffer(len); for (int x = 0; x &amp;lt; len;) &#123; aChar = theString.charAt(x++); if (aChar == &apos;\\&apos;) &#123; aChar = theString.charAt(x++); if (aChar == &apos;u&apos;) &#123; // Read the xxxx int value = 0; for (int i = 0; i &amp;lt; 4; i++) &#123; aChar = theString.charAt(x++); switch (aChar) &#123; case &apos;0&apos;: case &apos;1&apos;: case &apos;2&apos;: case &apos;3&apos;: case &apos;4&apos;: case &apos;5&apos;: case &apos;6&apos;: case &apos;7&apos;: case &apos;8&apos;: case &apos;9&apos;: value = (value &amp;lt;&amp;lt; 4) + aChar - &apos;0&apos;; break; case &apos;a&apos;: case &apos;b&apos;: case &apos;c&apos;: case &apos;d&apos;: case &apos;e&apos;: case &apos;f&apos;: value = (value &amp;lt;&amp;lt; 4) + 10 + aChar - &apos;a&apos;; break; case &apos;A&apos;: case &apos;B&apos;: case &apos;C&apos;: case &apos;D&apos;: case &apos;E&apos;: case &apos;F&apos;: value = (value &amp;lt;&amp;lt; 4) + 10 + aChar - &apos;A&apos;; break; default: throw new IllegalArgumentException( &quot;Malformed \\uxxxx encoding.&quot;); &#125; &#125; outBuffer.append((char) value); &#125; else &#123; if (aChar == &apos;t&apos;) aChar = &apos;\t&apos;; else if (aChar == &apos;r&apos;) aChar = &apos;\r&apos;; else if (aChar == &apos;n&apos;) aChar = &apos;\n&apos;; else if (aChar == &apos;f&apos;) aChar = &apos;\f&apos;; outBuffer.append(aChar); &#125; &#125; else outBuffer.append(aChar); &#125; return outBuffer.toString(); &#125; 使用此方法将接收到的字符处理后即可获得获得汉字显示，如下图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android获取外网ip地址详解]]></title>
      <url>%2F2016%2F07%2F10%2FAndroid%E8%8E%B7%E5%8F%96%E5%A4%96%E7%BD%91ip%E5%9C%B0%E5%9D%80%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[很多App都需要获取当前所在位置，如果需要获取精确地位置当然是使用GPS定位啦，但是有时候不需要那么精确的定位，而且手机开启GPS进行定位需要用户手动打开GPS开关，那么如何无声无息的在后台进行定位呢？其实，只要获取到本机的外网ip地址就能够获取你的所在大概地址啦！此篇博客主要讲解如何获取外网ip，如何通过ip进行定位将写在下一篇博客中。 获取外网ip地址实现方法想必很多人都查过本机的外网ip地址，通过cmd的config等命令看到的都是内网ip，要想查看外网ip有一个很简单的办法就是在百度输入ip，点击搜索即可看到自己的外网ip，这个结果通常是由www.ip138.com这个网站提供的，我们点进去可以看到他其实提供了ip地址查询服务。那我们就可以把这个利用起来，这里其实会用到类似爬虫的技术，也就是把网页源代码下下来，然后从源代码中提取ip地址。打开浏览器的开发者工具，定位ip地址那一行代码，可以看到如下代码： 我们对http://1212.ip138.com/ic.asp发送一个get请求即可获得服务器返回的ip地址信息。 android-async-http在AndroidManifest.xml文件中加入如下：1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; jar包下载点击此处可以下载第三方网络请求库：android-async-http的jar包 将jar包添加到工程将jar包复制到lib文件夹下，并右键该jar包，点击BuildPath，然后点击Add to Build Path。 获取网站返回信息对http://1212.ip138.com/ic.asp发送一个get请求来获得服务器返回的ip地址信息。 123456789101112131415161718192021222324252627282930public class IpHttpUtil &#123; public static void GetNetIp(final Handler handler, String url) &#123; AsyncHttpClient client = new AsyncHttpClient(); client.get(url, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int arg0, Header[] arg1, byte[] bytes) &#123; // TODO Auto-generated method stub String ipLine = null; String response = null; try &#123; //字节转字符串，并指定编码方式为GBK，否则会乱码 response = new String(bytes, &quot;GBK&quot;); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;返回的信息&quot; + response); //打印返回信息 &#125; @Override public void onFailure(int arg0, Header[] arg1, byte[] bytes, Throwable arg3) &#123; // TODO Auto-generated method stub String response = new String(bytes); System.out.println(response); &#125; &#125;); &#125;&#125; 返回信息如下： Java正则表达式取出字符串我们要从网站返回的html中提取ip地址则可以通过正则表达式来进行匹配： 提取中括号内容的规则：\[.*\]，对Http请求得到的response进行正则匹配，得到字符串：[xxx.xxx.xxx.xxx]，然后再进行字符串切割，取出ip地址。 1234567891011//匹配中括号及其之间的内容Pattern pattern = Pattern.compile(&quot;\\[.*\\]&quot;); Matcher matcher = pattern.matcher(response.toString());if (matcher.find()) &#123; ipLine = matcher.group();&#125;if(!ipLine.isEmpty())&#123; //去掉左右两边的中括号 ipLine = ipLine.substring(1, ipLine.length() - 1); &#125;System.out.println(&quot;ip地址：&quot; + ipLine); 将获取到的数据通过Handler传回到Activity：1234//将得到的ip地址传递给Activity进行显示Message msg = new Message();msg.obj = ipLine;handler.sendMessage(msg); 在Activity中调用Http请求：1234567891011121314151617181920212223242526public class MainActivity extends Activity &#123; private TextView mName, mIp; private Handler mIpHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; String res = (String) msg.obj; //取出通过Handler传递过来的字符串 System.out.println(&quot;MainActivity:&quot; + res); mIp.setText(res); //显示到界面 &#125;; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mName = (TextView) findViewById(R.id.tv_name); mIp = (TextView) findViewById(R.id.tv_ip); mName.setText(&quot;你的外网ip地址是：&quot;); //发送Http请求 String url = &quot;http://1212.ip138.com/ic.asp&quot;; IpHttpUtil.GetNetIp(mIpHandler, url); &#125;&#125; 效果展示 获取了本机的外网ip之后就可以通过这个ip来进行定位啦！欲知后事如何，请看下回分解！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python爬虫基础-正则表达式与Http请求]]></title>
      <url>%2F2016%2F07%2F03%2FPython%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8EHttp%E8%AF%B7%E6%B1%82%2F</url>
      <content type="text"><![CDATA[网络爬虫又称为网络机器人，它可以按照程序设定的规则自动抓取网页上的信息。网络是信息的海洋，但是网络中的数据是零散的、无序的且存在着冗余，如何从复杂的网页代码中提取有用的信息便是爬虫需要解决的问题。Python语法简洁，代码风骚，数据的处理能力强，比如函数参数的打包解包，列表解析，矩阵处理，非常方便，所以Python非常适合做网络爬虫。我将在这里很大家分享我的一些网络爬虫小程序，让我们一起体验爬虫带来的乐趣吧！ 基本正则表达式Python正则表达式模块：re模块 导入re模块：1import re python通过re模块提供对正则表达式的支持。 常用方法findall： 匹配所有符合规律的内容，返回包含结果的列表 Search：匹配并提取第一个符合规律的内容，返回一个正则表达式对象（object) Sub：替换符合规律的内容，返回替换后的值 常用符号，，问号与括号 点号. : 匹配任意字符，换行符\n除外 星号* ：匹配前一个字符0次或无限次 问号? ：匹配前一个字符0次或1次 贪心算法：.* 非贪心算法：.*? 括号（）：括号内的数据作为结果返回 常用情况使用findall与search从大量文本中匹配感兴趣的内容 使用sub实现换页功能 Http网络请求requests模块 Requests 是用Python语言编写，基于 urllib，采用 Apache2 Licensed 开源协议的 HTTP 库。它比 urllib 更加方便，可以节约我们大量的工作，完全满足 HTTP 测试需求。 导入requests模块1import requests 基本Get请求12345#-*- coding:utf-8 -*- //定义编码为utf-8，避免显示乱码import requestsurl = &apos;http://www.baidu.com&apos; r = requests.get(url) //使用requests模块的get方法获取百度首页的源代码print r.text 这里只举例了我们要使用的基本的get请求，如果需要了解更多的requests模块的方法请自行百度。 实例代码目的：爬取湖南农业大学官网中心位置的三张图片，并且下载下来 获取图片的源代码使用chrome打开农大官网，右键审查元素，然后点击左上角的放大镜，点击图片就会定位到图片的源代码位置，如图所示： 分析源代码，写出正则表达式分析上图可知，我们需要的部分为src=””中引号里面的url，而三张图片都是相同的格式，所以我们使用re模块的findall方法，将src的中间部分获取到即可：re.findall(‘img src=”(.?)” width=”990”‘,html.text,re.S)（1）findall即匹配所有符合正则表达式规则的内容（2）(.?)用作获取src=””的双引号中间的url并返回（3）re.S的作用是使.的作用范围包括换行符，即可以换行匹配 根据获取到的url下载图片因为我们获取到的url并不是完整的网址，所以右键上图的链接选择Open link in new tab来查看完整的网址，如下图，因此我们在下载图片时需要在url前加上http://www.hunau.edu.cn/。 代码如下：123456789101112131415161718import re //导入正则表达式的库import requests //导入第三方http库html = requests.get(&quot;http://www.hunau.edu.cn/&quot;) //通过get方法获取农大官网的网页源代码html.encoding = &apos;utf-8&apos; //设定编码方式，使能够正常显示中文# print(html.text) //也可以把网页源代码输出来看一下homedir = os.getcwd() //获取项目当前路径os.mkdir(homedir+&apos;\pic&apos;) //创建pic文件夹，用于保存图片pic_url = re.findall(&apos;img src=&quot;(.*?)&quot; width=&quot;990&quot;&apos;,html.text,re.S) //设定正则表达式，爬取图片的urli = 0for each in pic_url: //遍历pic_url print &apos;now downloading:&apos; + each pic = requests.get(&quot;http://www.hunau.edu.cn/&quot;+each) //补充完整的网址，通过get方法获取图片 fp = open(&apos;pic\\&apos; + str(i) + &apos;.jpg&apos;,&apos;wb&apos;) //在pic文件夹下创建jpg格式的文件 fp.write(pic.content) //将图片写入到工程文件夹下的pic文件夹中 fp.close() i += 1 文本爬虫，效果如下： 我们在这里只是爬取了三张图片，但是使用python来做网页爬虫真的功能很强大，大家可以试一试修改代码去爬取更多的图片。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Spinner控件之省市区（县）三级联动]]></title>
      <url>%2F2016%2F07%2F01%2FAndroid-Spinner%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%9C%81%E5%B8%82%E5%8C%BA%EF%BC%88%E5%8E%BF%EF%BC%89%E4%B8%89%E7%BA%A7%E8%81%94%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[使用Spinner控件实现省市区三级联动在很多地方都需要用到，比如用户个人信息填写、快递地址填写等场景，这是一个比较基本的功能，但是实现起来却有点麻烦，因为要加载很多的资源数组。掌握基本的省市区三级联动很有必要，当然，再加上一些酷炫的UI设计就能更nice。 布局文件添加三个Spinner控件，分别用于省、市、区（县）： 1234567891011121314151617181920212223242526272829303132&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot; &gt; &lt;Spinner android:id=&quot;@+id/spinner_province&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_weight=&quot;1.2&quot; &gt; &lt;/Spinner&gt; &lt;Spinner android:id=&quot;@+id/spinner_city&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;4dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_weight=&quot;1.2&quot; &gt; &lt;/Spinner&gt; &lt;Spinner android:id=&quot;@+id/spinner_county&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;4dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_weight=&quot;1.8&quot; &gt; &lt;/Spinner&gt;&lt;/LinearLayout&gt; 逻辑实现实现原理：为每一个Spinner添加监听，选择省份后加载该省份的市区（县）数组资源，选择市之后加载该市对应的区（县）数组资源，从而实现三级联动。 代码有点多，这里只贴了核心代码，资源数组与定义的资源数组ID数组都没有写出来了，目前博客的下载插件还没弄好，暂时无法提供下载，，如果需要源码可以联系我联系方式在主页可看到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294public class MainActivity extends Activity &#123; private Spinner mProvinceSpinner, mCitySpinner, mCountySpinner; private ArrayAdapter&lt;CharSequence&gt; mProvinceAdapter, mCityAdpater, mCountyAdapter; private int mProvinceId, mCityId; private String mProvinceName, mCityName, mCountyName; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mProvinceSpinner = (Spinner) findViewById(R.id.spinner_province); mCitySpinner = (Spinner) findViewById(R.id.spinner_city); mCountySpinner = (Spinner) findViewById(R.id.spinner_county); // 省份选择 mProvinceAdapter = ArrayAdapter.createFromResource(this, R.array.province_item, android.R.layout.simple_spinner_item); mProvinceAdapter .setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); mProvinceSpinner.setAdapter(mProvinceAdapter); mProvinceSpinner .setOnItemSelectedListener(new OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; // TODO Auto-generated method stub // 获取省的ID mProvinceId = mProvinceSpinner .getSelectedItemPosition(); // 获取省的名字 mProvinceName = mProvinceSpinner.getSelectedItem() .toString(); // 市选择 SpinnerBindResource(mCitySpinner, mCityAdpater, city[mProvinceId]); mCitySpinner .setOnItemSelectedListener(new OnItemSelectedListener() &#123; @Override public void onItemSelected( AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; // TODO Auto-generated method stub // 获取市的ID mCityId = mCitySpinner .getSelectedItemPosition(); // 获取市的名字 mCityName = mCitySpinner .getSelectedItem().toString(); // 县选择 switch (mProvinceId) &#123; case 0: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfBeiJing[mCityId]); break; case 1: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfTianJing[mCityId]); break; case 2: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHeBei[mCityId]); break; case 3: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfShanXi1[mCityId]); break; case 4: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfNeiMengGu[mCityId]); break; case 5: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfLiaoNing[mCityId]); break; case 6: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfJiLin[mCityId]); break; case 7: SpinnerBindResource( mCountySpinner, mCountyAdapter, countyOfHeiLongJiang[mCityId]); break; case 8: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfShangHai[mCityId]); break; case 9: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfJiangSu[mCityId]); break; case 10: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfZheJiang[mCityId]); break; case 11: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfAnHui[mCityId]); break; case 12: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfFuJian[mCityId]); break; case 13: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfJiangXi[mCityId]); break; case 14: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfShanDong[mCityId]); break; case 15: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHeNan[mCityId]); break; case 16: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHuBei[mCityId]); break; case 17: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHuNan[mCityId]); break; case 18: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfGuangDong[mCityId]); break; case 19: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfGuangXi[mCityId]); break; case 20: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHaiNan[mCityId]); break; case 21: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfChongQing[mCityId]); break; case 22: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfSiChuan[mCityId]); break; case 23: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfGuiZhou[mCityId]); break; case 24: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfYunNan[mCityId]); break; case 25: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfXiZang[mCityId]); break; case 26: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfShanXi2[mCityId]); break; case 27: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfGanSu[mCityId]); break; case 28: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfQingHai[mCityId]); break; case 29: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfNingXia[mCityId]); break; case 30: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfXinJiang[mCityId]); break; case 31: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHongKong[mCityId]); break; case 32: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfAoMen[mCityId]); break; case 33: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfTaiWan[mCityId]); break; default: break; &#125; mCountySpinner .setOnItemSelectedListener(new OnItemSelectedListener() &#123; @Override public void onItemSelected( AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; // TODO Auto-generated // method stub mCountyName = mCountySpinner .getSelectedItem() .toString(); Toast.makeText( MainActivity.this, &quot;你选择的是：&quot; + mProvinceName + &quot;-&quot; + mCityName + &quot;-&quot; + mCountyName, Toast.LENGTH_SHORT) .show(); &#125; @Override public void onNothingSelected( AdapterView&lt;?&gt; arg0) &#123; // TODO Auto-generated // method stub &#125; &#125;); &#125; @Override public void onNothingSelected( AdapterView&lt;?&gt; arg0) &#123; // TODO Auto-generated method stub &#125; &#125;); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; arg0) &#123; // TODO Auto-generated method stub &#125; &#125;); &#125; // 数据绑定 public void SpinnerBindResource(Spinner spinner, ArrayAdapter&lt;CharSequence&gt; adapter, int arrayId) &#123; adapter = ArrayAdapter.createFromResource(this, arrayId, android.R.layout.simple_spinner_item); adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); spinner.setAdapter(adapter); &#125;&#125; 效果展示 注：如果需要源码可以联系我，联系方式在主页可看到。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[六月，毕业季---感恩有你]]></title>
      <url>%2F2016%2F07%2F01%2F%E5%85%AD%E6%9C%88%EF%BC%8C%E6%AF%95%E4%B8%9A%E5%AD%A3-%E6%84%9F%E6%81%A9%E6%9C%89%E4%BD%A0%2F</url>
      <content type="text"><![CDATA[都说毕业遥遥无期，转眼就要各奔东西。又到毕业季，从在外实习的学长学姐回到学校，到学长学姐忙毕业论文，再到好多的送别宴，到最后的毕业典礼，到离别，这一段时间感触很多，但是一直没有记录下来，现在是时候写一写了。虽然不是我自己毕业了，但是还是有很多很多感触。毕竟是最亲的一届学长学姐，很多很亲近很熟悉的人就要离开了，说不定以后也很难再相见，也因为过完这个学期就是准大四学生了，一年后就是我们的毕业。 毕业典礼的第二天，蚯蚓学姐离开了学校，也是那天，算是大学最后一门正正规规的课，最后一次课程设计答辩也结束了。那天，答辩完，下楼就碰到了我们的助班学姐，她马上就要离校，匆匆忙忙拍了一张合照。突然觉得好伤感，学长学姐毕业，我们大学基本的课程结束，真的有很多很多要想说的话。 大一报道是一个人来的学校，从高铁站坐的农大校车到修业广场，来到这个陌生的地方，是助班学姐和一位学长帮我提行李，送我到寝室去的。一路上学姐给我各种介绍，特别清楚记得图书馆西边的小坡有几个由小树修剪成的校训：朴诚、奋勉、求实、创新，时至今日，我依然牢记。之后的军训，对于不常锻炼的我来说确实比较艰难，但是因为有大家一起，也因为有助班学长学姐的关心，我才坚持下来。不能说军训有多么多么的值得怀恋，毕竟我不是特别喜欢军训的人，但是记得有句话：所有的事情都有他存在的意义。或许也是军训这段时间让给我们懂得吃苦耐劳，结奋斗吧！军训结束，班级聚餐，大家各种喝酒，也于是大家慢慢熟悉起来。 国庆之后，随着大学正式开课、学生会招新等，我的大学生活也真正开始了。先说说组织部吧，我爱了三年的部门。我的助班蚯蚓学姐是我的部长，在这个部门她教给我很多的东西，最重要的应该是为人处世，有些东西真的就是耳濡目染，慢慢的会领悟很多。组织部的常规活动就是民主生活会了，说不出什么特别的地方，每两周一次的活动，组织部是作为检查打分的角色出现的，一开始还很有兴致，但是慢慢的也就觉得没什么意思了，然后还有一些比如收团费、团干培训等等事情，其实很多事情都是部长副部帮我们做了，只怪学姐们太能干，哈哈。最开心的当然还是部长带我们出去浪吧，去吃饭唱歌，记得部门最后一次是在市里的，在湘江边吃的饭，然后去唱了晚晚场，很开心，也很难忘。大一下学期，从懵懂的小屁孩也开始懂得了一些事情，一届学生会结束，昔日一起做事一起玩耍的小伙伴以后就很难有这样的机会了。 生活部的话，我的部长虎哥，副部诚哥、兰姐都对我很好。当干事的一年里，也是没什么特别的地方，每周一早上去早检，也就是叫学长学姐起床，然后检查宿舍卫生，还是很佩服自己大一的时候，也是从那时候培养的一种精神吧，冬天的早检是很痛苦的，天还没亮就要出发，但是不管多么冷，我都可以坚持从芷兰到金岸去早检。一直觉得生活部还是挺温馨的，有一个热心的部长，然后人也很多，经常能聚聚餐，喝酒也算是常态了，也有喝醉的时候，但是还是很开心，毕竟大家像一个温馨的大家庭。虽然可能到现在很多人都已经不熟悉了，但是至少大家以前都在生活部待过，都有过这段美好的回忆。 大一下学期，在图书馆大成厅，实验室招新宣讲会。学院几大实验室的指导老师都来宣传自己的实验室，曾炼成老师结合之前实验室的一些作品宣传了电子设计创新实验室，就在那时，我觉得这就是我要去的地方。现在回想起来，其实很多事情真的就是一种缘分，说不上什么很特别的理由。会后，我给曾老师打了电话表达了我想要加入电子设计创新实验室的想法，然后他让我找陈刚老师，再然后陈老师让我去找欧超学长，就这样，没有面试没有考核就这样进来啦。进来以后才知道，原来这个实验室已经很久没人管了，但是还是有一批学长学姐在这里学技术。虽然和想象的有区别也有点失望，但是欧超学长的热情与真诚打动了我，也是他带着我从零开始学习单片机，带我去图书馆找资料，给我拷视频资料，拿单片机开发板给我用，后来还给了我实验室的钥匙。经过一段时间的学习，我对单片机已经有了大体的一些了解，也开始真正了解大学应该学些什么。现在回想起来，其实当时的这一步对我来说真的非常重要，没有这些经历，我也不会这么快懂得要学习什么，怎么学习。 大二期间，担任班长、院学生会组织部副部长。其实，在开始的竞选中发生了很多不愉快的事情，但是还好最后的结果大家都还算满意。这一年里，班长、院学生会组织部副部长两个职务，也是对自己全新的挑战吧。作为班长，我想尽各种办法让班上同学能够认真学习专业知识，积极联系老师，积极开展导师制，积极完成学工老师交代的任务，积极带领班上同学搞活动、搞学习，一年下来，感觉很多事情都白做了，自己收获的很多，但是班级并没有很大的改观。其实，真的，大学关键还是靠自己，自己不动，别人怎么给你想办法都没用。作为组织部的副部长，积极配合我的部长的工作，带领几个小干事一起干活。天才第一步，进我组织部，这是蚯蚓学姐为组织部想的宣传语，沿用至今。很庆幸能够在组织部遇到这群人，我的领导善解人意、办事能力强，几位小干事也都很听话，感觉就是一个温馨的大家庭。现在看到他们越来越好我也是很开心的，毕竟我们永远是一家人。很遗憾的是我们部门在这个毕业季没能和我们上届的部长，也就是蚯蚓学姐吃一顿饭了，学姐真的是太忙了，档期安排的满满的，到最后也没找到机会一起。 也是在大二，我慢慢的开始适应实验室的环境，它没有图书馆压抑的气氛，在这里我们动手做实验，学习电子设计方面的知识，思维可以放得很开，网络也很方便，可以迅速的查阅资料，在这里我获得了前所未有的信息量，很大程度上开阔了视野。欧超、杨勇锋等几位学长策划着建立一个电子协会，也开始带着手实验室的招新工作。这一年，实验室招了30个13级学生，几位学长负责每周为我们讲课，因为这个平台我和后来一起带实验室和协会的搭档尹远和张涛开始熟知。也是这一年实验室获得了不错的发展，有了电子协会这个宣传的平台，实验室也开始被学弟学妹们所了解。学长们乐于奉献的精神也给我很大的影响，也是我接手实验室之后一直努力想把实验室建设好的原因吧，希望这种精神能够延续下去。同时，由于大二的数据结构课程，卧铺有幸认识了我的恩师戴教授，并开始在他的指导下接触科研。他是一个个踏踏实实搞教学和科研的人，他认真严谨的态度一直感染着我，也是他带着我写论文、学安卓、玩树莓派、报科创项目，能够耐心的听我讲我最新了解到的知识，和我一起聊技术方面的事情，也时常给我推荐各种书籍和资料。其实，让我最感动的还是他的倾听，因为在大学里很多教授都是很难见到的，但是每次他都能耐心的听我讲完并给我一些建议，在技术上算是一个知己吧。很多次在他办公室看到他在学习新的知识，也会看到他为了备课经常下载更多的资料以及自己看慕课来完善自己的课堂，这些在我看来都是很难得的。他的不断学习的意识以及认真严谨的学术态度让我很佩服，所以我也愿意一直跟着他学习，希望以后能成为像他这样优秀的人。 大三开始，真正接手实验室。说实话，一开始真的很无助，以前都是超哥和锋哥担当起很多的责任，实验室、协会上课都是他们在负责，但是他们已经去深圳参加嵌入式的培训了，剩下维哥也在学校准备找工作去实习了，不知道怎么办。不过，还好，上天总是眷顾努力的人们，就在这时候匡老师来了，她要来带一带实验室，匡老师的热情与真诚让我看到了希望，之后的很多事情很多安排都是她在做，包括实验室的规划、指导老师的调动等。于是，我也有了信心，在没有什么带过学弟学妹的经验的情况下，我平时积极学习，每周都积极备课，希望大家来了就能有收获，也邀请了维哥、能神来给大家讲课，总的来说，虽然我讲课确实讲得不好，讲得快，没有意识到大家是否听懂，但是至少在我带的这段时间，很多安排都在井井有条的进行，自我感觉还是很有希望的，实验室的学习气氛还是获得了其他老师的认可，也是因为大三上学期的积累，大三下学期的蓝桥杯才能取得不错的成绩。为了蓝桥杯，我确实付出了很多，画板子、调板子、再到安排大家焊接，已经之后各个模块的熟悉，确实花了很多时间。当初，毫无保留的把自己学会的与大家分享，也是希望大家都能在比赛中获得好的成绩。还好，我的付出也算有了回报，努力的人们都取得了不错的成绩，我自己也拿了省一等奖，获得去北京参加决赛的机会。去北京的经历已经很详细的记录在另一篇博客了，这里就略过吧。这其中也还是很感谢实验室各位老师的辛勤付出吧，特别是匡老师和陈老师，一个负责组织，一个负责技术，也挺好的啦！有时候，回想起来，这一段路有心酸、有泪水也有感动吧，当你一个人默默付出的时候，别人可能并不知道，但是在收获的时候你一定是最幸福的。 最近想尽办法让自己静下来好好复习，也买了很多书准备看看。这学期真的忙了很多的事情，一直想参加更多的比赛，想拿更多的奖，但是到头来发现过程中的收获比结果重要很多，虽然在有时候我们不得不拿出些奖励来获得别人的认可，但是我现在更希望自己具备真正的实力。不积跬步，无以至千里，不积小流，无以成江海，与其参加更多意义并不大的比赛，还不如静下来好好学知识学技术，这样不管对于找工作还是考研都是很有帮助的。到现在，很多事情都不想去做了，只想安安静静的复习考研，所以7月在武汉的的智能互联大学分赛区决赛我也不准备去了。为了让自己能够静下来好好复习我也确实放弃了很多东西，有时候也会觉得比较无奈吧。如果让我说大学三年来最大的遗憾是什么，我认为应该是我在大学没有找到一个好的团队，不是说怪队友怎么怎么，而是真的没有几个一起并肩奋斗的人，很多时候都是自己一个人在战斗，好几次比赛都是自己找的人，别人还不太乐意，团队没有共同的明确目标那很难走下去，有时候很绝望的是你想去做一个项目，别人却总是有各种事情，所以到现在我也慢慢明白了，确实大家都有各自的事情要忙，没有共同的目标又何苦要求别人一起来呢，这应该是我最近认识的最深刻的问题了。我是一个常常喜欢反思自己、思考问题的人，只是很多时候我并不喜欢表达出来，在别人看来这或许是我的缺点吧，但是有些想法确实不能说。 倒是还是很担心实验室，毕竟大家花了那么多心思才让实验室有一点起色，我不想让这一点点希望就这样没了，现在的情况让我很担忧，老师没时间来，学生也忙自己的事情，不主动，大概很久都没有听到实验室的动静了。有时候就是有那么一点点好强，总是去和其他实验室比较，看到这样的现状感觉很不爽，但是自己又不能改变什么。这两年真的把实验室当成了自己大学里的一个家了，在这里的成长与感动让我觉得大学过得很充实也很踏实，虽然不能在这里待一辈子，但是还是希望这个实验室能够越来越好。六月就这样结束了，大学前三年也就这样结束了，七月已经到来，现在的我只想好好复习准备考研或者找份好工作啦。 大学三年，只因有你们，我的大学生活才不平凡，感恩有你。虽然对这个地方还是有很多的不满，但是自己也在这里成长了三年，再多的抱怨也埋在心底好了。毕竟，我们的成长更多的是靠自己。大四，新的未来。学长学姐都毕业了，我们已经成为最老的老油条，慢慢的自己也获得了成长，但是每一次与学长学姐交流，都可以有新的收获，不管是对未来的一些了解，还是对自己现状的一些反思，我觉得虽然可能就是一次简单的聊天，但也可以对你产生一些无形的影响。最后，祝各位毕业的学长学姐前程似锦，以后有机会再相聚！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android获取yeelink云端数据]]></title>
      <url>%2F2016%2F06%2F29%2FAndroid%E8%8E%B7%E5%8F%96yeelink%E4%BA%91%E7%AB%AF%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[虽然前段时间的项目我参与了硬件部分的调试，但是我主要还是负责Android客户端的开发。yeelink是一个物联网云平台，我们可以采用单片机采集数据，然后将数据上传到yeelink，再通过Android客户端去云端获取数据，以便实现远程监测。这篇博客主要讲解如何从yeelink云端获取单片机上传到yeelink云端的数据。 查阅yeelink开发者文档要想查看云端数据，需使用GET方法，对http://api.yeelink.net/v1.0/device//sensor//datapoint/进行请求，对该URL的请求返回指定key的datapoint, 若未指定key, 则返回该sensor的最新数据。 新建并配置工程添加网络访问权限在AndroidManifest.xml文件中加入如下： 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 编写布局文件添加一个Button用于获取数据，添加一个TextView用于显示获取到的数据。 网络请求库android-async-http的使用android-async-http是一个强大的网络请求库，这个网络请求库是基于Apache HttpClient库之上的一个异步网络请求处理库，网络处理均基于Android的非UI线程，通过回调方法处理请求结果。 jar包下载点击此处可以下载jar包 将jar包添加到工程将jar包复制到lib文件夹下，并右键该jar包，BuildPath–Add to Build Path 编写代码新建一个Http工具类CloudHttpUtil,再新建一个静态方法GetCloudData()，该方法需要两个参数，一个是进行消息传递的Handler，另一个是Http请求的url地址，具体代码如下： 12345678910111213141516171819202122232425262728293031public class CloudHttpUtil &#123;public static void GetCloudData(final Handler handler, String url) &#123; AsyncHttpClient client = new AsyncHttpClient(); //添加Http请求的头部信息 client.addHeader(&quot;U-ApiKey&quot;, &quot;你的API密钥&quot;); //使用get方法获取数据 client.get(url, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int i, Header[] headers, byte[] bytes) &#123; // TODO Auto-generated method stub String response = new String(bytes); Message msg = new Message(); msg.obj = response; //请求成功后，将返回值通过消息传递到Activity实现数据显示 handler.sendMessage(msg); &#125; @Override public void onFailure(int i, Header[] headers, byte[] bytes, Throwable throwable) &#123; // TODO Auto-generated method stub String response = new String(bytes); //请求不成功时将错误信息打印 System.out.println(response); &#125; &#125;); &#125;&#125; 获取云端数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MainActivity extends ActionBarActivity &#123; private TextView tv_clound_data; private Button btn_get_data; private Handler cloudHandler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; String jsonData = (String) msg.obj; //成功获取数据后，将数据显示在界面上 tv_clound_data.setText(jsonData); //还可以将获得的JSON数据进行解析，以便使用适配器将数据显示在列表等其他地方 JSONArray ja; try &#123; ja = new JSONArray(jsonData); for (int i = 0; i &lt; ja.length(); i++) &#123; JSONObject js = ja.getJSONObject(i); String time = js.getString(&quot;timestamp&quot;); String value = js.getString(&quot;value&quot;); System.out.println(time + value); &#125; &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化控件 tv_clound_data = (TextView) findViewById(R.id.tv_clound_data); btn_get_data = (Button) findViewById(R.id.btn_get_data); //设置按钮监听事件 btn_get_data.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub //不带参数的请求 //String url = &quot;http://api.yeelink.net/v1.0/device/你的设备号/sensor/你的传感器号/datapoint&quot;; //带参数的请求 String url = &quot;http://api.yeelink.net/v1.0/device/你的设备号/sensor/你的传感器号.json?start=2016-05-01T14:01:46&amp;end=2016-06-24T10:01:40&amp;interval=1&quot;; //发送http请求 CloudHttpUtil.GetCloudData(cloudHandler, url); &#125; &#125;); &#125;&#125; 测试效果图不带参数的请求不带参数时将返回最新一个数据点的数据： 带参数的请求带参数时将返回参数指定时间段内的数据： 注：你的云端传感器得有数据才能获取啊，没有数据的话可以在yeelink官网手动添加几个数据，他的API文档中编辑数据，然后有个在线调试，可以模拟Http请求进行数据点的创建。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单片机+ESP8266上传数据到yeelink]]></title>
      <url>%2F2016%2F06%2F29%2F%E5%8D%95%E7%89%87%E6%9C%BA-ESP8266%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE%E5%88%B0yeelink%2F</url>
      <content type="text"><![CDATA[前段时间在做一个物联网的项目，需要将采集到的数据通过STM32单片机传送到yeelink云端，虽然之前学过51单片机但是因为ESP8266也是第一次使用，而且STM32没学过，对底层操作通信协议也不清楚，所以调试了很才成功了，现在有时间就把之前的思路理顺一下，希望对初学者有帮助。 串口直接调试一开始是直接和项目成员一起通过STM32的串口发送命令来控制ESP8266进行数据发送，但是一直没成功，也不知道哪里出错了，也是想到可以直接将ESP8266通过单片机的转串口模块连接到电脑，用电脑的串口助手直接发命令给ESP8266进行调试，这样调试成功之后再把STM32加进来就容易多啦。 熟悉操作命令查阅ESP8266的相关资料，以及yeelink的http请求格式，将命令准备在串口调试助手，如下图： 注意选择发送新行，这样串口助手将自动在每一行后面加上回车换行符，具体原因在后面解释。然后在http请求头最后要发送一个空行，在发送请求体，即数据。否则数据上传失败。 硬件连接与设置此处需要借助一个USB转串口的模块，也可以直接用单片机开发板上的转串口模块，将ESP8266的Txd，Rxd引脚与单片机开发板的串口输出引脚反接(即Txd连Rxd，Rxd连Txd)，将Vcc接单片机开发板的Vcc或5V，GND接开发板的GND，然后在电脑上设置串口调试助手波特率为：11520，再按顺序一条一条的发送以下命令，每条命令都会有相应的回应： ESP8266控制指令（1）设置WIFI模式AT+CWMODE=1 （2）重启生效AT+RST （3）连接无线路由器AT+CWJAP=”你的wifi账号”,”你的wifi密码” （4）查询模块IPAT+CIFSR （5）与服务器建立TCP连接AT+CIPSTART=”TCP”,”www.yeelink.net”,80 （6）开启透传模式AT+CIPMODE=1 （7）开始透传AT+CIPSEND 开始透传之后串口助手将显示‘&gt;’符号，已经开启透传模式，表示可以传输数据，如下图： Http请求格式Http请求的格式可以参照yeelink的API文档中的在线调试，如下图： 在线调试发送Http请求之后下面会显示发送Http请求的格式，可直接复制过来用。 进入透传模式之后开始发送http请求获取数据，将以下8条命令一次发送完成，按顺序将命令一个个点击发送完，不要点一个等一下，这个必须将所有命令发送完才会有回应 （1）POST /v1.0/device/你的设备号/sensor/你的传感器号/datapoints HTTP/1.1 （2）User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:9.0.1) Gecko/20100101 Firefox/9.0.1 （3）Host: api.yeelink.net （4）Accept: / （5）Content-Length: 15 （6）U-ApiKey: 这里填写你在yeelink申请的密钥 （7）发送一个空行 （8）{“value”:34.66} 发送成功将获得服务器的200，OK返回。 其实，在这个过程中也遇到了很多坑： （1）本来每发一条命令之后都要加上回车换行表示结束的，一开始没注意串口助手已经勾选发送新行，即自动为每一行添加回车换行，于是每条命令之后都有两个回车换行，就悲剧了。一定要注意你是否勾选上串口调试助手的回车换行。 （2）建议大家还是勾选上串口调试助手的发送新行，一方面不用自己去写回车换行符，另一方面也省去了考虑加转义字符的麻烦。亲测，串口助手还不一定可以识别你自己写的回车换行符。 （3）Http请求一定是一次性发送完才会有响应，否则服务器无法判断你的请求是否发送完。 单片机控制ESP8266以上的测试成功以后，应该怎么发送命令，怎么发送Http请求就已经很清楚了，将这些命令和请求嵌入到STM32的代码中，然后用STM32的串口通过printf函数进行输出，便可以很方便的实现我们需要的功能。当然，此时需要注意为每一行命令加上回车换行符，以及转义字符的处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//串口3,printf 函数//确保一次发送数据不超过USART3_MAX_SEND_LEN字节void u3_printf(char* fmt,...) &#123; u16 i,j; va_list ap; va_start(ap,fmt); vsprintf((char*)USART3_TX_BUF,fmt,ap); va_end(ap); i=strlen((const char*)USART3_TX_BUF); //此次发送数据的长度 for(j=0;j&lt;i;j++) //循环发送数据 &#123; //循环发送,直到发送完毕 while(USART_GetFlagStatus(USART3,USART_FLAG_TC)==RESET); USART_SendData(USART3,USART3_TX_BUF[j]); &#125; &#125;/*ESP8266连接网络与发送Http请求的部分代码*///设置WIFI模式u3_printf(&quot;AT+CWMODE=1\r\n&quot;);delay_ms(1000);//重启生效u3_printf(&quot;AT+RST\r\n&quot;);delay_ms(1000);//连接无线路由器，需延时等待连接成功u3_printf(&quot;AT+CWJAP=\&quot;你的wifi账号\&quot;,\&quot;你的wifi密码\&quot;\r\n&quot;); delay_ms(1000);delay_ms(1000);delay_ms(1000);delay_ms(1000);delay_ms(1000);delay_ms(1000);//此处省略了查看ip地址//与服务器建立TCP连接u3_printf(&quot;AT+CIPSTART=\&quot;TCP\&quot;,\&quot;www.yeelink.net\&quot;,80\r\n&quot;);delay_ms(1000);delay_ms(1000);//开启透传模式u3_printf(&quot;AT+CIPMODE=1\r\n&quot;);delay_ms(1000);//开始透传u3_printf(&quot;AT+CIPSEND\r\n&quot;);delay_ms(10);//开始发生Http请求u3_printf(&quot;POST /v1.0/device/你的设备号/sensor/你的传感器号/datapoints HTTP/1.1\r\n&quot;);u3_printf(&quot;Host: api.yeelink.net\r\n&quot;);u3_printf(&quot;Accept: */*\r\n&quot;);u3_printf(&quot;U-ApiKey: 你在yeelink申请的密钥\r\n&quot;);u3_printf(&quot;Content-Length: 15\r\n&quot;);//设置短连接，连接双方都会要求在处理请求后关闭它们的TCP连接u3_printf(&quot;Connection: close\r\n&quot;);u3_printf(&quot;\r\n&quot;); //发送数据u3_printf(&quot;&#123;\&quot;value\&quot;:34.66&#125;); delay_ms(1000);//关闭透传u3_printf(&quot;+++&quot;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android开发之eclipse快捷操作]]></title>
      <url>%2F2016%2F06%2F18%2FAndroid%E5%BC%80%E5%8F%91%E4%B9%8Beclipse%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[本文总结了一些eclipse常用的快捷键以及快捷操作的小技巧，熟悉使用这些操作对于提高开发效率将会很有帮助。 eclipse快速注释（1）行注释： ctrl+/ （2）取消行注释： 再按一次ctrl+/ （3）块注释: ctrl+shift+/ （4）取消块注释： ctrl+shift+\ eclipse快速编辑（1）快速删除当前行： ctrl+D （2）代码编辑窗口缩放： ctrl+M，再按一次则可以恢复 （3）快速切换代码编辑窗口： ctrl+F6 （4）大小写切换： Ctrl+Shift+Y 大写变小写 Ctrl+Shift+X 小写变大写 （5）复制行： Ctrl+Alt+向上 复制当前行到上一行 Ctrl+Alt+向下 复制当前行到下一行 （6）移动行： Alt+向下 快速提取某行到下边指定位置 Alt+向上 快速提取某行到上边指定位置 （7）下一个错误及快速修改： Ctrl+.及Ctrl+1 （8）快速跳转到申明： F3 （9）重命名： F2 （10）回到最后一次编辑的地方： ctrl+Q （11）快速查看当前类的方法或某个特定方法： ctrl+O （12）配置行号： 点击菜单栏的Windows—&gt;preference—&gt;General—&gt;Editors—&gt;Text Editors将show line numbers选上 （13）增强代码提示功能： 点击菜单栏的Windows—&gt;preference—&gt;Java—&gt;Editors—&gt;Content Assist将Auto activation atriggers for java后面的“.”换成“abcdefghijklmnopqrstuvwxyz.” 快速生成（1）快速复写超类的方法： 点击右键—&gt;source—&gt;Generate Constructors from Superclass （2）批量生成get、set方法： 点击右键—&gt;source—&gt;Generate Getters and Setters （3）快速生成构造方法： 点击右键—&gt;source—&gt;Generate Constructor using Fields （4）使用代码模板（需选中代码）： Alt+Shift+Z （5）快速导入包： Ctrl+Shift+O （5）快速添加javadoc注释： Ctrl+Shift+J 美化代码（1）快速格式化代码： Ctrl+Shift+F （2）成员排序： 选择菜单栏source—&gt;Sort Members，使变量名、方法名或者类名按首字母大小排序 （3）整理导入的包： 选择菜单栏Source—&gt;Organize Imports 或者使用Ctrl+Shift+O,可以快速导入缺少的包以及删除不需要的包 代码重构(Refactor)快速打开Refactor菜单：Alt+shift+T （1）Rename 选中变量或者方法名等需要更改的名字，点击菜单栏Refactor——&gt;Rename（或者使用快捷键alt+shift+R）即可实现代码中某一变量、方法或者类名进行全部重命名替换 （2）Move 点击菜单栏Refactor—&gt;Move（或者使用快捷键alt+shift+V），将该java文件移动到其他的包 （3）修改方法结构 点击菜单栏Refactor—&gt;Change Method Signature（或者使用快捷键alt+shift+C），不管有多少个函数调用了这个方法，修改一次就能全部搞定 （4）抽取方法 选中需要单独生成方法的代码，点击菜单栏（或者右键）Refactor—&gt;Extract Method（或者使用快捷键alt+shift+M）,这是重构里面最常用的方法之一 （5）抽取本地变量 选中数字或字符串，点击菜单栏（或者右键）Refactor—&gt;Extract Local Variable（或者使用快捷键alt+shift+L）， 可以直接把数字和字符串抽取成一个变量 （6）撤销重构： alt+shift+Z或者ctrl+Z]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树莓派+motion实现局域网简单监控]]></title>
      <url>%2F2016%2F06%2F14%2F%E6%A0%91%E8%8E%93%E6%B4%BE-motion%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E7%AE%80%E5%8D%95%E7%9B%91%E6%8E%A7%2F</url>
      <content type="text"><![CDATA[检查USB摄像头主要检查摄像头是否被树莓派检测到（同博主上一篇树莓派的博客） 如果没有你的摄像头的信息，那么有可能你的树莓派的电源无法供应足够的电力给你的摄像头。这时你可以给你的摄像头用独立的电源线，比如有源USB hub，并重新输入lsusb命令查看。如果摄像头还是不能被识别，我们只有建议你购买其他树莓派支持的摄像头了。 配置motion注意：本文以Raspbian系统为例 安装motion输入命令： 1sudo apt-get install motion 配置motion daemon 守护进程输入命令编辑motion： 1sudo nano /etc/default/motion 把里面的no修改成yes，让他可以一直在后台运行： 1start_motion_daemon=yes 修改motion的配置文件（1）输入命令 1sudo vim /etc/motion/motion.conf （2）修改配置文件 将第11行的daemon off 改成daemon on，如下图： 该文件很长，需要一直往下翻，直到464行你才看到端口号8081，我们通过这个端口来读取视频数据，这里无需修改！如下图： 然后到第477行将stream_localhost on改成off，即关闭 localhost 的限制，如下图： 当然，你也可以设定图片的分辨率，在第90行进行修改： 最后，vim编辑器下按esc然后输入：wq，即保存退出。 配置启动（1）输入下面命令启动服务： 1sudo service motion start （2）输入以下命令开启motion： 1sudo motion 查看效果打开浏览器，输入http://树莓派IP:8081即可查看拍到的图像，如下图： 需要注意的问题浏览器的问题经过测试，Google浏览器和火狐浏览器可以访问到图像，IE、Microsoft Edge和360都不显示图像，而是提示下载，一直下载，其他的没有测试。 局域网限制之前看到别人的教程写的是外网也可以访问，实际上如果你没有配置你的树莓派成为服务器的话，你的树莓派的ip地址都是私有地址，外网无法访问，只能在局域网内部使用。 摄像头的问题树莓派供电不足也会影响视频质量，就像我上面的视频不是很清楚，我是直接用笔记本的USB供电的，一般来说笔记本USB口电流一般为500mA，所以如果需要视频清晰的话建议使用移动电源进行供电，或者使用有源USB hub。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[蓝桥杯决赛之行---北京]]></title>
      <url>%2F2016%2F06%2F10%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%86%B3%E8%B5%9B%E4%B9%8B%E8%A1%8C-%E5%8C%97%E4%BA%AC%2F</url>
      <content type="text"><![CDATA[端午节都过去了，和室友出去浪了一天，回来已经很累了，但是突然想到这一篇博客还没有写完，从北京回来也将近10天了，我估计如果再不写以后就不会写了。这段时间断断续续写了一点，但是写着写着又觉得自己在记流水账，然后就不想写下去了，感觉写作能力是越来越差了。但是，我觉得这一篇我必须得完成它，毕竟这次去北京参加蓝桥杯决赛自己收获很多，也有很多可以讲述的故事，这样的总结不管是对自己来说还是对看这篇博客的人来说都会有意义。有兴趣就听我唠叨唠叨吧~ 5月26日晚，怀着对帝都的期待与蓝桥杯决赛的担忧踏上了去往北京的火车。还好是卧铺，睡一晚就可以到北京。蓝桥杯决赛，其实并没有准备多久。现在想起来原因很多，忙碌的五月，似乎好多计划都被打乱，因为软考，因为期中考，还因为很多要去争取的东西，准备比赛的心思也没有了，省赛时大家一起备赛的氛围也没了，实验室被做毕业设计的学长学姐霸占，自己只能在寝室写写代码，积极性并不高。所以，只在最后几天好好复习了一下基本的模块，然后准备了一些资料到火车上看，但是因为是和其他实验室的小伙伴一起去，所以并不好自己一个人看代码，而是听带队老师讲讲故事，和他们一起玩玩，熄灯后就各自睡了，并没有做任何的复习。 5月27日早，到达北京西站，指导老师已经提前订好房间，我们准备坐地铁去住的地方，在地铁站，10几条地铁线路将北京完全覆盖，早高峰地铁排队的场景让我感叹大城市的不易。很幸运的是出了地铁站便看到北京展览馆，而且正好第二十届中国国际软件博览会，指导老师提议要去看一看，领了免费的入场券，然后回宾馆放行李，休整了一会就去看博览会了。 不愧是中国国际软件博览会，我国的各个省都有展区，还有韩国日本的展区。比较大的馆主要还是北上广、成都、南京这些地方的，毕竟产业链比较完善。很多互联网公司都展示了他们的产品，也提供了很多宣传资料。在这次博览会中，我们不仅看到了很多新的科技产品，比如能和人对话的机器人、VR眼镜、无人机等，而且还看到了自己之前了解过的一些项目，之前想过用树莓派去做停车场管理系统，因为在国内树莓派的资源相对较少，而比较成功的例子恰好是北邮的几个学生做的基于树莓派和微信的停车场视频监控系统，在这次展览中也看到好几家公司都有在做停车场管理系统，只是侧重的方面不太相同，也和展台的工作人员有过交流，都还做得比较成功。也看到了做农产品电商的公司，之前自己也弄过一个掌上农资宝的项目，想着去做一个卖农资的安卓App，当时因为自己才刚刚开始学安卓，所以也只是参加了两个比赛，并没有真正去做。在广州馆看到了机智云，一家做物联网云平台的公司，之前根本不知道，因为自己一直用的青岛的一家物联网云平台：yeelink，觉得还挺不错的，这次的发现又让我多了一个选择。在香港馆看到了做儿童编程玩具的，与工作人员交流之中了解到，他们的产品就是用的esp8266无线模块连接手机来进行控制，因为实验室也有这个模块，所以觉得这个东西还挺不错的，值得以后去玩一下。还在安徽馆看到了科大讯飞的展台，因为之前用过科大讯飞的语音SDK，所以感觉很熟悉。总之，这次博览会让我对这个行业有了更多的了解，通过与工作人员交流，我对于这些技术也有了新的认识，也开阔了视野。有些技术能力可能我们已经具备了，只是缺少创新的思想，没有去尝试。 中午带队老师带我们去吃了自助，到北京的第一顿饭，吃的很饱也很爽。下午休息了一下就到北方工业大学去看考场了，在百度地图的指引下一路公交到达考点花了将近两个小时，确实有点远，计划第二天早上要很早起来，然后坐地铁过去，毕竟怕迟到。北方工业大学博远楼是新建不久的大楼，里面的设备都很好，大教室有100堕胎电脑，好几个大的显示屏，很是羡慕，毕竟帝都的学校啊，比我们的条件真的好很多。到赛场熟悉了比赛要使用的电脑之后我们便赶回宾馆与带队老师汇合。吃过晚饭后去了北大，虽然晚上不太看得清，但是还是有几点很不一样的感受，第一是北大的自行车特别多，几乎所有教学楼旁边都停满了自行车，然而在我们学校这样的场景是看不到的，这或许也是一种氛围吧，快节奏的校园生活。第二是课堂氛围好，观察了课堂最后几排的同学，基本没有在玩手机的，都在认真听讲，这和我们学校也是天然之别。第三是北大学生的气质都不一样，特别是女生，有一种肃然起敬的感觉。在未名湖畔，听带队老师给我们介绍北大，也是很不错的经历了。晚上回到宾馆已经10点，突然发现奔波了一天，感觉很累了，但是想到明天的比赛还剩很紧张，本来来北京之前准备了一些资料，准备在火车上或者到宾馆再认真看看，但是一直没有机会。现在终于可以再好好准备一下明天的比赛了，于是又和队友一起认真的写代码，记代码，熟悉自己还不熟练的模块，差不多到12点，累得不行了，就休息了。 5月28日早，因为住的地方离考点：北方工业大学有点远，坐地铁转公交加起来差不多要一个小时，所以我们早早的就出发了，到那里时后到处找卖早餐的地方，很是着急，匆匆吃完早餐就去考场了。一进大楼就有武警保守，突然觉得有点紧张了，排队进场然后抽取座位号，40号，说实话，不太喜欢的一个数字，但是当时也没想太多。找到座位后，我发现很多人已经开始在写代码了，于是我也里面开始建工程，把基本的代码框架搭好，等到老师发布题目时我已经能够让数码管显示数字了，这一点很重要，争取了一点点时间。然后，突然被告知这个机房的Altium Designer由于没有破解，很多电脑都用不了，所以只能用protel99 se，但是我从来都没用过，所以我当时就很慌了，打开protel 99后发现是英文版的，我连元器件都找不到！琢磨了几分钟后我放弃了，决定先把题目要求的功能实现，毕竟电路图只有十分。这次的题目相比省赛的题目难多了，时间一样，但是要求更多，逻辑更复杂。折腾了好一会，遇到不少的问题，发现原本熟悉的矩阵键盘也不灵了，最后赛点老师提示大家由于题目要测555产生的波的频率和周期，占用了P3.4口，所以会影响矩阵键盘，希望大家明白这不是板子的问题，我突然明白了，然后开始根据题目需求改矩阵键盘的检测代码。写着写着，又发现竞赛给的驱动代码也有问题，这个问题是我们在准备省赛的时候就发现了的，当时认真的解决了这个问题，但是我始终坚信竞赛的时候给的驱动代码是不会有问题的，于是决赛的备赛阶段我就没怎么注意这个问题。AD得到的数据一直在跳，到最后也没有稳定下来，但是AD是可以用的。后来发现时间越来越紧了，也是决定改变策略，把思路理清，把基本的界面和功能先实现，更深入的要求如果没时间就不做了。 5月28日下午，比赛就这样结束了，或许一切结束的太快，突然觉得如释重负，又觉得这次要拿奖很悬。仔细想了想，反正明天就出结果，今天得好好玩一玩，然后直接去了天安门城楼。公交转地铁，一路都很顺利，不得不感慨帝都的路面交通经常很堵，但是地铁真的是很方便。天安门城楼和天安门广场到处都有安保，进入天安门区域还有安检。以前只能在电视里看到的地方，现在自己终于有机会亲临现场感受祖国的伟大。4点过3分到达故宫售票点，却发现4点后不再售票，这也许是这次北京之行的一大遗憾了吧。看了中山公园、天安门广场、人民英雄纪念碑、人民大会堂、毛主席纪念堂等，具体的就不在这里一一描述了，感觉已经有点记流水账了。 5月28日晚上，先描述一下行程吧，因为指导老师以前的几个学生在北京工作，听说老师来北京了，特意来请老师吃饭，顺便把我们也带上了，吃完还带我们到鸟巢、水立方、奥林匹克森林公园附近转了转。然后谈谈感想，我是觉得很有幸能够见到几位07级的学长，几位学长以前是农大的，考了北邮、北航这样的学校的研究生，他们现在在阿里、360、百度这样的公司工作，以前都是从实验室出来的，他们都觉得是实验室的老师教会了他们很多，也是在实验室他们得到了很多锻炼。其中有一位学长本科是学经济学的，因为兴趣加入了我们院的ACM实验室，后来考上了北邮的研究生，现在在阿里做搜索方面的工作，这让我很佩服，然后我去看了他的博客，他从11年开始写，一直到现在都还有更新。与几位学长交流了很多，了解到360竟然有专门的爬虫部门，在阿里的学长说我们在大学能够做一个不错的搜索引擎项目就很不错了。交流之中，我也明白了做技术确定比较辛苦，坚持去做一件事情也确实不容易，但是如果能深入下去还是会找到不一样的快乐。 5月29日，长城一日游，也是一次充满故事的旅行吧！未完待续，有时间继续更新继续修改。 因为是第一次去北京，所以本来就很特殊。 特殊到我可以开心好久好久！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树莓派+USB摄像头+yeelink实现云监控]]></title>
      <url>%2F2016%2F06%2F10%2F%E6%A0%91%E8%8E%93%E6%B4%BE-USB%E6%91%84%E5%83%8F%E5%A4%B4-yeelink%E5%AE%9E%E7%8E%B0%E4%BA%91%E7%9B%91%E6%8E%A7%2F</url>
      <content type="text"><![CDATA[配置USB摄像头检查摄像头是否被树莓派检测到输入命令： 1$ lsusb 查看输出信息 如上图我们可以看到camera的信息，如果没有你的摄像头的信息，那么有可能你的树莓派的电源无法供应足够的电力给你的摄像头。这时你可以给你的摄像头用独立的电源线，比如有源USB hub，并重新输入lsusb命令查看。如果摄像头还是不能被识别，我们只有建议你购买其他树莓派支持的摄像头了。 安装fswebcam要想拍摄照片，你要安装fswebcam，这是一款小型摄像头程序。你可以直接通过Raspbian的仓库来安装fswebcam。 输入命令： 1sudo apt-get install fswebcam 配置yeelink云端 到yeelink官网注册一个账号 添加一个新设备,填写基本信息 点击管理设备，然后添加一个传感器 查看API文档 配置shell脚本 创建shell脚本输入命令 1touch yeelink.sh 打开yeelink.sh输入命令： 1nano yeelink.sh 编辑yeelink.sh写入如下两行，然后保存退出： 12sudo fswebcam -d /dev/video0 -r 800x600 --bottom-banner --title &quot;RaspberryPi@Yeelink&quot; --save /home/pi/yeelink.jpgcurl --request POST --data-binary @&quot;/home/pi/yeelink.jpg&quot; --header &quot;U-ApiKey:这里填写你自己的ApiKey&quot; http://api.yeelink.net/v1.0/device/你的设备码/sensor/你的传感器码/photos 为脚本增加可执行权限输入命令： 1chmod +x yeelink.sh 将脚本加入cronjob定时任务输入命令： 1crontab -e 加入下面一行, 让脚本每分钟运行一次,即发送一张图片，然后保存退出 1*/1 * * * * /home/pi/yeelink.sh 至此，我们的项目就完成了，我们可以到yeelink网站上去管理我们的设备，可以看到每隔一分钟会收到一张图片。如下图是我测试时的图片：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单片机设计与开发：前后台系统]]></title>
      <url>%2F2016%2F06%2F03%2F%E5%8D%95%E7%89%87%E6%9C%BA%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%EF%BC%9A%E5%89%8D%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"><![CDATA[前后台系统的架构简单来说就是一个大的循环，加上中断，就形成了一个整的体系。如GPIO、定时器、数码管实验等都是前后台系统架构，任务顺序地执行的，而前台指的是中断级，后台指的是main函数里的程序即任务级。 前后台系统又叫作超级大循环系统，这个可以从“while(1)”关键字眼就可以得知。这样的系统比较简单，实时性，并行性要求不太高的情况下是不错的方法，程序设计简单，思路比较清晰。但是当应用程序比较复杂的时候，如果没有一个完整的流程图，恐怕别人很难看懂程序的运行状态，而且随着程序功能的增加，编写应用程序的工程师的大脑也开始混乱。即不利于升级维护，也不利于代码优化。比较复杂一点的应用程序，使用此法虽然能够实现功能，但是自己的思维一直处于混乱状态，导致程序一直不能让自己满意。 这里通过一个简单的例子来说明前后台系统设计的思想，相信很多人平常也这么用过，但是可能并不知道这就是前后台系统的思想。很简单，我们通过单片机来实现一个温度采集并将温度显示在数码管上的小实验。在这里数码管显示就相当于前台，所以display函数放在中断服务函数里，是它能够2ms更新一次数据，然后在主函数通过while(1)循环实现后台任务，即温度采集与数据处理，最终实现温度实时更新。代码框架如下： 123456789101112131415161718192021222324252627282930313233343536void display() //数码管显示函数&#123; ........ //段选 ........ //位选 ........ //消影&#125;void init_timer() //定时器0初始化&#123; TMOD = 0x01; TH0 = (65536-2000)/256; TL0 = (65536-2000)%256; EA = 1; ET0 = 1; TR0 = 1;&#125;void main()&#123; uint temp; uchar adc,num; init_timer(); //定时器初始化 while(1) &#123; ...... //温度采集 ...... //数据处理 &#125;&#125;void timer() interrupt 1 //定时器0中断服务函数&#123; TH0 = (65536-2000)/256; TL0 = (65536-2000)%256; display(); //每2ms显示一次&#125; 当然，前后台系统设计一定要注意一条原则： 紧急的事务一定要用中断处理，中断只处理紧急事务！ 在前后台系统当中，关键的时间操作必须通过中断操作来保证实时性，由于前后台系统中的任务是顺序执行的，中断服务函数提供的信息需要后台程序走到该处理这个信息这一步时才能得到处理的，倘若任务数越多，实时性更加得不到保证，因为循环的执行时间不是常数，程序经过某一特定部分的准确时间也是不能确定的。进而，如果程序修改了，循环的时序也会受到影响。很多基于微处理器的产品采用前后台系统设计，例如微波炉、电话机、玩具等。在另外一些基于微处理器的应用中，从省电的角度出发，平时微处理器处在停机状态(halt)，所有的事都靠中断服务来完成。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树莓派+DHT11温湿度传感器+yeelink物联网云]]></title>
      <url>%2F2016%2F06%2F02%2F%E6%A0%91%E8%8E%93%E6%B4%BE-DHT11%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8-yeelink%E7%89%A9%E8%81%94%E7%BD%91%E4%BA%91%2F</url>
      <content type="text"><![CDATA[配置准备DHT11简介DHT11是一款有已校准数字信号输出的温湿度传感器。 精度湿度+-5%RH， 温度+-2℃，量程湿度20-90%RH， 温度0~50℃。 DHT11有四个引脚，分别是VCC，DATA，NC，GND 电路连接本博文中python程序使用的是BCM编号方式，17号即pin11接DHT11的DATA，VCC接3.3V，NC悬空，GND接0V，可通过下图找到对应引脚，进行连线。 用python读取温湿度数据关于DHT11具体的时序，以及如何操作，在我的博客《 51单片机DHT11温湿度传感器》中有详细分析，有兴趣可以去了解一下，以便你可以看懂下面的python程序。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#!/usr/bin/pythonimport RPi.GPIO as GPIOimport time#BCM编号方式的17对应树莓派的pin11channel = 17data = []j = 0#I/O口使用BCM编号方式GPIO.setmode(GPIO.BCM)time.sleep(1)#设置数据线为输出GPIO.setup(channel, GPIO.OUT)GPIO.output(channel, GPIO.LOW)time.sleep(0.02)GPIO.output(channel, GPIO.HIGH)#设置数据线为输入GPIO.setup(channel, GPIO.IN)while GPIO.input(channel) == GPIO.LOW: continuewhile GPIO.input(channel) == GPIO.HIGH: continuewhile j &lt; 40: k = 0 while GPIO.input(channel) == GPIO.LOW: continue while GPIO.input(channel) == GPIO.HIGH: k += 1 if k &gt; 100: break if k &lt; 8: data.append(0) else: data.append(1) j += 1print &quot;sensor is working.&quot;print data#读取数值humidity_bit = data[0:8]humidity_point_bit = data[8:16]temperature_bit = data[16:24]temperature_point_bit = data[24:32]check_bit = data[32:40]humidity = 0humidity_point = 0temperature = 0temperature_point = 0check = 0#转换数值for i in range(8): humidity += humidity_bit[i] * 2 ** (7 - i) humidity_point += humidity_point_bit[i] * 2 ** (7 - i) temperature += temperature_bit[i] * 2 ** (7 - i) temperature_point += temperature_point_bit[i] * 2 ** (7 - i) check += check_bit[i] * 2 ** (7 - i)tmp = humidity + humidity_point + temperature + temperature_point#数据校验if check == tmp: print &quot;temperature : &quot;, temperature, &quot;, humidity : &quot; , humidityelse: print &quot;wrong&quot; print &quot;temperature : &quot;, temperature, &quot;, humidity : &quot; , humidity, &quot; check : &quot;, check, &quot; tmp : &quot;, tmpGPIO.cleanup() 在python文件的路径下输入命令： 1sudo python ./dht11.py 即可获得数据，效果如图： 可以看到，当校验不正确时会打印出“wrong”，表示数据错误，在读取一次得到正常的数据。 上传数据到yeelink修改python代码在上面的代码后添加如下代码，即将温度和湿度数据保存到txt文件里： 123456789101112131415#数据转换成JSON格式mytemp = &apos;&#123;&quot;value&quot;:%f&#125;&apos; %temperaturemyhumi = &apos;&#123;&quot;value&quot;:%f&#125;&apos; %humidity#打开文件tmp_output = open(&apos;/home/pi/mytest/DHT11/tmp_data.txt&apos;, &apos;w&apos;)hud_output = open(&apos;/home/pi/mytest/DHT11/hud_data.txt&apos;, &apos;w&apos;)#写数据到文本文件中tmp_output.write(mytemp)hud_output.write(myhumi)#关闭文件tmp_output.closehud_output.close 新增yeelink.sh脚本yeelink是一个开源的硬件数据平台，我喜欢把它定义为一个物联网云平台，因为它给我们提供了API接口，我们可以把数据发送到云平台保存起来，也可以随时查看，真的很棒。具体的操作可以查看博主的博客：《 树莓派+USB摄像头+yeelink实现云监控》。 1234sudo python /home/pi/mytest/DHT11/dht11.pycurl --request POST --data-binary @&quot;/home/pi/mytest/DHT11/tmp_data.txt&quot; --header &quot;U-ApiKey:XXXXXXXXXXXXXXXX&quot; http://api.yeelink.net/v1.0/device/设备号/sensor/传感器号/datapointssleep 10scurl --request POST --data-binary @&quot;/home/pi/mytest/DHT11/hud_data.txt&quot; --header &quot;U-ApiKey:XXXXXXXXXXXXXXXX&quot; http://api.yeelink.net/v1.0/device/设备号/sensor/传感器号/datapoints “/home/pi/mytest/DHT11/tmp_data.txt”是需要上传到yeelink上的文件的路径，将XXXXXXXXXXXXXXXX替换为自已账户的API Key，后面的URL也需要替换为自己申请的传感器URL。 注意：因为DHT11可以获得温度和湿度两种值，所以我在yeelink添加了两个传感器，便于观察，在这里有两次上传数据，分别是把储存温度值得txt文本和储存湿度值得txt文本通过HTTP协议上传到云端。 为脚本增加可执行权限1sudo chmod +x yeelink.sh 将脚本加入cronjob定时任务1sudo crontab -e 让脚本自动运行加入下面一行, 让脚本每1分钟运行一次，即每1分钟上传一次数据，然后保存退出 1*/1 * * * * /home/pi/mytest/yeelink.sh 注：我给自己的实验新建了几个文件夹，路径如下：/home/pi/mytest/DHT11/，很多操作都是在这个路径下完成的。 实验效果： 温度： 湿度：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树莓派+DS18B20温度传感器+yeelink物联网云]]></title>
      <url>%2F2016%2F05%2F30%2F%E6%A0%91%E8%8E%93%E6%B4%BE-DS18B20%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8-yeelink%E7%89%A9%E8%81%94%E7%BD%91%E4%BA%91%2F</url>
      <content type="text"><![CDATA[本博文参考了网络上多篇树莓派操作DS18B20的博文，经过博主亲自实践，列出了详细的步骤，通过树莓派的单总线驱动来驱动DS18B20获取温度数据，并通过python读取温度值，上传到yeelink物联网云平台。 配置准备电路连接DS18B20有三个引脚：VCC，DQ，GND 其中VCC和DQ之间需接一个4K7的电阻，VCC接树莓派的3V3（pin1），DQ接GPIO4（pin7）,GND接GND（pin6） 升级内核首先升级内核(如果系统版本较新，可跳过这一步)（升级内核可能需要很长的时间）12sudo apt-get updatesudo apt-get upgrade 加载单总线驱动12sudo modprobe w1-gpiosudo modprobe w1-therm 注意： 系统升级后，有可能gpio读不了w1 解决办法： 打开/boot/config.txt 在最后一行手动添加这一行：dtoverlay=w1-gpio-pullup,gpiopin=4 12cd /bootsudo nano config.txt 然后保存退出，重启树莓派，再把DS18B20接上，再次加载驱动即可 查看设备是否工作12cd /sys/bus/w1/devices/ls 28-0000075a0d1c即为我使用的DS18B20的设备号 查看当前温度值进入到我的DSI8B20，使用命令查看数据 12cd 28-0000075a0d1ccat w1_slave 第二行的t=18437就是当前的温度值，要换算成摄氏度，除以1000，即当前温度为18437/1000=18.437摄氏度。 python读取温度值新建文件在/home/pi/目录下新建文件夹mytest，并在mytest下新建temp.py 123mkdir mytestcd mytesttouch temp.py 编辑temp.py1nano temp.py 编写代码123456789101112131415161718192021222324#-*-coding:utf8-*-#打开你的DS18B20的数据文件tfile = open(&quot;/sys/bus/w1/devices/28-0000075a0d1c/w1_slave&quot;)#读取文件所有内容text = tfile.read()#关闭文件tfile.close()#用换行符分割字符串成数组，并取第二行secondline = text.split(&quot;\n&quot;)[1]#用空格分割字符串成数组，并取最后一个，即t=18437temperaturedata = secondline.split(&quot; &quot;)[9]#取t=后面的数值，并转换为浮点型temperature = float(temperaturedata[2:])#转换单位为摄氏度temperature = temperature / 1000#打印值print temperature 执行python脚本读取温度1python temp.py 上传数据到yeelink云端yeelink是一个开源的硬件数据平台，我喜欢把它定义为一个物联网云平台，因为它给我们提供了API接口，我们可以把数据发送到云平台保存起来，也可以随时查看，真的很棒。具体的操作可以查看博主的博客：《 树莓派+USB摄像头+yeelink实现云监控》。 修改python代码将温度值用JSON格式保存到一个文本文件（/home/pi/mytest/temper_data.txt），在转换单位为摄氏度后添加如下代码： 1234567891011#数据转换成JSON格式res = &apos;&#123;&quot;value&quot;:%f&#125;&apos; %temperature#打开文件output = open(&apos;/home/pi/mytest/temper_data.txt&apos;, &apos;w&apos;)#写数据到文本文件中output.write(res)#关闭文件output.close 新增yeelink.sh脚本在/home/pi/mytest/目录下新建yeelink.sh 写入如下内容： 12sudo python /home/pi/mytest/temp.pycurl --request POST --data-binary @&quot;/home/pi/mytest/temper_data.txt&quot; --header &quot;U-ApiKey:XXXXXXXXXXXXXXXX&quot; http://api.yeelink.net/v1.0/device/设备号/sensor/传感器号/datapoints 将XXXXXXXXXXXXXXXX替换为自已账户的API Key，后面的URL也需要替换为自己申请的传感器URL。 为脚本增加可执行权限1sudo chmod +x yeelink.sh 将脚本加入cronjob定时任务1sudo crontab -e 让脚本自动运行加入下面一行, 让脚本每1分钟运行一次，即每1分钟上传一次温度数据，然后保存退出 1*/1 * * * * /home/pi/mytest/yeelink.sh 实验效果：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树莓派自动发送ip到指定邮箱]]></title>
      <url>%2F2016%2F05%2F26%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E8%87%AA%E5%8A%A8%E5%8F%91%E9%80%81ip%E5%88%B0%E6%8C%87%E5%AE%9A%E9%82%AE%E7%AE%B1%2F</url>
      <content type="text"><![CDATA[知道树莓派的ip地址才能通过SSH或者VNC在你的电脑上操作树莓派，树莓派开机自动发送ip地址到指定邮箱会让你使用树莓派更加方便！ 新建一个python脚本文件输入命令 1touch send_ip.py 编写python脚本（1）输入命令 1sudo vim send_ip.py （2）写入以下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!\usr\bin\env python#-*-coding: utf-8-*-import socketimport timeimport smtplibimport urllibfrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom email.mime.image import MIMEImage#发送邮件的基本函数，参数依次如下# smtp服务器地址、邮箱用户名，邮箱秘密，发件人地址，手贱儿女地址（列表的方式），邮件主题，邮件html内容def sendEmail(smtpserver,username,password,sender,receiver,subject,msghtml): msgRoot =MIMEMultipart(&apos;reklated&apos;) msgRoot[&apos;To&apos;]=&apos;,&apos;.join(receiver) msgRoot[&apos;Subject&apos;]= subject msgText = MIMEText(msghtml,&apos;html&apos;,&apos;utf-8&apos;) msgRoot.attach(msgText) smtp = smtplib.SMTP() smtp.connect(smtpserver,&quot;25&quot;) smtp.login(username,password) print &quot;YES&quot; smtp.quit()#检查网络连通性def check_network(): while True: try: result=urllib.urlopen(&apos;http://baidu.com&apos;).read() print result print &quot;Network is Ready!&quot; break except Exception , e: print e print &quot;Network is not ready,Sleep 5s...&quot; time.sleep(5) return True#获取本级制定接口的ip地址def get_ip_address(): s =socket.socket(socket.AF_INET,socket.SOCK_DGRAM) s.connect((&quot;1.1.1.1&quot;,80)) ipaddr=s.getsockname()[0] s.close() return ipaddrif __name__ == &apos;__main__&apos; : check_network() ipaddr= get_ip_address() sendEmail(&quot;smtp.sohu.com&quot;,&apos;你的邮箱帐号&apos;,&apos;你的邮箱密码&apos;,&apos;发件人地址&apos;,[&apos;收件人地址&apos;],&apos;IP Address of Raspberry PI&apos;,ipaddr) （3）保存退出 vim编辑器下保存退出步骤为： 按esc然后输入：，然后看到冒号显示出来再输入wq，回车即可 设置开机自动执行该脚本在/etc/rc.local文件里加入下面这一行： 1/usr/bin/python/home/pi/send_ip.py 输入命令： 1sudo vim /etc/rc.local 在文件中添加/usr/bin/python/home/pi/send_ip.py然后保存退出 特别提示：收到的邮件有可能在垃圾箱里，不要以为是脚本的问题，其实是邮箱的问题，请注意查看！另外，有的邮箱不支持smtp，所以无法使用。搜狐和网易的邮箱亲测可用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树莓派网线直连笔记本电脑]]></title>
      <url>%2F2016%2F05%2F23%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E7%BD%91%E7%BA%BF%E7%9B%B4%E8%BF%9E%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%2F</url>
      <content type="text"><![CDATA[查看网络连接状况运行DOS窗口，输入arp -a，可以看到没有连接树莓派时的网络连接情况。红色方框为笔记本连接无线网络的网络信息。 连线树莓派接好供电线；将网线一端接到树莓派，另一端接到笔记本。 共享无线网络如果现在笔记本已经通过WIFI连接到互联网，可以将无线网卡的互联网资源共享给本地连接。以win7系统为例，开始——控制面板——网络和Internet——网络和共享中心——查看网络状态和任务——更改适配器设置，找到无线网络连接右键“属性”，在共享选项卡上选中“允许其他网络用户通过此计算机的Internet连接来连接（N）”选项，下拉列表选择树莓派的那个网络，最后点确定。 查找树莓派的IP地址运行DOS窗口，输入arp -a，在这里可以看到在笔记本无线网络信息的上面（红色标注）多出来一个接口（蓝色标注），黄色标注的ip地址即为树莓派的ip地址。 利用Xshell或者PuTTY软件连接树莓派通过树莓派的ip地址登录到树莓派，树莓派的默认账号为pi，密码为raspberry。登录后可以看到树莓派操作系统的命令行界面。 图形化界面连接树莓派端： 在命令行界面安装VNCserver （1）安装VNC 1sudo apt-get install tightvncserver （2）增加一个桌面 1tightvncserver （3）启动VNC服务器 1vncserver 首次使用时需设置密码，当提示输入密码时，创建一个密码 (这个密码是远程用户访问时用的） （4）关闭VNC服务器 1vncserver -kill PC端： 在windows上下载安装下载VNC viewer地址http://www.tightvnc.com/download.php： （1）下载Window版的 VNC-Viewer ，无需安装，解压即可。 比如，解压出：VNC-Viewer-5.0.3-Windows-32bit.exe 。 （2）运行 VNC-Viewer 。 （3）输入树莓派的ip地址以及访问密码，即可登录到树莓派，并显示图形化界面。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树莓派配置无线网卡]]></title>
      <url>%2F2016%2F05%2F22%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%2F</url>
      <content type="text"><![CDATA[查看无线网卡状态把无线网卡插到树莓派上，输入命令ifconfig 查看是否有wlan0的信息，如果有说明网卡状态正常，可以直接进行第二步，直接配置无线网络。如果看不到wlan0的信息，则需要根据无线网卡型号安装驱动。 修改interfaces文件（1）用编辑器nano打开interfaces文件输入命令：sudo nano /etc/network/interfaces （2）把该文件内容修改成如下： 12345678910auto lo iface lo inet loopbackiface eth0 inet dhcp #采用dhcp方式获取IPauto wlan0 #如果有wlan，无线网卡，则默认启动无线网卡连接allow-hotplug wlan0 #表示wlan设备可以热插拨iface wlan0 inet dhcp #无线网卡连接也采用DHCP方式获取IP地址wpa-ssid &quot;你的wifi名字&quot; #ssid名wpa-psk &quot;wifi密码&quot; #wifi使用wpa-psk认证方式，认证密码iface default inet dhcp （3）保存，退出 启用无线网（1）用 ifconfig 命令可以看到 wlan0 设备，且有了IP地址(即表示已连接)。 （2）如果没有IP地址，则依次输入命令：sudo ifdown wlan0和sudo ifup wlan0来启用wlan0 （3）如果还不行，执行命令sudo reboot重启即可连上无线网络]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树莓派安装Linux操作系统]]></title>
      <url>%2F2016%2F05%2F18%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"><![CDATA[树莓派上可安装的操作系统（1）Linux：Raspbian,Arch Linux ARM （2）Unix：FreeBSD,NetBSD （3）Windows: Windows 10 for Raspberry Pi 2 其中： 使用最广泛：Raspbian——基于Debian，为树莓派优化 强调定制性：Arch Linux ARM——为轻量，简洁，定制而生 Raspbmc——用Kodi（XBMC/Xbox Media Center）打造多媒体中心 Chromium OS——云端操作系统，中国大陆用户不方便使用 Windows 10 loT物联网版本 Linux操作系统安装方法使用NOOBS来安装系统（1）将TF卡格式化为FAT32格式 注意：TF（micro SD）卡需要大于等于4GB，而且并不是所有TF卡都能兼容树莓派，需百度查询兼容性列表 （2） 到树莓派官网下载NOOBS（进入主页后点击DOWNLOAD就可以看到NOOBS了） （3）将NOOBS解压后的所有文件拷贝到TF卡的根目录下 （4）连接显示器，并给树莓派上电（5V，2A电源，也可直接使用电脑的USB插口） （5）初始化完成以后，你会进入NOOBS助手界面 （6）选择你需要安装的操作系统，然后点击上方的install OS即可进入安装 （7）完成后点击确认，然后Raspberry Pi会重启，至此系统安装完成 直接安装Linux系统到SD卡（1）到树莓派官网下载你需要的官方系统镜像 （2）下载安装镜像的工具win32diskimager （3）运行Win32DiskImager，在软件中选择系统镜像（img文件），然后device(设备）下选择TF卡盘符，点击write，等待写入完全，等到出现对话框write successful就说明成功了。 注意：写入完成后，win系统下看到SD只有几十MB了，这是正常现象，因为linux下的分区win下是看不到的！ （4）连接显示器，并给树莓派上电，至此系统安装完成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android ImageView实现圆形头像]]></title>
      <url>%2F2016%2F05%2F17%2FAndroid-ImageView%E5%AE%9E%E7%8E%B0%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8F%2F</url>
      <content type="text"><![CDATA[原理解析先在canvas上面画一个圆形，参照圆形的起点坐标、半径，再画一个边长为圆的直径的bitmap（这个bitmap就是你想画的圆形头像），此时圆和bitmap重叠在一起，圆在下面，bitmap在上面，bitmap覆盖着圆。 这时，圆形和bitmap相交的部分正是圆大小的面积，如果能将bitmap与圆相交之外的部分去掉，那么我们看到的就是bitmap的圆形部分了。 代码实现1234567891011121314151617181920212223242526272829303132public Bitmap toRoundBitmap(Bitmap bitmap) &#123; //圆形图片宽高 int width = bitmap.getWidth(); int height = bitmap.getHeight(); //正方形的边长 int r = 0; //取最短边做边长 if(width &amp;amp;amp;gt; height) &#123; r = height; &#125; else &#123; r = width; &#125; //构建一个bitmap Bitmap backgroundBmp = Bitmap.createBitmap(width, height, Config.ARGB_8888); //new一个Canvas，在backgroundBmp上画图 Canvas canvas = new Canvas(backgroundBmp); Paint paint = new Paint(); //设置边缘光滑，去掉锯齿 paint.setAntiAlias(true); //宽高相等，即正方形 RectF rect = new RectF(0, 0, r, r); //通过制定的rect画一个圆角矩形，当圆角X轴方向的半径等于Y轴方向的半径时， //且都等于r/2时，画出来的圆角矩形就是圆形 canvas.drawRoundRect(rect, r/2, r/2, paint); //设置当两个图形相交时的模式，SRC_IN为取SRC图形相交的部分，多余的将被去掉 paint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN)); //canvas将bitmap画在backgroundBmp上 canvas.drawBitmap(bitmap, null, rect, paint); //返回已经绘画好的backgroundBmp return backgroundBmp; &#125; 使用详解从res目录下的drawable文件夹获取图片资源进行转换1234567891011// 以数据流的方式读取bitmap资源Resources r = this.getResources();InputStream is = r.openRawResource(R.drawable.iv_head);BitmapDrawable bmpDraw = new BitmapDrawable(is);Bitmap bmp = bmpDraw.getBitmap(); // 将图片转换成圆形图片Bitmap bm = toRoundBitmap(bmp); //传给imagview进行显示imageview.setImageBitmap(bm); 从sdcard中获取图片资源进行转换注意：需添加sdcard读取数据的权限 1234567Bitmap bmp = BitmapFactory.decodeFile(path) (path 是图片的路径，根目录是/sdcard) // 将图片转换成圆形图片Bitmap bm = toRoundBitmap(bmp); //传给imagview进行显示imageview.setImageBitmap(bm);]]></content>
    </entry>

    
  
  
</search>
